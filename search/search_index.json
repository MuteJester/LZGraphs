{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to LZGraph Docs","text":"<p>This site contains the documentation for the <code>LZGraph</code> model and the applications around it as seen in the paper cite.  </p> <p>For a quick pug-and-play tutorials visit the Tutorials page for all the useful functionality provided by the LZGraph library.</p> <p>The documentation is divided into a few sections that aim to get the reader to use the functions and data structures implemented in this library in the most effective and quick manner.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install the library run:  <pre><code>pip install LZGraphs</code></pre></p>"},{"location":"#contact","title":"Contact","text":"<p>For any questions / requests related to the library contact:</p> <p>Thomas Konstantinovsky - thomaskon90@gmail.com</p>"},{"location":"aaplzgraph_reference/","title":"AAPLZGraph Class","text":""},{"location":"aaplzgraph_reference/#LZGraphs.AminoAcidPositional.AAPLZGraph","title":"<code>AAPLZGraph</code>","text":"<p>         Bases: <code>LZGraphBase</code></p> <pre><code>  This class implements the logic and infrastructure of the \"Amino Acid Positional\" version of the LZGraph\n  The nodes of this graph are LZ sub-patterns based on amino acids with added start position\n  in the sequence, formally: {lz_subpattern}_{start position in sequence},\n  This class best fits analysis and inference of amino acid sequences.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>walk_probability(walk,verbose=True)</code> <p>returns the PGEN of the given walk (list of sub-patterns)</p> required <code>is_dag()</code> <p>the function checks whether the graph is a Directed acyclic graph</p> required <code>walk_genes(walk,dropna=True)</code> <p>give a walk on the graph (a list of nodes) the function will return a table representing the possible genes and their probabilities at each edge of the walk.</p> required <code>path_gene_table(cdr3_sample,threshold=None)</code> <p>the function will return two tables of all possible v and j genes that colud be used to generate the sequence given by \"cdr3_sample\"</p> required <code>path_gene_table_plot(threshold=None,figsize=None)</code> <p>the function plots two heatmap, one for V genes and one for J genes, and represents the probability at each edge to select that gene, the color at each cell is equal to the probability of selecting the gene, a black cell means that the graph didn't see that gene used with that sub-pattern.</p> <p>the data used to create the charts can be derived by using the \"path_gene_table\" method.</p> required <code>gene_variation(cdr3)</code> <p>given a sequence, this will derive a charts that shows the number of V and J genes observed per node (LZ- subpattern).</p> required <code>gene_variation_plot(cdr3)</code> <p>Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count and one for J gene count.</p> required <code>random_walk(steps)</code> <p>given a number of steps (sub-patterns) returns a random walk on the graph between a random inital state to a random terminal state in the given number of steps</p> required <code>gene_random_walk(seq_len,</code> <code>initial_state</code> <p>given a target sequence length and an initial state, the function will select a random V and a random J genes from the observed gene frequency in the graph's \"Training data\" and generate a walk on the graph from the initial state to a terminal state while making sure at each step that both the selected V and J genes were seen used by that specific sub-pattern.</p> required <code>unsupervised_random_walk()</code> <p>a random initial state and a random terminal state are selected and a random unsupervised walk is carried out until the randomly selected terminal state is reached.</p> required <code>eigenvector_centrality()</code> <p>return the eigen vector centrality value for each node (this function is used as the feature extractor for the LZGraph)</p> required <code>sequence_variation_curve(cdr3_sample)</code> <p>given a cdr3 sequence, the function will calculate the value of the variation curve and return 2 arrays, 1 of the sub-patterns and 1 for the number of out neighbours for each sub-pattern</p> required <code>graph_summary()</code> <p>the function will return a pandas DataFrame containing the graphs Chromatic Number,Number of Isolates,Max In Deg,Max Out Deg,Number of Edges</p> required <p>Attributes:             nodes:                 returns the nodes of the graph             edges:                 return the edges of the graph</p> Source code in <code>LZGraphs\\AminoAcidPositional.py</code> <pre><code>class AAPLZGraph(LZGraphBase):\n\"\"\"\n              This class implements the logic and infrastructure of the \"Amino Acid Positional\" version of the LZGraph\n              The nodes of this graph are LZ sub-patterns based on amino acids with added start position\n              in the sequence, formally: {lz_subpattern}_{start position in sequence},\n              This class best fits analysis and inference of amino acid sequences.\n        Args:\n              walk_probability(walk,verbose=True):\n                  returns the PGEN of the given walk (list of sub-patterns)\n              is_dag():\n                the function checks whether the graph is a Directed acyclic graph\n              walk_genes(walk,dropna=True):\n                give a walk on the graph (a list of nodes) the function will return a table\n                representing the possible genes and their probabilities at each edge of the walk.\n              path_gene_table(cdr3_sample,threshold=None):\n                the function will return two tables of all possible v and j genes\n                that colud be used to generate the sequence given by \"cdr3_sample\"\n              path_gene_table_plot(threshold=None,figsize=None):\n                the function plots two heatmap, one for V genes and one for J genes,\n                and represents the probability at each edge to select that gene,\n                the color at each cell is equal to the probability of selecting the gene, a black\n                cell means that the graph didn't see that gene used with that sub-pattern.\n                the data used to create the charts can be derived by using the \"path_gene_table\" method.\n              gene_variation(cdr3):\n                given a sequence, this will derive a charts that shows the number of V and J genes observed\n                per node (LZ- subpattern).\n              gene_variation_plot(cdr3):\n                Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count\n                and one for J gene count.\n              random_walk(steps):\n                 given a number of steps (sub-patterns) returns a random walk on the graph between a random inital state\n                 to a random terminal state in the given number of steps\n              gene_random_walk(seq_len, initial_state):\n                given a target sequence length and an initial state, the function will select a random\n                V and a random J genes from the observed gene frequency in the graph's \"Training data\" and\n                generate a walk on the graph from the initial state to a terminal state while making sure\n                at each step that both the selected V and J genes were seen used by that specific sub-pattern.\n              unsupervised_random_walk():\n                a random initial state and a random terminal state are selected and a random unsupervised walk is\n                carried out until the randomly selected terminal state is reached.\n              eigenvector_centrality():\n                return the eigen vector centrality value for each node (this function is used as the feature extractor\n                for the LZGraph)\n              sequence_variation_curve(cdr3_sample):\n                given a cdr3 sequence, the function will calculate the value of the variation curve and return\n                2 arrays, 1 of the sub-patterns and 1 for the number of out neighbours for each sub-pattern\n              graph_summary():\n                the function will return a pandas DataFrame containing the graphs\n                Chromatic Number,Number of Isolates,Max In Deg,Max Out Deg,Number of Edges\n         Attributes:\n                    nodes:\n                        returns the nodes of the graph\n                    edges:\n                        return the edges of the graph\n        \"\"\"\ndef __init__(self, data, verbose=True, calculate_trainset_pgen=False):\n\"\"\"\n        data has to be a pandas dataframe, the cdr3 amino acid sequence has to be under a column named\n        \"cdr3_amino_acid\"\n        and optionally you can add two columns \"V\" and \"J\" with the gene annotation for each sequence\n        Args:\n            data (pd.DataFrame): a dataframe containing the sequences for which to consturct an LZGraph and any\n            additional V/J Data given provided under the \"V\" column and a \"J\" column.\n            verbose\n        \"\"\"\nsuper().__init__()\n# check for V and J gene data in input\nself.genetic = True if type(data) == pd.DataFrame and 'V' in data.columns and 'J' in data.columns else False\nif self.genetic:\nself._load_gene_data(data)\nself.verbose_driver(0, verbose)\n# construct the graph while iterating over the data\nself.__simultaneous_graph_construction(data)\nself.verbose_driver(1, verbose)\n# convert to pandas series and  normalize\nself.length_distribution = pd.Series(self.lengths)\nself.terminal_states = pd.Series(self.terminal_states)\nself.initial_states = pd.Series(self.initial_states)\nself.length_distribution_proba = self.terminal_states / self.terminal_states.sum()\nself.initial_states = self.initial_states[self.initial_states &gt; 5]\nself.initial_states_probability = self.initial_states/self.initial_states.sum()\nself.verbose_driver(2, verbose)\nself._derive_subpattern_individual_probability()\nself.verbose_driver(8, verbose)\nself._normalize_edge_weights()\nself.verbose_driver(3, verbose)\nif self.genetic:\n# Normalized Gene Weights\nself._batch_gene_weight_normalization(3, verbose)\nself.verbose_driver(4, verbose)\nself.edges_list = None\nself._derive_terminal_state_map()\nself.verbose_driver(7, verbose)\nself._derive_stop_probability_data()\nself.verbose_driver(8, verbose)\nself.verbose_driver(5, verbose)\nif calculate_trainset_pgen:\nself.train_pgen = np.array(\n[self.walk_probability(self.encode_sequence(i), verbose=False) for i in data.cdr3_amino_acid])\nself.constructor_end_time = time()\nself.verbose_driver(6, verbose)\nself.verbose_driver(-2, verbose)\n@staticmethod\ndef encode_sequence(amino_acid):\n\"\"\"\n        This function will take a sequence and return it as LZ sub-patterns with added position\n        the general format is given as {LZ-subpattern}_{start_index}\n        Args:\n            amino_acid (str)\n        \"\"\"\nlz, loc = derive_lz_and_position(amino_acid)\nreturn list(map(lambda x, z: x + '_' + str(z), lz, loc))\n@staticmethod\ndef clean_node(base):\n\"\"\"\n        This Function will take in a sub-pattern that has position added to it and clean\n        the added values returning only the amino acid value\n        Args:\n            base (str)\n        \"\"\"\nreturn re.search(r'[A-Z]*', base).group()\ndef _decomposed_sequence_generator(self,data):\nif self.genetic:\nfor cdr3,v,j in tqdm(zip(data['cdr3_amino_acid'],data['V'],data['J']), leave=False):\nLZ, locs = derive_lz_and_position(cdr3)\nsteps = (window(LZ, 2))\nlocations = (window(locs, 2))\nself.lengths[len(cdr3)] = self.lengths.get(len(cdr3), 0) + 1\nself._update_terminal_states(LZ[-1] + '_' + str(locs[-1]))\nself._update_initial_states(LZ[0] + '_1')\nyield steps,locations,v,j\nelse:\nfor cdr3 in tqdm(list(data), leave=False):\nLZ, locations_ = derive_lz_and_position(cdr3)\nsteps = (window(LZ, 2))\nlocations = (window(locations_, 2))\nself.lengths[len(cdr3)] = self.lengths.get(len(cdr3), 0) + 1\nself._update_terminal_states(LZ[-1] + '_' + str(locations_[-1]))\nself._update_initial_states(LZ[0] + '_1')\nyield steps,locations\ndef __simultaneous_graph_construction(self, data):\nprocessing_stream = self._decomposed_sequence_generator(data)\nif self.genetic:\nfor output in processing_stream:\nsteps, locations,v,j = output\nfor (A, B), (loc_a, loc_b) in zip(steps, locations):\nA_ = A + '_' + str(loc_a)\nself.per_node_observed_frequency[A_] = self.per_node_observed_frequency.get(A_, 0) + 1\nB_ = B + '_' + str(loc_b)\nself._insert_edge_and_information(A_, B_, v, j)\nself.per_node_observed_frequency[B_] = self.per_node_observed_frequency.get(B_, 0)\nelse:\nfor output in processing_stream:\nsteps, locations = output\nfor (A, B), (loc_a, loc_b) in zip(steps, locations):\nA_ = A + '_' + str(loc_a)\nself.per_node_observed_frequency[A_] = self.per_node_observed_frequency.get(A_, 0) + 1\nB_ = B + '_' + str(loc_b)\nself._insert_edge_and_information_no_genes(A_, B_)\nself.per_node_observed_frequency[B_] = self.per_node_observed_frequency.get(B_, 0)\ndef walk_probability(self, walk, verbose=True, use_epsilon=False):\n\"\"\"\n                    given a walk (a sequence converted into LZ sub-pattern) return the probability of generation (PGEN)\n                    of the walk.\n                    you can use \"lempel_ziv_decomposition\" from this libraries decomposition module in order to convert a\n                    sequence into LZ sub-patterns\n                             Parameters:\n                                     walk (list): a list of LZ - sub-patterns\n                             Returns:\n                                     float : the probability of generating such a walk (PGEN)\n                      \"\"\"\nif type(walk) == str:\nLZ, POS = derive_lz_and_position(walk)\nwalk_ = [i + str(j) for i, j in zip(LZ, POS)]\nelse:\nwalk_ = walk\nif walk_[0] not in self.subpattern_individual_probability['proba']:\nreturn np.finfo(float).eps ** 2\nproba = self.subpattern_individual_probability['proba'][walk_[0]]\nn_missing = 0\ntotal = 0\nfor step1, step2 in window(walk_, 2):\nif self.graph.has_edge(step1, step2):\nproba *= self.graph.get_edge_data(step1, step2)['weight']\nelse:\nif verbose:\nprint('No Edge Connecting| ', step1, '--&gt;', step2)\nn_missing += 1\ntotal += 1\nif n_missing &gt; 0:\ngmean = np.power(proba, (1 / total))\nproba = proba * (gmean ** n_missing)\nreturn proba\ndef walk_gene_probability(self, walk, v, j, verbose=True, use_epsilon=False):\nif type(walk) == str:\nLZ, POS = derive_lz_and_position(walk)\nwalk_ = [i + str(j) for i, j in zip(LZ, POS)]\nelse:\nwalk_ = walk\nproba_v = self.marginal_vgenes.loc[v]\nproba_j = self.marginal_jgenes.loc[j]\nfor step1, step2 in window(walk_, 2):\nif self.graph.has_edge(step1, step2):\nproba_v *= self.graph.get_edge_data(step1, step2)[v]\nproba_j *= self.graph.get_edge_data(step1, step2)[j]\nelse:\nif verbose:\nprint('No Edge Connecting| ', step1, '--&gt;', step2)\nif use_epsilon:\nreturn np.finfo(np.float64).eps\nelse:\nreturn 0\nreturn proba_v, proba_j\n# def random_walk(self, seq_len, initial_state):\n#     \"\"\"\n#       given a number of steps (sub-patterns) returns a random walk on the graph between a random inital state\n#         to a random terminal state in the given number of steps\n#\n#\n#                  Parameters:\n#                          steps (int): number of sub-patterns the resulting walk should contain\n#                  Returns:\n#                          (list) : a list of LZ sub-patterns representing the random walk\n#                   \"\"\"\n#     current_state = initial_state\n#     walk = [initial_state]\n#     sequence = clean_node(initial_state)\n#\n#     final_states = self._length_specific_terminal_state(seq_len)\n#\n#     if len(final_states) &lt; 1:\n#         raise Exception('Unfamiliar Seq Length')\n#\n#     while current_state not in final_states:\n#         states, probabilities = self._get_state_weights(current_state)\n#         # Try add dynamic dictionary of weight that will remove invalid paths\n#\n#         # if went into a final path with mismatch length\n#         if len(probabilities) == 0:  # no options we can take from here\n#             # go back to the last junction where a different choice can be made\n#             for ax in range(len(walk) - 1, 1, -1):\n#                 for final_s in final_states:\n#                     try:\n#                         SP = nx.dijkstra_path(self.graph, source=walk[ax], target=final_s,\n#                                               weight=lambda x, y, z: 1 - z['weight'])\n#                         walk = walk[:ax] + SP\n#                         sequence = ''.join([clean_node(i) for i in walk])\n#                         return walk\n#                     except nx.NetworkXNoPath:\n#                         continue\n#\n#         current_state = np.random.choice(states, size=1, p=probabilities).item()\n#         walk.append(current_state)\n#         sequence += clean_node(current_state)\n#\n#     return walk\ndef multi_gene_random_walk(self, N, seq_len, initial_state=None, vj_init='marginal'):\nselected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\nif seq_len == 'unsupervised':\nfinal_states = self.terminal_states.index.to_list().copy()\nelse:\nfinal_states = self._length_specific_terminal_state(seq_len)\n# nodes not to consider due to invalidity\nif self.genetic_walks_black_list is None:\nself.genetic_walks_black_list = dict()\nresults = []\nlengths = pd.Series(self.terminal_states).value_counts()\nmax_length = lengths.idxmax()\nfor _ in tqdm(range(N)):\nif initial_state is None:\ncurrent_state = self._random_initial_state()\nwalk = [current_state]\nelse:\ncurrent_state = initial_state\nwalk = [initial_state]\n# while the walk is not in a valid final state\nwhile current_state not in lengths.index:\n# print('Blacklist: ',blacklist)\n# print('='*30)\n# get the node_data for the current state\nedge_info = pd.DataFrame(dict(self.graph[current_state]))\nif (current_state, selected_gene_path_v, selected_gene_path_j) in self.genetic_walks_black_list:\nedge_info = edge_info.drop(columns=self.genetic_walks_black_list[\n(current_state, selected_gene_path_v, selected_gene_path_j)])\n# check selected path has genes\nif len(set(edge_info.index) &amp; {selected_gene_path_v, selected_gene_path_j}) != 2:\n# TODO: add a visited node stack to not repeat the same calls and mistakes\nif len(walk) &gt; 2:\nself.genetic_walks_black_list[(walk[-2], selected_gene_path_v, selected_gene_path_j)] \\\n                            = self.genetic_walks_black_list.get((walk[-2], selected_gene_path_v, selected_gene_path_j),\n[]) + [walk[-1]]\ncurrent_state = walk[-2]\nwalk = walk[:-1]\nelse:\nwalk = walk[:1]\ncurrent_state = walk[0]\nselected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\ncontinue\n# get paths containing selected_genes\nidf = edge_info.T[[selected_gene_path_v, selected_gene_path_j]].dropna()\nw = edge_info.loc['weight', idf.index]\nw = w / w.sum()\nif len(w) == 0:\nif len(walk) &gt; 2:\nself.genetic_walks_black_list[(walk[-2], selected_gene_path_v, selected_gene_path_j)] = \\\n                            self.genetic_walks_black_list.get((walk[-2], selected_gene_path_v, selected_gene_path_j),\n[]) + [walk[-1]]\ncurrent_state = walk[-2]\nwalk = walk[:-1]\nelse:\nwalk = walk[:1]\ncurrent_state = walk[0]\nselected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\ncontinue\ncurrent_state = np.random.choice(w.index, size=1, p=w.values).item()\nwalk.append(current_state)\nresults.append((walk, selected_gene_path_v, selected_gene_path_j))\nif walk[-1] in lengths.index and walk[-1] != max_length:  # [lengths &lt;= lengths.max()].index:\nlengths[walk[-1]] -= 1\nif lengths[walk[-1]] &lt; 0:\nlengths.pop(walk[-1])\nreturn results\ndef unsupervised_random_walk(self):\n\"\"\"\n     a random initial state and a random terminal state are selected and a random unsupervised walk is\n    carried out until the randomly selected terminal state is reached.\n              Parameters:\n                      None\n              Returns:\n                      (list,str) : a list of LZ sub-patterns representing the random walk and a string\n                      matching the walk only translated back into a sequence.\n                       \"\"\"\nrandom_initial_state = self._random_initial_state()\ncurrent_state = random_initial_state\nwalk = [random_initial_state]\nsequence = self.clean_node(random_initial_state)\nwhile not self.is_stop_condition(current_state):\n# take a random step\ncurrent_state = self.random_step(current_state)\nwalk.append(current_state)\nsequence += self.clean_node(current_state)\nreturn walk, sequence\ndef walk_genes(self, walk, dropna=True,raise_error=True):\n\"\"\"\n               give a walk on the graph (a list of nodes) the function will return a table\n                   representing the possible genes and their probabilities at each edge of the walk.\n           Args:\n            walk (list): a list of nodes representing a walk on the graph.\n            dropna (bool): whether to drop the edges that are missing from the graph.\n           \"\"\"\ntrans_genes = dict()\nfor i in range(0, len(walk) - 1):\nif self.graph.has_edge(walk[i], walk[i + 1]):\nls = self.graph.get_edge_data(walk[i], walk[i + 1]).copy()\nls.pop('weight')\nls.pop('Vsum')\nls.pop('Jsum')\ntrans_genes[walk[i] + '-&gt;' + walk[i + 1]] = ls\ncc = pd.DataFrame(trans_genes)\nif dropna:\ncc = cc.dropna()\nif cc.shape[0] == 0 and raise_error:\nraise Exception('No Constant Gene Flow F')\ncc['type'] = ['v' if 'v' in x.lower() else 'j' for x in cc.index]\ncc['sum'] = cc.sum(axis=1, numeric_only=True)\n#cc = cc.sort_values(by='sum', ascending=False)\nreturn cc\ndef random_walk_distribution_based(self, length_distribution):\nN = length_distribution.sum()\nN = N * 3\nrwalks = []\nrseqs = []\nfor _ in tqdm(range(N)):\nrw = self.unsupervised_random_walk()\nrwalks.append(rw[0])\nrseqs.append(rw[1])\nR = pd.DataFrame({'Seqs': rseqs, 'Walks': rwalks})\nR['L'] = R['Seqs'].str.len()\nsamples = []\nfor length in length_distribution.index:\nsamples.append(R[R['L'] == length].sample(length_distribution[length]))\nreturn pd.concat(samples).iloc[:, :-1].values\ndef get_gene_graph(self, v, j):\nto_drop = []\nif self.edges_list is None:\nself.edges_list = list(self.graph.edges(data=True))\nfor edge in self.edges_list:\nif v in edge[2] and j in edge[2]:\ncontinue\nelse:\nto_drop.append((edge[0], edge[1]))\nG = self.graph.copy()\nG.remove_edges_from(to_drop)\nG.remove_nodes_from(list(nx.isolates(G)))\nreturn G\ndef cac_random_gene_walk(self, initial_state=None, vj_init='combined'):\nselected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\nif (selected_gene_path_v, selected_gene_path_j) not in self.cac_graphs:\nG = self.get_gene_graph(selected_gene_path_v, selected_gene_path_j)\nself.cac_graphs[(selected_gene_path_v, selected_gene_path_j)] = G\nelse:\nG = self.cac_graphs[(selected_gene_path_v, selected_gene_path_j)]\nfinal_states = self.terminal_states.copy()\nfinal_states = list(set(final_states) &amp; set(G.nodes))\nfirst_states = self.initial_states.copy()\nfirst_states = first_states.loc[list(set(first_states.index) &amp; set(G.nodes))]\nfirst_states = (first_states / first_states.sum())\ncurrent_state = np.random.choice(first_states.index, size=1, p=first_states.values)[0]\nwalk = [current_state]\n# nodes not to consider due to invalidity\nif self.genetic_walks_black_list is None:\nself.genetic_walks_black_list = dict()\n# while the walk is not in a valid final state\nwhile current_state not in final_states:\n# get the node_data for the current state\nedge_info = pd.DataFrame(dict(G[current_state]))\nif (selected_gene_path_v, selected_gene_path_j, current_state) in self.genetic_walks_black_list:\nedge_info = edge_info.drop(\ncolumns=self.genetic_walks_black_list[(selected_gene_path_v, selected_gene_path_j, current_state)])\nif edge_info.shape[1] == 0:\nself.genetic_walks_black_list[(selected_gene_path_v, selected_gene_path_j, walk[-2])] = \\\n                    self.genetic_walks_black_list.get((selected_gene_path_v, selected_gene_path_j, walk[-2]), []) + [\ncurrent_state]\nwalk = walk[:-1]\ncurrent_state = walk[-1]\ncontinue\n# get paths containing selected_genes\nidf = edge_info.T[[selected_gene_path_v, selected_gene_path_j]].dropna()\nw = edge_info.loc['weight', idf.index]\nw = w / w.sum()\ncurrent_state = np.random.choice(w.index, size=1, p=w.values).item()\nwalk.append(current_state)\nreturn walk, selected_gene_path_v, selected_gene_path_j\ndef sequence_variation_curve(self, cdr3_sample):\n\"\"\"\n        given a sequence this function will return 2 list,\n        the first is the lz-subpattern path through the graph and the second list is the number\n        of possible choices that can be made at each sub-pattern\n        :param cdr3_sample:\n        :return:\n        \"\"\"\nencoded = self.encode_sequence(cdr3_sample)\ncurve = [self.graph.out_degree(i) for i in encoded]\nreturn encoded, curve\ndef path_gene_table(self, cdr3_sample, threshold=None):\n\"\"\"\n               the function will return two tables of all possible v and j genes\n                   that colud be used to generate the sequence given by \"cdr3_sample\"\n               :param cdr3_sample: a cdr3 sequence\n               :param threshold: drop genes that are missing from threshold % of the sequence\n               :return:\n               \"\"\"\nlength = len(self.encode_sequence(cdr3_sample))\nif threshold is None:\nthreshold = length * (1 / 4)\ngene_table = self.walk_genes(self.encode_sequence(cdr3_sample), dropna=False)\ngene_table = gene_table[gene_table.isna().sum(axis=1) &lt; threshold]\nvgene_table = gene_table[gene_table.index.str.contains('V')]\ngene_table = self.walk_genes(self.encode_sequence(cdr3_sample), dropna=False)\ngene_table = gene_table[gene_table.isna().sum(axis=1) &lt; (length * (1 / 2))]\njgene_table = gene_table[gene_table.index.str.contains('J')]\njgene_table = jgene_table.loc[jgene_table.isna().sum(axis=1).sort_values(ascending=True).index, :]\nvgene_table = vgene_table.loc[vgene_table.isna().sum(axis=1).sort_values(ascending=True).index, :]\nreturn vgene_table, jgene_table\ndef gene_variation(self, cdr3):\n\"\"\"\n               Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count\n                   and one for J gene count.\n               :param cdr3:\n               :return:\n               \"\"\"\nif not self.genetic:\nraise Exception('The LZGraph Has No Gene Data')\nencoded_a = self.encode_sequence(cdr3)\nnv_genes = [len(self.marginal_vgenes)]\nnj_genes = [len(self.marginal_jgenes)]\nfor node in encoded_a[1:]:\ninedges = self.graph.in_edges(node)\nv = set()\nj = set()\nfor ea, eb in inedges:\ngenes = pd.Series(self.graph[ea][eb]).drop(index=['Vsum', 'Jsum', 'weight'])\nv = v | set(genes[genes.index.str.contains('V')].index)\nj = j | set(genes[genes.index.str.contains('J')].index)\nnv_genes.append(len(v))\nnj_genes.append(len(j))\nnj_genes = np.array(nj_genes)\nnv_genes = np.array(nv_genes)\nj_df = pd.DataFrame(\n{'genes': list(nv_genes) + list(nj_genes), 'type': ['V'] * len(nv_genes) + ['J'] * len(nj_genes),\n'sp': lempel_ziv_decomposition(cdr3) + lempel_ziv_decomposition(cdr3)})\nreturn j_df\n</code></pre>"},{"location":"aaplzgraph_reference/#LZGraphs.AminoAcidPositional.AAPLZGraph.__init__","title":"<code>__init__(data, verbose=True, calculate_trainset_pgen=False)</code>","text":"<p>data has to be a pandas dataframe, the cdr3 amino acid sequence has to be under a column named \"cdr3_amino_acid\" and optionally you can add two columns \"V\" and \"J\" with the gene annotation for each sequence</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame</code> <p>a dataframe containing the sequences for which to consturct an LZGraph and any</p> required Source code in <code>LZGraphs\\AminoAcidPositional.py</code> <pre><code>def __init__(self, data, verbose=True, calculate_trainset_pgen=False):\n\"\"\"\n    data has to be a pandas dataframe, the cdr3 amino acid sequence has to be under a column named\n    \"cdr3_amino_acid\"\n    and optionally you can add two columns \"V\" and \"J\" with the gene annotation for each sequence\n    Args:\n        data (pd.DataFrame): a dataframe containing the sequences for which to consturct an LZGraph and any\n        additional V/J Data given provided under the \"V\" column and a \"J\" column.\n        verbose\n    \"\"\"\nsuper().__init__()\n# check for V and J gene data in input\nself.genetic = True if type(data) == pd.DataFrame and 'V' in data.columns and 'J' in data.columns else False\nif self.genetic:\nself._load_gene_data(data)\nself.verbose_driver(0, verbose)\n# construct the graph while iterating over the data\nself.__simultaneous_graph_construction(data)\nself.verbose_driver(1, verbose)\n# convert to pandas series and  normalize\nself.length_distribution = pd.Series(self.lengths)\nself.terminal_states = pd.Series(self.terminal_states)\nself.initial_states = pd.Series(self.initial_states)\nself.length_distribution_proba = self.terminal_states / self.terminal_states.sum()\nself.initial_states = self.initial_states[self.initial_states &gt; 5]\nself.initial_states_probability = self.initial_states/self.initial_states.sum()\nself.verbose_driver(2, verbose)\nself._derive_subpattern_individual_probability()\nself.verbose_driver(8, verbose)\nself._normalize_edge_weights()\nself.verbose_driver(3, verbose)\nif self.genetic:\n# Normalized Gene Weights\nself._batch_gene_weight_normalization(3, verbose)\nself.verbose_driver(4, verbose)\nself.edges_list = None\nself._derive_terminal_state_map()\nself.verbose_driver(7, verbose)\nself._derive_stop_probability_data()\nself.verbose_driver(8, verbose)\nself.verbose_driver(5, verbose)\nif calculate_trainset_pgen:\nself.train_pgen = np.array(\n[self.walk_probability(self.encode_sequence(i), verbose=False) for i in data.cdr3_amino_acid])\nself.constructor_end_time = time()\nself.verbose_driver(6, verbose)\nself.verbose_driver(-2, verbose)\n</code></pre>"},{"location":"aaplzgraph_reference/#LZGraphs.AminoAcidPositional.AAPLZGraph.clean_node","title":"<code>clean_node(base)</code>  <code>staticmethod</code>","text":"<p>This Function will take in a sub-pattern that has position added to it and clean the added values returning only the amino acid value</p> Source code in <code>LZGraphs\\AminoAcidPositional.py</code> <pre><code>@staticmethod\ndef clean_node(base):\n\"\"\"\n    This Function will take in a sub-pattern that has position added to it and clean\n    the added values returning only the amino acid value\n    Args:\n        base (str)\n    \"\"\"\nreturn re.search(r'[A-Z]*', base).group()\n</code></pre>"},{"location":"aaplzgraph_reference/#LZGraphs.AminoAcidPositional.AAPLZGraph.encode_sequence","title":"<code>encode_sequence(amino_acid)</code>  <code>staticmethod</code>","text":"<p>This function will take a sequence and return it as LZ sub-patterns with added position the general format is given as {LZ-subpattern}_{start_index}</p> Source code in <code>LZGraphs\\AminoAcidPositional.py</code> <pre><code>@staticmethod\ndef encode_sequence(amino_acid):\n\"\"\"\n    This function will take a sequence and return it as LZ sub-patterns with added position\n    the general format is given as {LZ-subpattern}_{start_index}\n    Args:\n        amino_acid (str)\n    \"\"\"\nlz, loc = derive_lz_and_position(amino_acid)\nreturn list(map(lambda x, z: x + '_' + str(z), lz, loc))\n</code></pre>"},{"location":"aaplzgraph_reference/#LZGraphs.AminoAcidPositional.AAPLZGraph.gene_variation","title":"<code>gene_variation(cdr3)</code>","text":"<p>Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count     and one for J gene count. :param cdr3: :return:</p> Source code in <code>LZGraphs\\AminoAcidPositional.py</code> <pre><code>def gene_variation(self, cdr3):\n\"\"\"\n           Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count\n               and one for J gene count.\n           :param cdr3:\n           :return:\n           \"\"\"\nif not self.genetic:\nraise Exception('The LZGraph Has No Gene Data')\nencoded_a = self.encode_sequence(cdr3)\nnv_genes = [len(self.marginal_vgenes)]\nnj_genes = [len(self.marginal_jgenes)]\nfor node in encoded_a[1:]:\ninedges = self.graph.in_edges(node)\nv = set()\nj = set()\nfor ea, eb in inedges:\ngenes = pd.Series(self.graph[ea][eb]).drop(index=['Vsum', 'Jsum', 'weight'])\nv = v | set(genes[genes.index.str.contains('V')].index)\nj = j | set(genes[genes.index.str.contains('J')].index)\nnv_genes.append(len(v))\nnj_genes.append(len(j))\nnj_genes = np.array(nj_genes)\nnv_genes = np.array(nv_genes)\nj_df = pd.DataFrame(\n{'genes': list(nv_genes) + list(nj_genes), 'type': ['V'] * len(nv_genes) + ['J'] * len(nj_genes),\n'sp': lempel_ziv_decomposition(cdr3) + lempel_ziv_decomposition(cdr3)})\nreturn j_df\n</code></pre>"},{"location":"aaplzgraph_reference/#LZGraphs.AminoAcidPositional.AAPLZGraph.path_gene_table","title":"<code>path_gene_table(cdr3_sample, threshold=None)</code>","text":"<p>the function will return two tables of all possible v and j genes     that colud be used to generate the sequence given by \"cdr3_sample\" :param cdr3_sample: a cdr3 sequence :param threshold: drop genes that are missing from threshold % of the sequence :return:</p> Source code in <code>LZGraphs\\AminoAcidPositional.py</code> <pre><code>def path_gene_table(self, cdr3_sample, threshold=None):\n\"\"\"\n           the function will return two tables of all possible v and j genes\n               that colud be used to generate the sequence given by \"cdr3_sample\"\n           :param cdr3_sample: a cdr3 sequence\n           :param threshold: drop genes that are missing from threshold % of the sequence\n           :return:\n           \"\"\"\nlength = len(self.encode_sequence(cdr3_sample))\nif threshold is None:\nthreshold = length * (1 / 4)\ngene_table = self.walk_genes(self.encode_sequence(cdr3_sample), dropna=False)\ngene_table = gene_table[gene_table.isna().sum(axis=1) &lt; threshold]\nvgene_table = gene_table[gene_table.index.str.contains('V')]\ngene_table = self.walk_genes(self.encode_sequence(cdr3_sample), dropna=False)\ngene_table = gene_table[gene_table.isna().sum(axis=1) &lt; (length * (1 / 2))]\njgene_table = gene_table[gene_table.index.str.contains('J')]\njgene_table = jgene_table.loc[jgene_table.isna().sum(axis=1).sort_values(ascending=True).index, :]\nvgene_table = vgene_table.loc[vgene_table.isna().sum(axis=1).sort_values(ascending=True).index, :]\nreturn vgene_table, jgene_table\n</code></pre>"},{"location":"aaplzgraph_reference/#LZGraphs.AminoAcidPositional.AAPLZGraph.sequence_variation_curve","title":"<code>sequence_variation_curve(cdr3_sample)</code>","text":"<p>given a sequence this function will return 2 list, the first is the lz-subpattern path through the graph and the second list is the number of possible choices that can be made at each sub-pattern :param cdr3_sample: :return:</p> Source code in <code>LZGraphs\\AminoAcidPositional.py</code> <pre><code>def sequence_variation_curve(self, cdr3_sample):\n\"\"\"\n    given a sequence this function will return 2 list,\n    the first is the lz-subpattern path through the graph and the second list is the number\n    of possible choices that can be made at each sub-pattern\n    :param cdr3_sample:\n    :return:\n    \"\"\"\nencoded = self.encode_sequence(cdr3_sample)\ncurve = [self.graph.out_degree(i) for i in encoded]\nreturn encoded, curve\n</code></pre>"},{"location":"aaplzgraph_reference/#LZGraphs.AminoAcidPositional.AAPLZGraph.unsupervised_random_walk","title":"<code>unsupervised_random_walk()</code>","text":"<p>a random initial state and a random terminal state are selected and a random unsupervised walk is carried out until the randomly selected terminal state is reached.</p> <pre><code>      Parameters:\n              None\n\n      Returns:\n              (list,str) : a list of LZ sub-patterns representing the random walk and a string\n              matching the walk only translated back into a sequence.\n</code></pre> Source code in <code>LZGraphs\\AminoAcidPositional.py</code> <pre><code>def unsupervised_random_walk(self):\n\"\"\"\n a random initial state and a random terminal state are selected and a random unsupervised walk is\ncarried out until the randomly selected terminal state is reached.\n          Parameters:\n                  None\n          Returns:\n                  (list,str) : a list of LZ sub-patterns representing the random walk and a string\n                  matching the walk only translated back into a sequence.\n                   \"\"\"\nrandom_initial_state = self._random_initial_state()\ncurrent_state = random_initial_state\nwalk = [random_initial_state]\nsequence = self.clean_node(random_initial_state)\nwhile not self.is_stop_condition(current_state):\n# take a random step\ncurrent_state = self.random_step(current_state)\nwalk.append(current_state)\nsequence += self.clean_node(current_state)\nreturn walk, sequence\n</code></pre>"},{"location":"aaplzgraph_reference/#LZGraphs.AminoAcidPositional.AAPLZGraph.walk_genes","title":"<code>walk_genes(walk, dropna=True, raise_error=True)</code>","text":"<pre><code>give a walk on the graph (a list of nodes) the function will return a table\n    representing the possible genes and their probabilities at each edge of the walk.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>walk</code> <code>list</code> <p>a list of nodes representing a walk on the graph.</p> required <code>dropna</code> <code>bool</code> <p>whether to drop the edges that are missing from the graph.</p> <code>True</code> Source code in <code>LZGraphs\\AminoAcidPositional.py</code> <pre><code>def walk_genes(self, walk, dropna=True,raise_error=True):\n\"\"\"\n           give a walk on the graph (a list of nodes) the function will return a table\n               representing the possible genes and their probabilities at each edge of the walk.\n       Args:\n        walk (list): a list of nodes representing a walk on the graph.\n        dropna (bool): whether to drop the edges that are missing from the graph.\n       \"\"\"\ntrans_genes = dict()\nfor i in range(0, len(walk) - 1):\nif self.graph.has_edge(walk[i], walk[i + 1]):\nls = self.graph.get_edge_data(walk[i], walk[i + 1]).copy()\nls.pop('weight')\nls.pop('Vsum')\nls.pop('Jsum')\ntrans_genes[walk[i] + '-&gt;' + walk[i + 1]] = ls\ncc = pd.DataFrame(trans_genes)\nif dropna:\ncc = cc.dropna()\nif cc.shape[0] == 0 and raise_error:\nraise Exception('No Constant Gene Flow F')\ncc['type'] = ['v' if 'v' in x.lower() else 'j' for x in cc.index]\ncc['sum'] = cc.sum(axis=1, numeric_only=True)\n#cc = cc.sort_values(by='sum', ascending=False)\nreturn cc\n</code></pre>"},{"location":"aaplzgraph_reference/#LZGraphs.AminoAcidPositional.AAPLZGraph.walk_probability","title":"<code>walk_probability(walk, verbose=True, use_epsilon=False)</code>","text":"<p>given a walk (a sequence converted into LZ sub-pattern) return the probability of generation (PGEN) of the walk.</p> <p>you can use \"lempel_ziv_decomposition\" from this libraries decomposition module in order to convert a sequence into LZ sub-patterns</p> <pre><code>     Parameters:\n             walk (list): a list of LZ - sub-patterns\n\n     Returns:\n             float : the probability of generating such a walk (PGEN)\n</code></pre> Source code in <code>LZGraphs\\AminoAcidPositional.py</code> <pre><code>def walk_probability(self, walk, verbose=True, use_epsilon=False):\n\"\"\"\n                given a walk (a sequence converted into LZ sub-pattern) return the probability of generation (PGEN)\n                of the walk.\n                you can use \"lempel_ziv_decomposition\" from this libraries decomposition module in order to convert a\n                sequence into LZ sub-patterns\n                         Parameters:\n                                 walk (list): a list of LZ - sub-patterns\n                         Returns:\n                                 float : the probability of generating such a walk (PGEN)\n                  \"\"\"\nif type(walk) == str:\nLZ, POS = derive_lz_and_position(walk)\nwalk_ = [i + str(j) for i, j in zip(LZ, POS)]\nelse:\nwalk_ = walk\nif walk_[0] not in self.subpattern_individual_probability['proba']:\nreturn np.finfo(float).eps ** 2\nproba = self.subpattern_individual_probability['proba'][walk_[0]]\nn_missing = 0\ntotal = 0\nfor step1, step2 in window(walk_, 2):\nif self.graph.has_edge(step1, step2):\nproba *= self.graph.get_edge_data(step1, step2)['weight']\nelse:\nif verbose:\nprint('No Edge Connecting| ', step1, '--&gt;', step2)\nn_missing += 1\ntotal += 1\nif n_missing &gt; 0:\ngmean = np.power(proba, (1 / total))\nproba = proba * (gmean ** n_missing)\nreturn proba\n</code></pre>"},{"location":"bowencoder_reference/","title":"BOW Encoder Functions","text":""},{"location":"bowencoder_reference/#LZGraphs.BOWEncoder.LZBOW","title":"<code>LZBOW</code>","text":"<p>This class supplies a full suite for the conversion of repertoires into a bag of words representation based on a given sub-pattern (graph node) deriving function. This class requires fitting on a set of sequences in order to derive the dictionary of unique sub patterns used to generate the bag of words representation. After the class been fitted on a source set of sequences each time a transformation is needed one can use the transform method to get the vector representation.</p> <p>Parameters:</p> Name Type Description Default <code>encoding_function</code> <code>str</code> <p>the selected node extraction method to use 'naive' - emulate Naive LZGraph extraction / 'ndp'- emulate Nucleotide Double Positional LZGraph / 'aap' - Amino Acid Positional LZGraph.</p> <code>lempel_ziv_decomposition</code> <p>Attributes:</p> Name Type Description <code>dictionary</code> <code>set</code> <p>a set of sub-patterns (graph nodes) representing the dictionary of the BOW vector</p> <code>dictionary_size</code> <code>int</code> <p>The size of the dictionary</p> <code>observed_sequences</code> <code>int</code> <p>The number of sequences used to derive the dictionary</p> <code>encoding_function</code> <code>func</code> <p>the function used to derive sub-patterns from a sequence (in the context of this</p> <code>library</code> <code>it is one of the 3</code> <p>Naive, Nucleotide Double Positional, Amino Acid Positional</p> <code>dictionary_index_map</code> <code>dict</code> <p>a dictionary that maps the set of sub-patterns to numerical positions in</p> <code>dictionary_index_inverse_map</code> <code>dict</code> <p>a dictionary that maps numerical positions to the sub-patterns from</p> Source code in <code>LZGraphs\\BOWEncoder.py</code> <pre><code>class LZBOW:\n\"\"\"\n         This class supplies a full suite for the conversion of repertoires into a bag of words representation\n         based on a given sub-pattern (graph node) deriving function.\n         This class requires fitting on a set of sequences in order to derive the dictionary of unique sub patterns used\n         to generate the bag of words representation.\n         After the class been fitted on a source set of sequences each time a transformation is needed one can use\n         the transform method to get the vector representation.\n         Args:\n             encoding_function (str): the selected node extraction method to use 'naive' - emulate Naive LZGraph extraction\n              / 'ndp'- emulate Nucleotide Double Positional LZGraph / 'aap' - Amino Acid Positional LZGraph.\n         Attributes:\n             dictionary (set): a set of sub-patterns (graph nodes) representing the dictionary of the BOW vector\n             dictionary_size (int): The size of the dictionary\n             observed_sequences (int): The number of sequences used to derive the dictionary\n             encoding_function (func): the function used to derive sub-patterns from a sequence (in the context of this\n             library it is one of the 3: Naive, Nucleotide Double Positional, Amino Acid Positional\n             dictionary_index_map (dict): a dictionary that maps the set of sub-patterns to numerical positions in\n             the BOW vector.\n             dictionary_index_inverse_map (dict): a dictionary that maps numerical positions to the sub-patterns from\n             the dictionary set\n         \"\"\"\ndef __init__(self, encoding_function=lempel_ziv_decomposition):\nself.dictionary = set()\nself.dictionary_size = 0\nself.observed_sequences = 0\nself.encoding_function = encoding_function\nself.dictionary_index_map = dict()\nself.dictionary_index_inverse_map = dict()\ndef _derive_index_maps(self):\nself.dictionary_index_map = {pattern: idx for idx, pattern in enumerate(self.dictionary)}\nself.dictionary_index_inverse_map = {idx: pattern for idx, pattern in enumerate(self.dictionary)}\nself.dictionary_size = len(self.dictionary)\ndef fit(self, data):\nif type(data) == str:\nencoded = self.encoding_function(data)\nself.dictionary = self.dictionary | set(encoded)\nself._derive_index_maps()\nelif isinstance(data, Iterable):\nfor seq in tqdm(data, leave=False, position=0):\nencoded = self.encoding_function(seq)\nself.dictionary = self.dictionary | set(encoded)\nself.observed_sequences += 1\nself._derive_index_maps()\ndef _seq_to_index(self, seq):\nencoded = self.encoding_function(seq)\nreturn [self.dictionary_index_map[i] for i in encoded if i in self.dictionary]\ndef transform(self, data, normalize=False):\nif type(data) == str:\nresult = np.zeros(self.dictionary_size)\nresult[self._seq_to_index(data)] += 1\nreturn result\nelif isinstance(data, Iterable):\nresult = np.zeros(self.dictionary_size)\nfor seq in tqdm(data, leave=False, position=0):\nresult[self._seq_to_index(seq)] += 1\nif normalize:\nreturn result / result.sum()\nelse:\nreturn result\ndef load_from(self, other):\nself.dictionary = other.dictionary\nself.dictionary_size = other.dictionary_size\nself.observed_sequences = other.observed_sequences\nself.encoding_function = other.encoding_function\nself.dictionary_index_map = other.dictionary_index_map\nself.dictionary_index_inverse_map = other.dictionary_index_inverse_map\ndef __add__(self, other):\nif self.encoding_function != other.encoding_function:\nraise Exception('Encoding Function Mismatch Between BOW Objects')\nunion = LZBOW(self.encoding_function)\nunion.dictionary = self.dictionary | other.dictionary\nunion.observed_sequences = self.observed_sequences + other.observed_sequences\nunion.dictionary_index_map = {pattern: idx for idx, pattern in enumerate(union.dictionary)}\nunion.dictionary_index_inverse_map = {idx: pattern for idx, pattern in enumerate(union.dictionary)}\nunion.dictionary_size = len(self.dictionary)\nreturn union\n</code></pre>"},{"location":"explanation/","title":"Explanation","text":"<p>This part of the project documentation focuses on a learning-oriented approach. You'll learn how to get started with the code in this project.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Help newcomers with getting started</li> <li>Teach readers about your library by making them     write code</li> <li>Inspire confidence through examples that work for     everyone, repeatably</li> <li>Give readers an immediate sense of achievement</li> <li>Show concrete examples, no abstractions</li> <li>Provide the minimum necessary explanation</li> <li>Avoid any distractions</li> </ul>"},{"location":"lzgraphbase_reference/","title":"LZGraph Base Class","text":"<p>This abstract class provides the base functionality and attributes shared between the different LZGraphs (excluding the Naive LZGraph).</p> <p>Attributes:</p> Name Type Description <code>constructor_start_time</code> <code>int</code> <p>An integer recording the time in seconds the constructor was initiated</p> <code>graph</code> <code>netowrkx.DiGraph</code> <p>An empty DiGraph based on the networkx library, this object will keep the information</p> <code>genetic</code> <code>bool</code> <p>if True this flag will allow genetic function to be used as V and J annotation were provoided</p> <code>genetic_walks_black_list</code> <code>dict</code> <p>This dictionary maps (edge / edge+vj) to another edge that leads a</p> <code>n_subpatterns</code> <code>int</code> <p>The total number of sequences used to construct the LZGraph.</p> <code>initial_states</code> <code>dict</code> <p>A dictionary containing all initial state and the number of time each one of them</p> <code>terminal_states</code> <code>dict</code> <p>A dictionary containing all terminal state and the number of time each one of them</p> <code>initial_states_probability</code> <code>pd.Series</code> <p>A pandas series containing the normalized counts of the initial</p> <code>lengths</code> <code>dict</code> <p>a dictionary that maps the different observed sequences length to the number of time</p> <code>cac_graphs</code> <code>dict</code> <p>This is dictionary used to keep different sub-graphs based on the condition in the</p> <code>n_transitions</code> <code>int</code> <p>The total number of transition observed while constructing the graph.</p> <code>n_neighbours</code> <code>dict</code> <p>Keep track of the number of neighbours given a certain condition in the key.</p> <code>length_distribution_proba</code> <code>pd.Series</code> <p>A pandas series mapping sequence length to a probability value</p> <code>subpattern_individual_probability</code> <code>pd.Series</code> <p>A pandas series mapping the different graph nodes to the</p> Source code in <code>LZGraphs\\LZGraphBase.py</code> <pre><code>class LZGraphBase:\n\"\"\"\n         This abstract class provides the base functionality and attributes shared between the different LZGraphs\n         (excluding the Naive LZGraph).\n         Args:\n             Abstract Class\n         Attributes:\n             constructor_start_time (int): An integer recording the time in seconds the constructor was initiated\n             (returned via the python time library time function)\n             graph (netowrkx.DiGraph): An empty DiGraph based on the networkx library, this object will keep the information\n             we derive throughout the constructor routine\n             genetic (bool): if True this flag will allow genetic function to be used as V and J annotation were provoided\n             along with the sequences. False means no genetic information is encoded into the graph.\n             genetic_walks_black_list (dict): This dictionary maps (edge / edge+vj) to another edge that leads a\n             generated random walk to a \"dead-end\" as no more steps can be taken due to missing v/j information.\n             (this applies only to genomic random walk where the randomly selected v and j genes have to appear at each edge).\n             The more sequences are generated by a particular LZGraph the more dead ends will be found, the quicker\n             the sequences will be generated.\n             n_subpatterns (int):  The total number of sequences used to construct the LZGraph.\n             initial_states (dict): A dictionary containing all initial state and the number of time each one of them\n             was observed.\n             terminal_states (dict): A dictionary containing all terminal state and the number of time each one of them\n             was observed.\n             initial_states_probability (pd.Series): A pandas series containing the normalized counts of the initial\n             states.\n             lengths (dict): a dictionary that maps the different observed sequences length to the number of time\n             that length has been observed.\n             cac_graphs (dict): This is dictionary used to keep different sub-graphs based on the condition in the\n             key, currently deprecated.\n             n_transitions (int): The total number of transition observed while constructing the graph.\n             n_neighbours (dict): Keep track of the number of neighbours given a certain condition in the key.\n             currently deprecated.\n             length_distribution_proba (pd.Series): A pandas series mapping sequence length to a probability value\n             based on the sequence used to construct the LZGraph.\n             subpattern_individual_probability (pd.Series): A pandas series mapping the different graph nodes to the\n             emperical probability of observing that specific node independent of the graph structure.\n         \"\"\"\ndef __init__(self):\n# start time of constructor\nself.constructor_start_time = time()\n# create graph\nself.graph = nx.DiGraph()\n# check for V and J gene data in input\nself.genetic = False\n# a list of invalid genetic walks\nself.genetic_walks_black_list = {}\n# total number of sub-patterns\nself.n_subpatterns = 0\nself.initial_states, self.terminal_states = dict(), dict()\nself.initial_states_probability = pd.Series()\nself.lengths = dict()\nself.cac_graphs = dict()\nself.n_transitions = 0\nself.n_neighbours = dict()\nself.length_distribution_proba = pd.Series()\nself.subpattern_individual_probability = pd.Series()\n# per node observed frequency for unity operation\nself.per_node_observed_frequency = dict()\ndef __eq__(self, other):\n\"\"\" This method test whether two LZGraph are equal, i.e. have the same node,edges and metadata on the edges.\n                                    Returns:\n                                        bool: True if graph equal else False\n          \"\"\"\nif nx.utils.graphs_equal(self.graph, other.graph):\naux = 0\naux += self.genetic_walks_black_list != other.genetic_walks_black_list\naux += self.n_subpatterns != other.n_subpatterns\naux += not self.initial_states.round(3).equals(other.initial_states.round(3))\naux += not self.terminal_states.round(3).equals(other.terminal_states.round(3))\n# test marginal_vgenes\naux += not other.marginal_vgenes.round(3).equals(self.marginal_vgenes.round(3))\n# test vj_probabilities\naux += not other.vj_probabilities.round(3).equals(self.vj_probabilities.round(3))\n# test length_distribution\naux += not other.length_distribution.round(3).equals(self.length_distribution.round(3))\n# test final_state\naux += not other.terminal_states.round(3).equals(self.terminal_states.round(3))\n# test length_distribution_proba\naux += not other.length_distribution_proba.round(3).equals(self.length_distribution_proba.round(3))\nif aux == 0:\nreturn True\nelse:\nreturn False\nelse:\nreturn False\n@staticmethod\ndef encode_sequence(sequence):\n\"\"\"\n          This method is abstract, when creating a new LZGraph class, one should override this method with a method\n          that process a sequence of symbols (nucleotides/amino acids) and return a list of string where each\n          string represents a node in the graph. note that it is implied that each pair of sequential string in the\n          returned list are connect by an edge.\n                  Args:\n                          sequence (str): a string from which to derive sub-patterns\n                  Returns:\n                          list : a list of unique sub-patterns\n       \"\"\"\nraise NotImplementedError\n@staticmethod\ndef clean_node(base):\n\"\"\"\n          given a sub-pattern that has reading frame and position added to it, cleans it and returns\n          only the nucleotides from the string\n                  Args:\n                          base (str): a node from the NDPLZGraph\n                  Returns:\n                          str : only the nucleotides of the node\n     \"\"\"\nreturn re.search(r'[ATGC]*', base).group()\ndef _decomposed_sequence_generator(self,data):\n\"\"\"\n           This abstract method should be overwritten in any LZGraph class inheriting this baseclass,\n           this method should return a generator that will take all the data provided to the constractor and\n           yield the relevant node and edge data each time it is called to be added to graph.\n                   Args:\n                           data (pd.DataFrame): a pandas Dataframe containing all information relevant for the\n                           construction of an LZGraph (sequences / genomic data etc).\n                   Returns:\n                           generator : a generator the yield the information needed to add nodes and edges to the graph\n                           attribute.\n      \"\"\"\nraise NotImplementedError\ndef _simultaneous_graph_construction(self, data):\n\"\"\"\n                  This method leverage the generator implemented in _decomposed_sequence_generator\n                  in order to iterate over the information returned by the generator and each iteration insert\n                  the node and edge data into the networkx DiGraph and embed and genetic information provided.\n                          Args:\n                                  data (pd.DataFrame): a pandas Dataframe containing all information relevant for the\n                                  construction of an LZGraph (sequences / genomic data etc).\n                          Returns:\n                                  None\n             \"\"\"\nprocessing_stream = self._decomposed_sequence_generator(data)\nif self.genetic:\nfor output in processing_stream:\nsteps, locations,v,j = output\nfor (A, B), (loc_a, loc_b) in zip(steps, locations):\nA_ = A + '_' + str(loc_a)\nself.per_node_observed_frequency[A_] = self.per_node_observed_frequency.get(A_, 0) + 1\nB_ = B + '_' + str(loc_b)\nself._insert_edge_and_information(A_, B_, v, j)\nself.per_node_observed_frequency[B_] = self.per_node_observed_frequency.get(B_, 0)\nelse:\nfor output in processing_stream:\nsteps, locations = output\nfor (A, B), (loc_a, loc_b) in zip(steps, locations):\nA_ = A + '_' + str(loc_a)\nself.per_node_observed_frequency[A_] = self.per_node_observed_frequency.get(A_, 0) + 1\nB_ = B + '_' + str(loc_b)\nself._insert_edge_and_information_no_genes(A_, B_)\nself.per_node_observed_frequency[B_] = self.per_node_observed_frequency.get(B_, 0)\ndef _normalize_edge_weights(self):\n\"\"\"\n             This method iterates over all the edges in the graph, normalizing edge edgre by the total number\n             of observed edges at the source node of that edge. the resulting graph will contain nodes that the sum\n             of weights for all edges expanding fit that node sum to 1.\n            \"\"\"\nfor edge_a, edge_b in self.graph.edges:\nnode_observed_total = self.per_node_observed_frequency[edge_a]\nself.graph[edge_a][edge_b]['weight'] /= node_observed_total\ndef _get_node_info_df(self, node_a, V=None, J=None, condition='and'):\n\"\"\"\n           This method returns a dataframe containing the information encoded in each edge spaning from a given node,\n           the indecies of the dataframe are the edges and the column are the different attributes.\n                   Args:\n                           node_a (str): a string matching a node in the graph\n                           V (str): optional, if provided together with J this can be used to filter out node edges\n                           J (str): optional, if provided together with V this can be used to filter out node edges\n                           condition (str):optional, one of the values = (\"and\"/\"or\"), based on the value the function\n                           will return the edges of the given node that have information for V and J (the other\n                           two parameters passed) or for edge containing V or J/\n                   Returns:\n                           pd.DataFrame : a DataFrame containing all edges and their metadata for a specific node.\n            \"\"\"\nif V is None or J is None:\nreturn pd.DataFrame(dict(self.graph[node_a]))\nelse:\nnode_data = self.graph[node_a]\nif condition == 'and':\npartial_dict = {pk: node_data[pk] for pk in node_data if V in node_data[pk] and J in node_data[pk]}\nelse:\npartial_dict = {pk: node_data[pk] for pk in node_data if V in node_data[pk] or J in node_data[pk]}\nreturn pd.DataFrame(partial_dict)\ndef _get_node_feature_info_df(self, node_a, feature, V=None, J=None, asdict=False):\nif V is None or J is None:\nreturn pd.DataFrame(dict(self.graph[node_a]))\nelse:\nnode_data = self.graph[node_a]\npartial_dict = {pk: {feature: node_data[pk][feature]} for pk in node_data \\\n                            if V in node_data[pk] and J in node_data[pk]}\nif asdict:\nreturn partial_dict\nelse:\nreturn pd.DataFrame(partial_dict)\ndef is_stop_condition(self, state, selected_v=None, selected_j=None):\nif state not in self.terminal_states:\nreturn False\nif self.genetic:\nif selected_j is not None:\n# edge_info = self._get_node_info_df(state, selected_v, selected_j,condition='or')\nedge_info = dict(self.graph[state])  # pd.DataFrame()\nobserved_gene_paths = set(get_dictionary_subkeys(edge_info))\nif len(set(observed_gene_paths) &amp; {selected_v, selected_j}) != 2:\nneighbours = 0\nelse:\nneighbours = 2\nelse:\nneighbours = self.graph.out_degree(state)\nif (neighbours) == 0:\nreturn True\nelse:\nstop_probability = self.terminal_state_data.loc[state, 'wsif/sep']\ndecision = np.random.binomial(1, stop_probability) == 1\nreturn decision\nelse:\nstop_probability = self.terminal_state_data.loc[state, 'wsif/sep']\ndecision = np.random.binomial(1, stop_probability) == 1\nreturn decision\ndef genomic_random_walk(self, initial_state=None, vj_init='marginal'):\n\"\"\"\n             given a target sequence length and an initial state, the function will select a random\n             V and a random J genes from the observed gene frequency in the graph's \"Training data\" and\n             generate a walk on the graph from the initial state to a terminal state while making sure\n             at each step that both the selected V and J genes were seen used by that specific sub-pattern.\n             if seq_len is equal to \"unsupervised\" than a random seq len will be returned\n        \"\"\"\nself._raise_genetic_mode_error()\nselected_v, selected_j = self._select_random_vj_genes(vj_init)\nif initial_state is None:\ncurrent_state = self._random_initial_state()\nwalk = [current_state]\nelse:\ncurrent_state = initial_state\nwalk = [initial_state]\n# while the walk is not in a valid final state\nwhile not self.is_stop_condition(current_state, selected_v, selected_j):\n# get the node_data for the current state\nedge_info = self._get_node_feature_info_df(current_state, 'weight', selected_v, selected_j, asdict=True)\nif (current_state, selected_v, selected_j) in self.genetic_walks_black_list:\nfor col in self.genetic_walks_black_list[(current_state, selected_v, selected_j)]:\nedge_info.pop(col)\n# edge_info = edge_info.drop(\n#     columns=self.genetic_walks_black_list[(current_state, selected_v, selected_j)])\n# check selected path has genes\nif len(edge_info) == 0:\nif len(walk) &gt; 2:\nself.genetic_walks_black_list[(walk[-2], selected_v, selected_j)] \\\n                        = self.genetic_walks_black_list.get((walk[-2], selected_v, selected_j),\n[]) + [walk[-1]]\ncurrent_state = walk[-2]\nwalk = walk[:-1]\nelse:\nwalk = walk[:1]\ncurrent_state = walk[0]\nselected_v, selected_j = self._select_random_vj_genes(vj_init)\ncontinue\nw = np.array([edge_info[i]['weight'] for i in edge_info])\nw = w / w.sum()\ncurrent_state = choice([*edge_info], w)\nwalk.append(current_state)\nreturn walk, selected_v, selected_j\ndef random_walk(self, initial_state=None, vj_init='marginal'):\nif initial_state is None:\ncurrent_state = self._random_initial_state()\nwalk = [current_state]\nelse:\ncurrent_state = initial_state\nwalk = [initial_state]\n# while the walk is not in a valid final state\nwhile not self.is_stop_condition(current_state):\n# get the node_data for the current state\nedge_info = self._get_node_feature_info_df(current_state, 'weight', asdict=True)\nif (current_state) in self.genetic_walks_black_list:\nfor col in self.genetic_walks_black_list[(current_state)]:\nedge_info.pop(col)\n# edge_info = edge_info.drop(\n#     columns=self.genetic_walks_black_list[(current_state, selected_v, selected_j)])\n# check selected path has genes\nif len(edge_info) == 0:\nif len(walk) &gt; 2:\nself.genetic_walks_black_list[(walk[-2])] \\\n                        = self.genetic_walks_black_list.get((walk[-2]),\n[]) + [walk[-1]]\ncurrent_state = walk[-2]\nwalk = walk[:-1]\nelse:\nwalk = walk[:1]\ncurrent_state = walk[0]\nselected_v, selected_j = self._select_random_vj_genes(vj_init)\ncontinue\nw = np.array([edge_info[i]['weight'] for i in edge_info])\nw = w / w.sum()\ncurrent_state = choice([*edge_info], w)\nwalk.append(current_state)\nreturn walk\ndef _derive_subpattern_individual_probability(self):\nweight_df = pd.Series(nx.get_edge_attributes(self.graph, 'weight')).reset_index()\nself.subpattern_individual_probability = weight_df.groupby('level_0').sum().rename(columns={0: 'proba'})\nself.subpattern_individual_probability /= self.subpattern_individual_probability.proba.sum()\ndef verbose_driver(self, message_number, verbose):\nif not verbose:\nreturn None\nif message_number == -2:\nprint(\"===\" * 10)\nprint('\\n')\nelif message_number == 0:\nCT = round(time() - self.constructor_start_time, 2)\nprint(\"Gene Information Loaded..\", '| ', CT, ' Seconds')\nelif message_number == 1:\nCT = round(time() - self.constructor_start_time, 2)\nprint(\"Graph Constructed..\", '| ', CT, ' Seconds')\nelif message_number == 2:\nCT = round(time() - self.constructor_start_time, 2)\nprint(\"Graph Metadata Derived..\", '| ', CT, ' Seconds')\nelif message_number == 3:\nCT = round(time() - self.constructor_start_time, 2)\nprint(\"Graph Edge Weight Normalized..\", '| ', CT, ' Seconds')\nelif message_number == 4:\nCT = round(time() - self.constructor_start_time, 2)\nprint(\"Graph Edge Gene Weights Normalized..\", '| ', CT, ' Seconds')\nelif message_number == 5:\nCT = round(time() - self.constructor_start_time, 2)\nprint(\"Terminal State Map Derived..\", '| ', CT, ' Seconds')\nelif message_number == 6:\nCT = round(self.constructor_end_time - self.constructor_start_time, 2)\nprint(\"LZGraph Created Successfully..\", '| ', CT, ' Seconds')\nelif message_number == 7:\nCT = round(time() - self.constructor_start_time, 2)\nprint(\"Terminal State Map Derived..\", '| ', CT, ' Seconds')\nelif message_number == 8:\nCT = round(time() - self.constructor_start_time, 2)\nprint(\"Individual Subpattern Empirical Probability Derived..\", '| ', CT, ' Seconds')\nelif message_number == 9:\nCT = round(time() - self.constructor_start_time, 2)\nprint(\"Terminal State Conditional Probabilities Map Derived..\", '| ', CT, ' Seconds')\ndef random_step(self, state):\n\"\"\"\n           Given the current state, pick and take a random step based on the translation probabilities\n           :param state:\n           :return:\n                       \"\"\"\nstates, probabilities = self._get_state_weights(state)\nreturn choice(states, probabilities)\ndef _random_initial_state(self):\n\"\"\"\n       Select a random initial state based on the marginal distribution of initial states.\n       :return:\n       \"\"\"\nreturn choice(self.initial_states_probability.index, self.initial_states_probability.values)\ndef _select_random_vj_genes(self, type='marginal'):\nself._raise_genetic_mode_error()\nif type == 'marginal':\nV = choice(self.marginal_vgenes.index, self.marginal_vgenes.values)\nJ = choice(self.marginal_jgenes.index, self.marginal_jgenes.values)\nreturn V, J\nelif type == 'combined':\nVJ = choice(self.vj_probabilities.index, self.vj_probabilities.values)\nV, J = VJ.split('_')\nreturn V, J\ndef _insert_edge_and_information(self, A_, B_, Vgene, Jgene):\n# if self.graph.has_edge(A_, B_):\ntry:  # assuming edge exists\nedge_pointer = self.graph[A_][B_]\nedge_pointer[\"weight\"] += 1\nedge_pointer[Vgene] = edge_pointer.get(Vgene, 0) + 1\nedge_pointer[Jgene] = edge_pointer.get(Jgene, 0) + 1\nedge_pointer['Vsum'] += 1\nedge_pointer['Jsum'] += 1\nexcept KeyError as e:  # edge not fount\nattr = {'weight': 1, 'Vsum': 1, 'Jsum': 1}\nattr[Vgene] = 1\nattr[Jgene] = 1\nself.graph.add_edge(A_, B_, **attr)\nself.n_transitions += 1\ndef _insert_edge_and_information_no_genes(self, A_, B_):\nif self.graph.has_edge(A_, B_):\nself.graph[A_][B_][\"weight\"] += 1\nelse:\nself.graph.add_edge(A_, B_, weight=1)\nself.n_transitions += 1\ndef _get_state_weights(self, node, v=None, j=None):\n\"\"\"\n        Given a node, return all the possible translation from that node and their respective weights\n        :param node:\n        :param v:\n        :param j:\n        :return:\n                    \"\"\"\nif v is None and j is None:\nnode_data = self.graph[node]\nstates = list(node_data.keys())\nprobabilities = [node_data[i]['weight'] for i in states]\nreturn states, probabilities\nelse:\nreturn pd.DataFrame(dict(self.graph[node])).T\ndef _batch_gene_weight_normalization(self, n_process=3, verbose=False):\nbatches = chunkify(list(self.graph.edges), len(self.graph.edges) // 3)\npool = ThreadPool(n_process)\npool.map(self._normalize_gene_weights, list(batches))\n# self.normalize_gene_weights(self.graph.edges)\ndef _normalize_gene_weights(self, edge_list):\nfor n_a, n_b in (edge_list):\ne_data = self.graph.get_edge_data(n_a, n_b)\nvsum = e_data['Vsum']\njsum = e_data['Jsum']\ngenes = set(e_data) - {'Vsum', 'Jsum', 'weight'}\nfor key in genes:\nif 'V' in key:\nself.graph[n_a][n_b][key] /= vsum\nelse:\nself.graph[n_a][n_b][key] /= jsum\ndef _update_terminal_states(self, terminal_state):\nself.terminal_states[terminal_state] = self.terminal_states.get(terminal_state, 0) + 1\ndef _update_initial_states(self, initial_state):\nself.initial_states[initial_state] = self.initial_states.get(initial_state, 0) + 1\ndef _load_gene_data(self, data):\nself.observed_vgenes = list(set(data['V']))\nself.observed_jgenes = list(set(data['J']))\nself.marginal_vgenes = data['V'].value_counts()\nself.marginal_jgenes = data['J'].value_counts()\nself.marginal_vgenes /= self.marginal_vgenes.sum()\nself.marginal_jgenes /= self.marginal_jgenes.sum()\nself.vj_probabilities = (data['V'] + '_' + data['J']).value_counts()\nself.vj_probabilities /= self.vj_probabilities.sum()\ndef _derive_terminal_state_map(self):\n\"\"\"\n        create a matrix map between all terminal state,\n        given that we have  K terminal states, the matrix will be of dim KxK\n        where at each row reachability will be denoted by 1, i.e\n        if I can reach e  state K_i from state k, the value at K[k][K_i] = 1\n        :return:\n        \"\"\"\nterminal_state_map = np.zeros((len(self.terminal_states), len(self.terminal_states)))\nts_index = {i: ax for ax, i in enumerate(self.terminal_states.index)}\nfor pos_1, terminal_1 in enumerate(self.terminal_states.index):\ndfs_node = list(nx.dfs_preorder_nodes(self.graph, source=terminal_1))\n# for pos_2, terminal_2 in enumerate(self.terminal_states.index):\n#     terminal_state_map[pos_1][pos_2] = nx.has_path(self.graph, source=terminal_1, target=terminal_2)\nreachable_terminal_state = set(dfs_node) &amp; set(self.terminal_states.index)\nfor node in reachable_terminal_state:\nterminal_state_map[pos_1][ts_index[node]] = 1\nterminal_state_map = pd.DataFrame(terminal_state_map,\ncolumns=self.terminal_states.index,\nindex=self.terminal_states.index).apply(\nlambda x: x.apply(lambda y: x.name if y == 1 else np.nan), axis=0)\n# np.fill_diagonal(terminal_state_map.values, np.nan)\nself.terminal_state_map = pd.Series(terminal_state_map.apply(lambda x: (x.dropna().to_list()), axis=1),\nindex=self.terminal_states.index)\ndef _derive_stop_probability_data(self):\ndef freq_normalize(target):\n# all possible alternative future terminal states from current state\nD = self.length_distribution_proba.loc[target].copy()\n# normalize observed frequencey\nD /= D.sum()\nreturn D\ndef wont_stop_at_future_states(state, es):\nD = freq_normalize(es.decendent_end_states[state])\n# remove current state\ncurrent_freq = D.pop(state)\nif len(D) &gt;= 1:\nD = 1 - D\nreturn D.product()\nelse:\nreturn 1\ndef didnt_stop_at_past(state, es):\n# all possible alternative future terminal states from current state\nD = freq_normalize(es.ancestor_end_state[state])\n# remove current state\nif state in D:\nD.pop(state)\nif len(D) &gt;= 1:\nD = 1 - D\nreturn D.product()\nelse:\nreturn 1\nes = self.terminal_state_map.to_frame().rename(columns={0: 'decendent_end_states'})\nes['n_alternative'] = es['decendent_end_states'].apply(lambda x: len(x) - 1)\nes['end_freq'] = self.length_distribution_proba\nes['wont_stop_in_future'] = 0\nes['wont_stop_in_future'] = es.index.to_series().apply(lambda x: wont_stop_at_future_states(x, es))\nes['state_end_proba'] = es.index.to_series().apply(lambda x: freq_normalize(es.decendent_end_states[x])[x])\nes['ancestor_end_state'] = es.index.to_series() \\\n            .apply(\nlambda x: list(set([ax for ax, i in zip(es.index, es['decendent_end_states']) if x in i])))\nes['state_end_proba_ancestor'] = es.index.to_series().apply(\nlambda x: freq_normalize(es.ancestor_end_state[x])[x])\nes['didnt_stop_at_past'] = 1\nes['didnt_stop_at_past'] = es.index.to_series().apply(lambda x: didnt_stop_at_past(x, es))\n# state end freq normalized by wont stop in future\nes['wsif/sep'] = es['state_end_proba'] / es['wont_stop_in_future']\nes.loc[es['wsif/sep'] &gt;= 1, 'wsif/sep'] = 1\n# ancestor and decendent product\n# es['normalized'] = (es['state_end_proba']*es['state_end_proba_ancestor']) / (es['wont_stop_in_future']*es['didnt_stop_at_past'])\nself.terminal_state_data = es\ndef _length_specific_terminal_state(self, length):\nreturn self.terminal_states[\nself.terminal_states.index.to_series().str.split('_').apply(lambda x: int(x[-1])) == length].index.to_list()\ndef _max_sum_gene_prediction(self, walk, top_n=1):\nv_gene_agg = dict()\nj_gene_agg = dict()\nfor i in range(0, len(walk) - 1):\nif self.graph.has_edge(walk[i], walk[i + 1]):\nls = self.graph.get_edge_data(walk[i], walk[i + 1]).copy()\nfor key in {*ls} - {'weight', 'Vsum', 'Jsum'}:\nif 'V' in key:\nv_gene_agg[key] = v_gene_agg.get(key, 0) + ls[key]\nelse:\nj_gene_agg[key] = j_gene_agg.get(key, 0) + ls[key]\nif top_n == 1:\nreturn max(v_gene_agg, key=v_gene_agg.get), max(j_gene_agg, key=j_gene_agg.get)\nelse:\nvs = {k for k in heapq.nlargest(top_n, v_gene_agg, key=lambda k: v_gene_agg[k])}\njs = {k for k in heapq.nlargest(top_n, j_gene_agg, key=lambda k: j_gene_agg[k])}\nreturn vs, js\ndef _max_product_gene_prediction(self, walk, top_n=1):\nv_gene_agg = dict()\nj_gene_agg = dict()\nfor i in range(0, len(walk) - 1):\nif self.graph.has_edge(walk[i], walk[i + 1]):\nls = self.graph.get_edge_data(walk[i], walk[i + 1]).copy()\nfor key in {*ls} - {'weight', 'Vsum', 'Jsum'}:\nif 'V' in key:\nv_gene_agg[key] = v_gene_agg.get(key, 1) * ls[key]\nelse:\nj_gene_agg[key] = j_gene_agg.get(key, 1) * ls[key]\nif top_n == 1:\nreturn max(v_gene_agg, key=v_gene_agg.get), max(j_gene_agg, key=j_gene_agg.get)\nelse:\nvs = {k for k in heapq.nlargest(top_n, v_gene_agg, key=lambda k: v_gene_agg[k])}\njs = {k for k in heapq.nlargest(top_n, j_gene_agg, key=lambda k: j_gene_agg[k])}\nreturn vs, js\ndef _sampling_gene_prediction(self, walk, top_n=1):\nV = []\nJ = []\nfor i in range(0, len(walk) - 1):\nif self.graph.has_edge(walk[i], walk[i + 1]):\nls = self.graph.get_edge_data(walk[i], walk[i + 1]).copy()\nvkeys = dict()\njkeys = dict()\nfor k in ls:\nif k not in {'weight', 'Vsum', 'Jsum'}:\nif 'V' in k:\nvkeys[k] = ls[k]\nelse:\njkeys[k] = ls[k]\nfor _ in range(25):\nV.append(choice(list(vkeys.keys()), list(vkeys.values())))\nJ.append(choice(list(jkeys.keys()), list(jkeys.values())))\nvcounter = Counter(V)\njcounter = Counter(J)\nif top_n == 1:\nreturn vcounter.most_common(1)[0][0], jcounter.most_common(1)[0][0]\nelse:\nvs = [i[0] for i in vcounter]\njs = [i[0] for i in jcounter]\nreturn vs, js\ndef _full_appearance_gene_prediction(self, walk, alpha=0):\nvgenes = list()\njgenes = list()\nwl = len(walk) - (1 + alpha)\nfor i in range(0, wl):\nif self.graph.has_edge(walk[i], walk[i + 1]):\nls = self.graph.get_edge_data(walk[i], walk[i + 1]).copy()\nvgenes += [i for i in ({*ls} - {'weight', 'Vsum', 'Jsum'}) if 'V' in i]\njgenes += [i for i in ({*ls} - {'weight', 'Vsum', 'Jsum'}) if 'J' in i]\nvcount = Counter(vgenes)\njcount = Counter(vgenes)\nreturn [w for w in vcount if vcount[w] == wl], [w for w in jcount if jcount[w] == wl]\ndef _raise_genetic_mode_error(self):\nif not self.genetic:\nraise Exception('Genomic Data Function Requires Gene Annotation Data, The Graph Has No Such Data')\ndef predict_vj_genes(self, walk, top_n=1, mode='max', alpha=0):\nif mode == 'max_sum':\nreturn self._max_sum_gene_prediction(walk, top_n=top_n)\nelif mode == 'max_product':\nreturn self._max_product_gene_prediction(walk, top_n=top_n)\nelif mode == 'sampling':\nreturn self._sampling_gene_prediction(walk, top_n=top_n)\nelif mode == 'full':\nreturn self._full_appearance_gene_prediction(walk, alpha)\ndef eigenvector_centrality(self):\nreturn nx.algorithms.eigenvector_centrality(self.graph, weight='weight')\ndef isolates(self):\n\"\"\"\n           A function that returns the list of all isolates in the graph.\n           an isolate is a node that is connected to 0 edges (unseen sub-pattern).\n                   Parameters:\n                           None\n                   Returns:\n                           list : a list of isolates\n                    \"\"\"\nreturn list(nx.isolates(self.graph))\ndef drop_isolates(self):\n\"\"\"\n         A function to drop all isolates from the graph.\n                 Parameters:\n                         None\n                 Returns:\n                         None\n                  \"\"\"\nself.graph.remove_nodes_from(self.isolates())\ndef is_dag(self):\n\"\"\"\n           the function checks whether the graph is a Directed acyclic graph\n               :return:\n               \"\"\"\nreturn nx.is_directed_acyclic_graph(self.graph)\n@property\ndef nodes(self):\nreturn self.graph.nodes\n@property\ndef edges(self):\nreturn self.graph.edges\ndef graph_summary(self):\n\"\"\"\n                          the function will return a pandas DataFrame containing the graphs\n                            Chromatic Number,Number of Isolates,Max In Deg,Max Out Deg,Number of Edges\n                        \"\"\"\nR = pd.Series({\n'Chromatic Number': max(nx.greedy_color(self.graph).values()) + 1,\n'Number of Isolates': nx.number_of_isolates(self.graph),\n'Max In Deg': max(dict(self.graph.in_degree).values()),\n'Max Out Deg': max(dict(self.graph.out_degree).values()),\n'Number of Edges': len(self.graph.edges),\n})\nreturn R\ndef voterank(self, n_nodes=25):\n\"\"\"\n                         Uses the VoteRank algorithm to return the top N influential nodes in the graph, where N is equal to n_nodes\n                                  Parameters:\n                                          n_nodes (int): the number of most influential nodes to find\n                                  Returns:\n                                          list : a list of top influential nodes\n                        \"\"\"\nreturn nx.algorithms.voterank(self.graph, number_of_nodes=n_nodes)\n</code></pre>"},{"location":"lzgraphbase_reference/#LZGraphs.LZGraphBase.LZGraphBase.__eq__","title":"<code>__eq__(other)</code>","text":"<p>This method test whether two LZGraph are equal, i.e. have the same node,edges and metadata on the edges.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if graph equal else False</p> Source code in <code>LZGraphs\\LZGraphBase.py</code> <pre><code>def __eq__(self, other):\n\"\"\" This method test whether two LZGraph are equal, i.e. have the same node,edges and metadata on the edges.\n                                Returns:\n                                    bool: True if graph equal else False\n      \"\"\"\nif nx.utils.graphs_equal(self.graph, other.graph):\naux = 0\naux += self.genetic_walks_black_list != other.genetic_walks_black_list\naux += self.n_subpatterns != other.n_subpatterns\naux += not self.initial_states.round(3).equals(other.initial_states.round(3))\naux += not self.terminal_states.round(3).equals(other.terminal_states.round(3))\n# test marginal_vgenes\naux += not other.marginal_vgenes.round(3).equals(self.marginal_vgenes.round(3))\n# test vj_probabilities\naux += not other.vj_probabilities.round(3).equals(self.vj_probabilities.round(3))\n# test length_distribution\naux += not other.length_distribution.round(3).equals(self.length_distribution.round(3))\n# test final_state\naux += not other.terminal_states.round(3).equals(self.terminal_states.round(3))\n# test length_distribution_proba\naux += not other.length_distribution_proba.round(3).equals(self.length_distribution_proba.round(3))\nif aux == 0:\nreturn True\nelse:\nreturn False\nelse:\nreturn False\n</code></pre>"},{"location":"lzgraphbase_reference/#LZGraphs.LZGraphBase.LZGraphBase.clean_node","title":"<code>clean_node(base)</code>  <code>staticmethod</code>","text":"<p>given a sub-pattern that has reading frame and position added to it, cleans it and returns only the nucleotides from the string</p> <pre><code>    Args:\n            base (str): a node from the NDPLZGraph\n\n    Returns:\n            str : only the nucleotides of the node\n</code></pre> Source code in <code>LZGraphs\\LZGraphBase.py</code> <pre><code>@staticmethod\ndef clean_node(base):\n\"\"\"\n      given a sub-pattern that has reading frame and position added to it, cleans it and returns\n      only the nucleotides from the string\n              Args:\n                      base (str): a node from the NDPLZGraph\n              Returns:\n                      str : only the nucleotides of the node\n \"\"\"\nreturn re.search(r'[ATGC]*', base).group()\n</code></pre>"},{"location":"lzgraphbase_reference/#LZGraphs.LZGraphBase.LZGraphBase.drop_isolates","title":"<code>drop_isolates()</code>","text":"<p>A function to drop all isolates from the graph.</p> <pre><code>    Parameters:\n            None\n\n    Returns:\n            None\n</code></pre> Source code in <code>LZGraphs\\LZGraphBase.py</code> <pre><code>def drop_isolates(self):\n\"\"\"\n     A function to drop all isolates from the graph.\n             Parameters:\n                     None\n             Returns:\n                     None\n              \"\"\"\nself.graph.remove_nodes_from(self.isolates())\n</code></pre>"},{"location":"lzgraphbase_reference/#LZGraphs.LZGraphBase.LZGraphBase.encode_sequence","title":"<code>encode_sequence(sequence)</code>  <code>staticmethod</code>","text":"<p>This method is abstract, when creating a new LZGraph class, one should override this method with a method that process a sequence of symbols (nucleotides/amino acids) and return a list of string where each string represents a node in the graph. note that it is implied that each pair of sequential string in the returned list are connect by an edge.</p> <pre><code>    Args:\n            sequence (str): a string from which to derive sub-patterns\n\n    Returns:\n            list : a list of unique sub-patterns\n</code></pre> Source code in <code>LZGraphs\\LZGraphBase.py</code> <pre><code>@staticmethod\ndef encode_sequence(sequence):\n\"\"\"\n      This method is abstract, when creating a new LZGraph class, one should override this method with a method\n      that process a sequence of symbols (nucleotides/amino acids) and return a list of string where each\n      string represents a node in the graph. note that it is implied that each pair of sequential string in the\n      returned list are connect by an edge.\n              Args:\n                      sequence (str): a string from which to derive sub-patterns\n              Returns:\n                      list : a list of unique sub-patterns\n   \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"lzgraphbase_reference/#LZGraphs.LZGraphBase.LZGraphBase.genomic_random_walk","title":"<code>genomic_random_walk(initial_state=None, vj_init='marginal')</code>","text":"<p>given a target sequence length and an initial state, the function will select a random V and a random J genes from the observed gene frequency in the graph's \"Training data\" and generate a walk on the graph from the initial state to a terminal state while making sure at each step that both the selected V and J genes were seen used by that specific sub-pattern.</p> <p>if seq_len is equal to \"unsupervised\" than a random seq len will be returned</p> Source code in <code>LZGraphs\\LZGraphBase.py</code> <pre><code>def genomic_random_walk(self, initial_state=None, vj_init='marginal'):\n\"\"\"\n         given a target sequence length and an initial state, the function will select a random\n         V and a random J genes from the observed gene frequency in the graph's \"Training data\" and\n         generate a walk on the graph from the initial state to a terminal state while making sure\n         at each step that both the selected V and J genes were seen used by that specific sub-pattern.\n         if seq_len is equal to \"unsupervised\" than a random seq len will be returned\n    \"\"\"\nself._raise_genetic_mode_error()\nselected_v, selected_j = self._select_random_vj_genes(vj_init)\nif initial_state is None:\ncurrent_state = self._random_initial_state()\nwalk = [current_state]\nelse:\ncurrent_state = initial_state\nwalk = [initial_state]\n# while the walk is not in a valid final state\nwhile not self.is_stop_condition(current_state, selected_v, selected_j):\n# get the node_data for the current state\nedge_info = self._get_node_feature_info_df(current_state, 'weight', selected_v, selected_j, asdict=True)\nif (current_state, selected_v, selected_j) in self.genetic_walks_black_list:\nfor col in self.genetic_walks_black_list[(current_state, selected_v, selected_j)]:\nedge_info.pop(col)\n# edge_info = edge_info.drop(\n#     columns=self.genetic_walks_black_list[(current_state, selected_v, selected_j)])\n# check selected path has genes\nif len(edge_info) == 0:\nif len(walk) &gt; 2:\nself.genetic_walks_black_list[(walk[-2], selected_v, selected_j)] \\\n                    = self.genetic_walks_black_list.get((walk[-2], selected_v, selected_j),\n[]) + [walk[-1]]\ncurrent_state = walk[-2]\nwalk = walk[:-1]\nelse:\nwalk = walk[:1]\ncurrent_state = walk[0]\nselected_v, selected_j = self._select_random_vj_genes(vj_init)\ncontinue\nw = np.array([edge_info[i]['weight'] for i in edge_info])\nw = w / w.sum()\ncurrent_state = choice([*edge_info], w)\nwalk.append(current_state)\nreturn walk, selected_v, selected_j\n</code></pre>"},{"location":"lzgraphbase_reference/#LZGraphs.LZGraphBase.LZGraphBase.graph_summary","title":"<code>graph_summary()</code>","text":"<p>the function will return a pandas DataFrame containing the graphs   Chromatic Number,Number of Isolates,Max In Deg,Max Out Deg,Number of Edges</p> Source code in <code>LZGraphs\\LZGraphBase.py</code> <pre><code>def graph_summary(self):\n\"\"\"\n                      the function will return a pandas DataFrame containing the graphs\n                        Chromatic Number,Number of Isolates,Max In Deg,Max Out Deg,Number of Edges\n                    \"\"\"\nR = pd.Series({\n'Chromatic Number': max(nx.greedy_color(self.graph).values()) + 1,\n'Number of Isolates': nx.number_of_isolates(self.graph),\n'Max In Deg': max(dict(self.graph.in_degree).values()),\n'Max Out Deg': max(dict(self.graph.out_degree).values()),\n'Number of Edges': len(self.graph.edges),\n})\nreturn R\n</code></pre>"},{"location":"lzgraphbase_reference/#LZGraphs.LZGraphBase.LZGraphBase.is_dag","title":"<code>is_dag()</code>","text":"<p>the function checks whether the graph is a Directed acyclic graph</p> <pre><code>:return:\n</code></pre> Source code in <code>LZGraphs\\LZGraphBase.py</code> <pre><code>def is_dag(self):\n\"\"\"\n       the function checks whether the graph is a Directed acyclic graph\n           :return:\n           \"\"\"\nreturn nx.is_directed_acyclic_graph(self.graph)\n</code></pre>"},{"location":"lzgraphbase_reference/#LZGraphs.LZGraphBase.LZGraphBase.isolates","title":"<code>isolates()</code>","text":"<p>A function that returns the list of all isolates in the graph. an isolate is a node that is connected to 0 edges (unseen sub-pattern).</p> <pre><code>    Parameters:\n            None\n\n    Returns:\n            list : a list of isolates\n</code></pre> Source code in <code>LZGraphs\\LZGraphBase.py</code> <pre><code>def isolates(self):\n\"\"\"\n       A function that returns the list of all isolates in the graph.\n       an isolate is a node that is connected to 0 edges (unseen sub-pattern).\n               Parameters:\n                       None\n               Returns:\n                       list : a list of isolates\n                \"\"\"\nreturn list(nx.isolates(self.graph))\n</code></pre>"},{"location":"lzgraphbase_reference/#LZGraphs.LZGraphBase.LZGraphBase.random_step","title":"<code>random_step(state)</code>","text":"<p>Given the current state, pick and take a random step based on the translation probabilities :param state: :return:</p> Source code in <code>LZGraphs\\LZGraphBase.py</code> <pre><code>def random_step(self, state):\n\"\"\"\n       Given the current state, pick and take a random step based on the translation probabilities\n       :param state:\n       :return:\n                   \"\"\"\nstates, probabilities = self._get_state_weights(state)\nreturn choice(states, probabilities)\n</code></pre>"},{"location":"lzgraphbase_reference/#LZGraphs.LZGraphBase.LZGraphBase.voterank","title":"<code>voterank(n_nodes=25)</code>","text":"<p>Uses the VoteRank algorithm to return the top N influential nodes in the graph, where N is equal to n_nodes</p> <pre><code>     Parameters:\n             n_nodes (int): the number of most influential nodes to find\n\n     Returns:\n             list : a list of top influential nodes\n</code></pre> Source code in <code>LZGraphs\\LZGraphBase.py</code> <pre><code>def voterank(self, n_nodes=25):\n\"\"\"\n                     Uses the VoteRank algorithm to return the top N influential nodes in the graph, where N is equal to n_nodes\n                              Parameters:\n                                      n_nodes (int): the number of most influential nodes to find\n                              Returns:\n                                      list : a list of top influential nodes\n                    \"\"\"\nreturn nx.algorithms.voterank(self.graph, number_of_nodes=n_nodes)\n</code></pre>"},{"location":"misc_reference/","title":"Misc Functions","text":"<p>Provide support for other library functionality.</p> <p>This module support various other operations in this library, any function with no specific scope appears here.</p> <p>The module contains the following functions:</p> <ul> <li><code>choice(options,probs)</code> - choose a random element from a list given a probability distribution over the elements.</li> <li><code>window(iterable, size)</code> - Return a sliding window generator of size \"size\".</li> <li><code>get_dictionary_subkeys(target)</code> - Returns a list of all sub dictionary keys.</li> <li><code>chunkify(L, n)</code> - Yield successive n-sized chunks from L.</li> </ul>"},{"location":"misc_reference/#LZGraphs.misc.choice","title":"<code>choice(options, probs)</code>","text":"<p>Choose a single random variable from a list given a probability distribution</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>list</code> <p>The list of values from which a single random one should be chosen</p> required <code>probs</code> <code>float</code> <p>Probability distribution.</p> required <p>Returns:</p> Name Type Description <code>element</code> <p>a random variable from list \"options\" with probability p in probas.</p> Source code in <code>LZGraphs\\misc.py</code> <pre><code>def choice(options,probs):\n\"\"\"Choose a single random variable from a list given a probability distribution\n      Args:\n          options (list): The list of values from which a single random one should be chosen\n          probs (float): Probability distribution.\n      Returns:\n          element: a random variable from list \"options\" with probability p in probas.\n      \"\"\"\nx = np.random.rand()\ncum = 0\ni = None\nfor i,p in enumerate(probs):\ncum += p\nif x &lt; cum:\nbreak\nreturn options[i]\n</code></pre>"},{"location":"misc_reference/#LZGraphs.misc.chunkify","title":"<code>chunkify(L, n)</code>","text":"<p>Yield successive n-sized chunks from L.</p> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>iterable</code> <p>An iterable of elements to partition into n-sized chunks</p> required <p>Returns:</p> Name Type Description <code>generator</code> <p>a generator that will return the next chunck each time its called until all of L is returned.</p> Source code in <code>LZGraphs\\misc.py</code> <pre><code>def chunkify(L, n):\n\"\"\" Yield successive n-sized chunks from L.\n          Args:\n              L (iterable): An iterable of elements to partition into n-sized chunks\n              n (int) the size of each chunck.\n          Returns:\n              generator: a generator that will return the next chunck each time its called until all of L is returned.\n    \"\"\"\nfor i in range(0, len(L), n):\nyield L[i:i+n]\n</code></pre>"},{"location":"misc_reference/#LZGraphs.misc.get_dictionary_subkeys","title":"<code>get_dictionary_subkeys(target)</code>","text":"<p>Returns a list of all sub dictionary keys.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>dict</code> <p>a dictionary of dictionaries.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>a list of all the keys contained in the sub dictionaries.</p> Source code in <code>LZGraphs\\misc.py</code> <pre><code>def get_dictionary_subkeys(target):\n\"\"\"Returns a list of all sub dictionary keys.\n          Args:\n              target (dict): a dictionary of dictionaries.\n          Returns:\n              list: a list of all the keys contained in the sub dictionaries.\n          \"\"\"\nsubkeys = []\nfor key in target:\nsubkeys +=[*target[key]]\nreturn subkeys\n</code></pre>"},{"location":"misc_reference/#LZGraphs.misc.window","title":"<code>window(iterable, size)</code>","text":"<p>Return a sliding window generator of size \"size\".</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>iterable</code> <p>An iterable of elements</p> required <code>size</code> <code>int</code> <p>The size of the sliding window.</p> required <p>Returns:</p> Name Type Description <code>zip</code> <p>a zip of all windows of size \"size\"</p> Source code in <code>LZGraphs\\misc.py</code> <pre><code>def window(iterable, size):\n\"\"\"Return a sliding window generator of size \"size\".\n          Args:\n              iterable (iterable): An iterable of elements\n              size (int): The size of the sliding window.\n          Returns:\n              zip: a zip of all windows of size \"size\"\n          \"\"\"\niters = tee(iterable, size)\nfor i in range(1, size):\nfor each in iters[i:]:\nnext(each, None)\nreturn zip(*iters)\n</code></pre>"},{"location":"ndplgraph_reference/","title":"NDPLZGraph Class","text":""},{"location":"ndplgraph_reference/#LZGraphs.NucleotideDoublePositional.NDPLZGraph","title":"<code>NDPLZGraph</code>","text":"<p>         Bases: <code>LZGraphBase</code></p> <p>This class implements the logic and infrastructure of the \"Nucleotide Double Positional\" version of the LZGraph   The nodes of this graph are LZ sub-patterns with added reading frame start position and the start position   in the sequence, formally: {lz_subpattern}{reading frame start}_{start position in sequence},   This class best fits analysis and inference of nucleotide sequences.</p> <p>...</p> <p>Parameters:</p> Name Type Description Default <code>walk_probability(walk,verbose=True)</code> <p>returns the PGEN of the given walk (list of sub-patterns)</p> required <code>is_dag()</code> <p>the function checks whether the graph is a Directed acyclic graph</p> required <code>walk_genes(walk,dropna=True)</code> <p>give a walk on the graph (a list of nodes) the function will return a table representing the possible genes and their probabilities at each edge of the walk.</p> required <code>path_gene_table(cdr3_sample,threshold=None)</code> <p>the function will return two tables of all possible v and j genes that colud be used to generate the sequence given by \"cdr3_sample\"</p> required <code>path_gene_table_plot(threshold=None,figsize=None)</code> <p>the function plots two heatmap, one for V genes and one for J genes, and represents the probability at each edge to select that gene, the color at each cell is equal to the probability of selecting the gene, a black cell means that the graph didn't see that gene used with that sub-pattern.</p> <p>the data used to create the charts can be derived by using the \"path_gene_table\" method.</p> required <code>gene_variation(cdr3)</code> <p>given a sequence, this will derive a charts that shows the number of V and J genes observed per node (LZ- subpattern).</p> required <code>gene_variation_plot(cdr3)</code> <p>Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count and one for J gene count.</p> required <code>random_walk(steps)</code> <p>given a number of steps (sub-patterns) returns a random walk on the graph between a random inital state  to a random terminal state in the given number of steps</p> required <code>gene_random_walk(seq_len,</code> <code>initial_state</code> <p>given a target sequence length and an initial state, the function will select a random V and a random J genes from the observed gene frequency in the graph's \"Training data\" and generate a walk on the graph from the initial state to a terminal state while making sure at each step that both the selected V and J genes were seen used by that specific sub-pattern.</p> required <code>unsupervised_random_walk()</code> <p>a random initial state and a random terminal state are selected and a random unsupervised walk is carried out until the randomly selected terminal state is reached.</p> required <code>eigenvector_centrality()</code> <p>return the eigen vector centrality value for each node (this function is used as the feature extractor for the LZGraph)</p> required <code>sequence_variation_curve(cdr3_sample)</code> <p>given a cdr3 sequence, the function will calculate the value of the variation curve and return 2 arrays, 1 of the sub-patterns and 1 for the number of out neighbours for each sub-pattern</p> required <code>graph_summary()</code> <p>the function will return a pandas DataFrame containing the graphs Chromatic Number,Number of Isolates,Max In Deg,Max Out Deg,Number of Edges</p> <p>Attributes:</p> <pre><code>nodes:\n    returns the nodes of the graph\nedges:\n    return the edges of the graph\n</code></pre> required Source code in <code>LZGraphs\\NucleotideDoublePositional.py</code> <pre><code>class NDPLZGraph(LZGraphBase):\n\"\"\"\n          This class implements the logic and infrastructure of the \"Nucleotide Double Positional\" version of the LZGraph\n          The nodes of this graph are LZ sub-patterns with added reading frame start position and the start position\n          in the sequence, formally: {lz_subpattern}{reading frame start}_{start position in sequence},\n          This class best fits analysis and inference of nucleotide sequences.\n          ...\n        Args:\n          walk_probability(walk,verbose=True):\n              returns the PGEN of the given walk (list of sub-patterns)\n          is_dag():\n            the function checks whether the graph is a Directed acyclic graph\n          walk_genes(walk,dropna=True):\n            give a walk on the graph (a list of nodes) the function will return a table\n            representing the possible genes and their probabilities at each edge of the walk.\n          path_gene_table(cdr3_sample,threshold=None):\n            the function will return two tables of all possible v and j genes\n            that colud be used to generate the sequence given by \"cdr3_sample\"\n          path_gene_table_plot(threshold=None,figsize=None):\n            the function plots two heatmap, one for V genes and one for J genes,\n            and represents the probability at each edge to select that gene,\n            the color at each cell is equal to the probability of selecting the gene, a black\n            cell means that the graph didn't see that gene used with that sub-pattern.\n            the data used to create the charts can be derived by using the \"path_gene_table\" method.\n          gene_variation(cdr3):\n            given a sequence, this will derive a charts that shows the number of V and J genes observed\n            per node (LZ- subpattern).\n          gene_variation_plot(cdr3):\n            Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count\n            and one for J gene count.\n          random_walk(steps):\n             given a number of steps (sub-patterns) returns a random walk on the graph between a random inital state\n             to a random terminal state in the given number of steps\n          gene_random_walk(seq_len, initial_state):\n            given a target sequence length and an initial state, the function will select a random\n            V and a random J genes from the observed gene frequency in the graph's \"Training data\" and\n            generate a walk on the graph from the initial state to a terminal state while making sure\n            at each step that both the selected V and J genes were seen used by that specific sub-pattern.\n          unsupervised_random_walk():\n            a random initial state and a random terminal state are selected and a random unsupervised walk is\n            carried out until the randomly selected terminal state is reached.\n          eigenvector_centrality():\n            return the eigen vector centrality value for each node (this function is used as the feature extractor\n            for the LZGraph)\n          sequence_variation_curve(cdr3_sample):\n            given a cdr3 sequence, the function will calculate the value of the variation curve and return\n            2 arrays, 1 of the sub-patterns and 1 for the number of out neighbours for each sub-pattern\n          graph_summary():\n            the function will return a pandas DataFrame containing the graphs\n            Chromatic Number,Number of Isolates,Max In Deg,Max Out Deg,Number of Edges\n            Attributes:\n                nodes:\n                    returns the nodes of the graph\n                edges:\n                    return the edges of the graph\n    \"\"\"\ndef __init__(self, data, verbose=True, calculate_trainset_pgen=False):\n\"\"\"\n        :param data: a padnas dataframe with 1 mandatory column \"cdr3_rearrangement\" which is all the cdr3 neuclitode\n        sequences , optinaly genes can be added to graph for gene inference via adding a \"V\" and \"J\" column\n        :param verbose:\n        :param dictionary:\n        \"\"\"\nsuper().__init__()\n# check for V and J gene data in input\nself.genetic = True if type(data) == pd.DataFrame and 'V' in data.columns and 'J' in data.columns else False\nif self.genetic:\nself._load_gene_data(data)\nself.verbose_driver(0, verbose)\n# construct the graph while iterating over the data\nself.__simultaneous_graph_construction(data)\nself.verbose_driver(1, verbose)\n# convert to pandas series and  normalize\nself.length_distribution = pd.Series(self.lengths)\nself.terminal_states = pd.Series(self.terminal_states)\nself.initial_states = pd.Series(self.initial_states)\nself.length_distribution_proba = self.terminal_states / self.terminal_states.sum()\nself.initial_states = self.initial_states[self.initial_states &gt; 5]\nself.initial_states_probability = self.initial_states/self.initial_states.sum()\nself.verbose_driver(2, verbose)\nself._derive_subpattern_individual_probability()\nself.verbose_driver(8, verbose)\nself._normalize_edge_weights()\nself.verbose_driver(3, verbose)\nif self.genetic:\n# Normalized Gene Weights\nself._batch_gene_weight_normalization(3, verbose)\nself.verbose_driver(4, verbose)\nself.edges_list = None\nself._derive_terminal_state_map()\nself.verbose_driver(7, verbose)\nself._derive_stop_probability_data()\nself.verbose_driver(8, verbose)\nself.verbose_driver(5, verbose)\nself.constructor_end_time = time()\nself.verbose_driver(6, verbose)\nif calculate_trainset_pgen:\nself.train_pgen = np.array(\n[self.walk_probability(self.encode_sequence(i), verbose=False) for i in data['cdr3_rearrangement']])\nself.verbose_driver(-2, verbose)\n@staticmethod\ndef encode_sequence(cdr3):\n\"\"\"\n              given a sequence of nucleotides this function will encode it into the following format:\n              {lz_subpattern}{reading frame start}_{start position in sequence}\n              matching the requirement of the NDPLZGraph.\n                      Parameters:\n                              cdr3 (str): a string to encode into the NDPLZGraph format\n                      Returns:\n                              list : a list of unique sub-patterns in the NDPLZGraph format\n       \"\"\"\nlz, rf, pos = derive_lz_reading_frame_position(cdr3)\nreturn list(map(lambda x, y, z: x + str(y) + '_' + str(z), lz, rf, pos))\n@staticmethod\ndef clean_node(base):\n\"\"\"\n          given a sub-pattern that has reading frame and position added to it, cleans it and returns\n          only the nucleotides from the string\n                  Parameters:\n                          base (str): a node from the NDPLZGraph\n                  Returns:\n                          str : only the nucleotides of the node\n     \"\"\"\nreturn re.search(r'[ATGC]*', base).group()\ndef _decomposed_sequence_generator(self,data):\nif self.genetic:\nfor cdr3, v, j in tqdm(zip(data['cdr3_rearrangement'], data['V'], data['J']), leave=False):\nsubpattern, reading_frame, position = derive_lz_reading_frame_position(cdr3)\nsteps = (window(subpattern, 2))\nreading_frames = (window(reading_frame, 2))\nlocations = (window(position, 2))\nself.lengths[len(cdr3)] = self.lengths.get(len(cdr3), 0) + 1\nself._update_terminal_states(subpattern[-1] + str(reading_frame[-1]) + '_' + str(position[-1]))\nself._update_initial_states(subpattern[0] + str(reading_frame[0]) + '_1')\nyield steps,reading_frames, locations, v, j\nelse:\nfor cdr3 in tqdm(list(data), leave=False):\nsubpattern, reading_frame, position = derive_lz_reading_frame_position(cdr3)\nsteps = (window(subpattern, 2))\nreading_frames = (window(reading_frame, 2))\nlocations = (window(position, 2))\nself.lengths[len(cdr3)] = self.lengths.get(len(cdr3), 0) + 1\nself._update_terminal_states(subpattern[-1] + str(reading_frame[-1]) + '_' + str(position[-1]))\nself._update_initial_states(subpattern[0] + str(reading_frame[0]) + '_1')\nyield steps,reading_frames,locations\ndef __simultaneous_graph_construction(self,data):\nprocessing_stream = self._decomposed_sequence_generator(data)\nif self.genetic:\nfor output in processing_stream:\nsteps,reading_frames,locations,v,j = output\nfor (A, B), (pos_a, pos_b), (loc_a, loc_b) in zip(steps, reading_frames, locations):\nA_ = A + str(pos_a) + '_' + str(loc_a)\nself.per_node_observed_frequency[A_] = self.per_node_observed_frequency.get(A_,0)+1\nB_ = B + str(pos_b) + '_' + str(loc_b)\nself._insert_edge_and_information(A_, B_, v, j)\nself.per_node_observed_frequency[B_] = self.per_node_observed_frequency.get(B_, 0)\nelse:\nfor output in processing_stream:\nsteps, reading_frames, locations = output\nfor (A, B), (pos_a, pos_b), (loc_a, loc_b) in zip(steps, reading_frames, locations):\nA_ = A + str(pos_a) + '_' + str(loc_a)\nself.per_node_observed_frequency[A_] = self.per_node_observed_frequency.get(A_,0)+1\nB_ = B + str(pos_b) + '_' + str(loc_b)\nself._insert_edge_and_information_no_genes(A_, B_)\ndef walk_probability(self, walk, verbose=True):\n\"\"\"\n             given a walk (a sequence converted into LZ sub-pattern) return the probability of generation (PGEN)\n             of the walk.\n             you can use \"lempel_ziv_decomposition\" from this libraries decomposition module in order to convert a\n             sequence into LZ sub-patterns\n                      Parameters:\n                              walk (list): a list of LZ - sub-patterns\n                      Returns:\n                              float : the probability of generating such a walk (PGEN)\n               \"\"\"\nif type(walk) == str:\nLZ, POS = derive_lz_reading_frame_position(walk)\nwalk_ = [i + str(j) for i, j in zip(LZ, POS)]\nelse:\nwalk_ = walk\nproba = self.subpattern_individual_probability['proba'][walk_[0]]\nfor step1, step2 in window(walk_, 2):\nif self.graph.has_edge(step1, step2):\nproba *= self.graph.get_edge_data(step1, step2)['weight']\nelse:\nif verbose:\nprint('No Edge Connecting| ', step1, '--&gt;', step2)\nreturn 0\nreturn proba\n# def random_walk(self, seq_len, initial_state):\n#     \"\"\"\n#       given a number of steps (sub-patterns) returns a random walk on the graph between a random inital state\n#         to a random terminal state in the given number of steps\n#\n#\n#                  Parameters:\n#                          steps (int): number of sub-patterns the resulting walk should contain\n#                  Returns:\n#                          (list) : a list of LZ sub-patterns representing the random walk\n#           \"\"\"\n#     current_state = initial_state\n#     walk = [initial_state]\n#     sequence = clean_node(initial_state)\n#\n#     terminal_states = self._length_specific_terminal_state(seq_len)\n#\n#     if len(terminal_states) &lt; 1:\n#         raise Exception('Unfamiliar Seq Length')\n#\n#     while current_state not in terminal_states:\n#         states, probabilities = self._get_state_weights(current_state)\n#         # Try add dynamic dictionary of weight that will remove invalid paths\n#\n#         # if went into a final path with mismatch length\n#         if len(probabilities) == 0:  # no options we can take from here\n#             # go back to the last junction where a different choice can be made\n#             for ax in range(len(walk) - 1, 1, -1):\n#                 for final_s in terminal_states:\n#                     try:\n#                         SP = nx.dijkstra_path(self.graph, source=walk[ax], target=final_s,\n#                                               weight=lambda x, y, z: 1 - z['weight'])\n#                         walk = walk[:ax] + SP\n#                         sequence = ''.join([clean_node(i) for i in walk])\n#                         return walk\n#                     except nx.NetworkXNoPath:\n#                         continue\n#\n#         current_state = np.random.choice(states, size=1, p=probabilities).item()\n#         walk.append(current_state)\n#         sequence += clean_node(current_state)\n#\n#     return walk\ndef gene_random_walk(self, seq_len, initial_state=None, vj_init='marginal'):\n\"\"\"\n            given a target sequence length and an initial state, the function will select a random\n            V and a random J genes from the observed gene frequency in the graph's \"Training data\" and\n            generate a walk on the graph from the initial state to a terminal state while making sure\n            at each step that both the selected V and J genes were seen used by that specific sub-pattern.\n            if seq_len is equal to \"unsupervised\" than a random seq len will be returned\n       \"\"\"\nselected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\nif seq_len == 'unsupervised':\nterminal_states = self.terminal_states\ninitial_state = self._random_initial_state()\nelse:\nterminal_states = self._length_specific_terminal_state(seq_len)\ncurrent_state = initial_state\nwalk = [initial_state]\n# nodes not to consider due to invalidity\nif self.genetic_walks_black_list is None:\nself.genetic_walks_black_list = dict()\n# while the walk is not in a valid final state\nwhile current_state not in terminal_states:\n# print('Blacklist: ',blacklist)\n# print('='*30)\n# get the node_data for the current state\nedge_info = pd.DataFrame(dict(self.graph[current_state]))\nif (current_state,selected_gene_path_v,selected_gene_path_j) in self.genetic_walks_black_list:\nedge_info = edge_info.drop(columns=self.genetic_walks_black_list[(current_state,selected_gene_path_v,selected_gene_path_j)])\n# check selected path has genes\nif len(set(edge_info.index) &amp; {selected_gene_path_v, selected_gene_path_j}) != 2:\n# TODO: add a visited node stack to not repeat the same calls and mistakes\nif len(walk) &gt; 2:\nself.genetic_walks_black_list[(walk[-2],selected_gene_path_v,selected_gene_path_j)]\\\n                        = self.genetic_walks_black_list.get((walk[-2],selected_gene_path_v,selected_gene_path_j), []) + [walk[-1]]\ncurrent_state = walk[-2]\nwalk = walk[:-1]\nelse:\nwalk = walk[:1]\ncurrent_state = walk[0]\nselected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\ncontinue\n# get paths containing selected_genes\nidf = edge_info.T[[selected_gene_path_v, selected_gene_path_j]].dropna()\nw = edge_info.loc['weight', idf.index]\nw = w / w.sum()\nif len(w) == 0:\nif len(walk) &gt; 2:\nself.genetic_walks_black_list[(walk[-2],selected_gene_path_v,selected_gene_path_j)] = \\\n                        self.genetic_walks_black_list.get((walk[-2],selected_gene_path_v,selected_gene_path_j), []) + [walk[-1]]\ncurrent_state = walk[-2]\nwalk = walk[:-1]\nelse:\nwalk = walk[:1]\ncurrent_state = walk[0]\nselected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\ncontinue\n# if len(w) == 0:  # no options we can take from here\n#     # go back to the last junction where a different choice can be made\n#     for ax in range(len(walk) - 1, 1, -1):\n#         for final_s in terminal_states:\n#             try:\n#                 SP = nx.dijkstra_path(self.graph, source=walk[ax], target=final_s,\n#                                       weight=lambda x, y, z: 1 - z['weight'])\n#                 walk = walk[:ax] + SP\n#                 sequence = ''.join([clean_node(i) for i in walk])\n#                 raise Exception(f' Ended After Selecting SP '+str(walk))\n#             except nx.NetworkXNoPath:\n#                 continue\ncurrent_state = np.random.choice(w.index, size=1, p=w.values).item()\nwalk.append(current_state)\nreturn walk, selected_gene_path_v, selected_gene_path_j\ndef unsupervised_random_walk(self):\n\"\"\"\n                     a random initial state and a random terminal state are selected and a random unsupervised walk is\n                    carried out until the randomly selected terminal state is reached.\n                              Parameters:\n                                      None\n                              Returns:\n                                      (list,str) : a list of LZ sub-patterns representing the random walk and a string\n                                      matching the walk only translated back into a sequence.\n               \"\"\"\nrandom_initial_state = self._random_initial_state()\ncurrent_state = random_initial_state\nwalk = [random_initial_state]\nsequence = self.clean_node(random_initial_state)\nwhile current_state not in self.terminal_states:\n# take a random step\ncurrent_state = self.random_step(current_state)\nwalk.append(current_state)\nsequence += self.clean_node(current_state)\nreturn walk, sequence\ndef walk_genes(self, walk,dropna=True):\n\"\"\"\n        give a walk on the graph (a list of nodes) the function will return a table\n            representing the possible genes and their probabilities at each edge of the walk.\n        :param walk:\n        :param dropna:\n        :return:\n        \"\"\"\ntrans_genes = []\ncolumns = []\nfor i in range(0, len(walk) - 1):\nls = self.graph.get_edge_data(walk[i], walk[i + 1]).copy()\ncolumns.append(walk[i] + '-&gt;' + walk[i + 1])\nls.pop('weight')\nls.pop('Vsum')\nls.pop('Jsum')\ntrans_genes.append(pd.Series(ls))\ncc = pd.concat(trans_genes, axis=1)\nif dropna:\ncc = cc.dropna()\nif cc.shape[0] == 0:\nraise Exception('No Constant Gene Flow F')\ncc.columns = columns\ncc['type'] = ['v' if 'v' in x.lower() else 'j' for x in cc.index]\ncc['sum'] = cc.sum(axis=1, numeric_only=True)\ncc = cc.sort_values(by='sum', ascending=False)\nreturn cc\ndef sequence_variation_curve(self,cdr3_sample):\n\"\"\"\n        given a sequence this function will return 2 list,\n        the first is the lz-subpattern path through the graph and the second list is the number\n        of possible choices that can be made at each sub-pattern\n        :param cdr3_sample:\n        :return:\n        \"\"\"\nencoded = self.self.encode_sequence(cdr3_sample)\ncurve = [self.graph.out_degree(i) for i in encoded]\nreturn encoded,curve\ndef path_gene_table(self,cdr3_sample,threshold=None):\n\"\"\"\n        the function will return two tables of all possible v and j genes\n            that colud be used to generate the sequence given by \"cdr3_sample\"\n        :param cdr3_sample: a cdr3 sequence\n        :param threshold: drop genes that are missing from threshold % of the sequence\n        :return:\n        \"\"\"\nlength = len(self.encode_sequence(cdr3_sample))\nif threshold is None:\nthreshold = length * (1 / 4)\ngene_table = self.walk_genes(self.encode_sequence(cdr3_sample), dropna=False)\ngene_table = gene_table[gene_table.isna().sum(axis=1) &lt; threshold]\nvgene_table = gene_table[gene_table.index.str.contains('V')]\ngene_table = self.walk_genes(self.encode_sequence(cdr3_sample), dropna=False)\ngene_table = gene_table[gene_table.isna().sum(axis=1) &lt; (length * (1 / 2))]\njgene_table = gene_table[gene_table.index.str.contains('J')]\njgene_table = jgene_table.loc[jgene_table.isna().sum(axis=1).sort_values(ascending=True).index, :]\nvgene_table = vgene_table.loc[vgene_table.isna().sum(axis=1).sort_values(ascending=True).index, :]\nreturn vgene_table,jgene_table\ndef gene_variation(self,cdr3):\n\"\"\"\n        Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count\n            and one for J gene count.\n        :param cdr3:\n        :return:\n        \"\"\"\nif not self.genetic:\nraise Exception('The LZGraph Has No Gene Data')\nencoded_a = self.encode_sequence(cdr3)\nnv_genes = [len(self.marginal_vgenes)]\nnj_genes = [len(self.marginal_jgenes)]\nfor node in encoded_a[1:]:\ninedges = self.graph.in_edges(node)\nv = set()\nj = set()\nfor ea, eb in inedges:\ngenes = pd.Series(self.graph[ea][eb]).drop(index=['Vsum', 'Jsum', 'weight'])\nv = v | set(genes[genes.index.str.contains('V')].index)\nj = j | set(genes[genes.index.str.contains('J')].index)\nnv_genes.append(len(v))\nnj_genes.append(len(j))\nnj_genes = np.array(nj_genes)\nnv_genes = np.array(nv_genes)\nj_df = pd.DataFrame(\n{'genes': list(nv_genes) + list(nj_genes), 'type': ['V'] * len(nv_genes) + ['J'] * len(nj_genes),\n'sp': lempel_ziv_decomposition(cdr3) + lempel_ziv_decomposition(cdr3)})\nreturn j_df\n</code></pre>"},{"location":"ndplgraph_reference/#LZGraphs.NucleotideDoublePositional.NDPLZGraph.__init__","title":"<code>__init__(data, verbose=True, calculate_trainset_pgen=False)</code>","text":"<p>:param data: a padnas dataframe with 1 mandatory column \"cdr3_rearrangement\" which is all the cdr3 neuclitode sequences , optinaly genes can be added to graph for gene inference via adding a \"V\" and \"J\" column :param verbose: :param dictionary:</p> Source code in <code>LZGraphs\\NucleotideDoublePositional.py</code> <pre><code>def __init__(self, data, verbose=True, calculate_trainset_pgen=False):\n\"\"\"\n    :param data: a padnas dataframe with 1 mandatory column \"cdr3_rearrangement\" which is all the cdr3 neuclitode\n    sequences , optinaly genes can be added to graph for gene inference via adding a \"V\" and \"J\" column\n    :param verbose:\n    :param dictionary:\n    \"\"\"\nsuper().__init__()\n# check for V and J gene data in input\nself.genetic = True if type(data) == pd.DataFrame and 'V' in data.columns and 'J' in data.columns else False\nif self.genetic:\nself._load_gene_data(data)\nself.verbose_driver(0, verbose)\n# construct the graph while iterating over the data\nself.__simultaneous_graph_construction(data)\nself.verbose_driver(1, verbose)\n# convert to pandas series and  normalize\nself.length_distribution = pd.Series(self.lengths)\nself.terminal_states = pd.Series(self.terminal_states)\nself.initial_states = pd.Series(self.initial_states)\nself.length_distribution_proba = self.terminal_states / self.terminal_states.sum()\nself.initial_states = self.initial_states[self.initial_states &gt; 5]\nself.initial_states_probability = self.initial_states/self.initial_states.sum()\nself.verbose_driver(2, verbose)\nself._derive_subpattern_individual_probability()\nself.verbose_driver(8, verbose)\nself._normalize_edge_weights()\nself.verbose_driver(3, verbose)\nif self.genetic:\n# Normalized Gene Weights\nself._batch_gene_weight_normalization(3, verbose)\nself.verbose_driver(4, verbose)\nself.edges_list = None\nself._derive_terminal_state_map()\nself.verbose_driver(7, verbose)\nself._derive_stop_probability_data()\nself.verbose_driver(8, verbose)\nself.verbose_driver(5, verbose)\nself.constructor_end_time = time()\nself.verbose_driver(6, verbose)\nif calculate_trainset_pgen:\nself.train_pgen = np.array(\n[self.walk_probability(self.encode_sequence(i), verbose=False) for i in data['cdr3_rearrangement']])\nself.verbose_driver(-2, verbose)\n</code></pre>"},{"location":"ndplgraph_reference/#LZGraphs.NucleotideDoublePositional.NDPLZGraph.clean_node","title":"<code>clean_node(base)</code>  <code>staticmethod</code>","text":"<p>given a sub-pattern that has reading frame and position added to it, cleans it and returns only the nucleotides from the string</p> <pre><code>    Parameters:\n            base (str): a node from the NDPLZGraph\n\n    Returns:\n            str : only the nucleotides of the node\n</code></pre> Source code in <code>LZGraphs\\NucleotideDoublePositional.py</code> <pre><code>@staticmethod\ndef clean_node(base):\n\"\"\"\n      given a sub-pattern that has reading frame and position added to it, cleans it and returns\n      only the nucleotides from the string\n              Parameters:\n                      base (str): a node from the NDPLZGraph\n              Returns:\n                      str : only the nucleotides of the node\n \"\"\"\nreturn re.search(r'[ATGC]*', base).group()\n</code></pre>"},{"location":"ndplgraph_reference/#LZGraphs.NucleotideDoublePositional.NDPLZGraph.encode_sequence","title":"<code>encode_sequence(cdr3)</code>  <code>staticmethod</code>","text":"<p>given a sequence of nucleotides this function will encode it into the following format: {lz_subpattern}{reading frame start}_{start position in sequence} matching the requirement of the NDPLZGraph.</p> <pre><code>    Parameters:\n            cdr3 (str): a string to encode into the NDPLZGraph format\n\n    Returns:\n            list : a list of unique sub-patterns in the NDPLZGraph format\n</code></pre> Source code in <code>LZGraphs\\NucleotideDoublePositional.py</code> <pre><code>@staticmethod\ndef encode_sequence(cdr3):\n\"\"\"\n          given a sequence of nucleotides this function will encode it into the following format:\n          {lz_subpattern}{reading frame start}_{start position in sequence}\n          matching the requirement of the NDPLZGraph.\n                  Parameters:\n                          cdr3 (str): a string to encode into the NDPLZGraph format\n                  Returns:\n                          list : a list of unique sub-patterns in the NDPLZGraph format\n   \"\"\"\nlz, rf, pos = derive_lz_reading_frame_position(cdr3)\nreturn list(map(lambda x, y, z: x + str(y) + '_' + str(z), lz, rf, pos))\n</code></pre>"},{"location":"ndplgraph_reference/#LZGraphs.NucleotideDoublePositional.NDPLZGraph.gene_random_walk","title":"<code>gene_random_walk(seq_len, initial_state=None, vj_init='marginal')</code>","text":"<p>given a target sequence length and an initial state, the function will select a random V and a random J genes from the observed gene frequency in the graph's \"Training data\" and generate a walk on the graph from the initial state to a terminal state while making sure at each step that both the selected V and J genes were seen used by that specific sub-pattern.</p> <p>if seq_len is equal to \"unsupervised\" than a random seq len will be returned</p> Source code in <code>LZGraphs\\NucleotideDoublePositional.py</code> <pre><code>def gene_random_walk(self, seq_len, initial_state=None, vj_init='marginal'):\n\"\"\"\n        given a target sequence length and an initial state, the function will select a random\n        V and a random J genes from the observed gene frequency in the graph's \"Training data\" and\n        generate a walk on the graph from the initial state to a terminal state while making sure\n        at each step that both the selected V and J genes were seen used by that specific sub-pattern.\n        if seq_len is equal to \"unsupervised\" than a random seq len will be returned\n   \"\"\"\nselected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\nif seq_len == 'unsupervised':\nterminal_states = self.terminal_states\ninitial_state = self._random_initial_state()\nelse:\nterminal_states = self._length_specific_terminal_state(seq_len)\ncurrent_state = initial_state\nwalk = [initial_state]\n# nodes not to consider due to invalidity\nif self.genetic_walks_black_list is None:\nself.genetic_walks_black_list = dict()\n# while the walk is not in a valid final state\nwhile current_state not in terminal_states:\n# print('Blacklist: ',blacklist)\n# print('='*30)\n# get the node_data for the current state\nedge_info = pd.DataFrame(dict(self.graph[current_state]))\nif (current_state,selected_gene_path_v,selected_gene_path_j) in self.genetic_walks_black_list:\nedge_info = edge_info.drop(columns=self.genetic_walks_black_list[(current_state,selected_gene_path_v,selected_gene_path_j)])\n# check selected path has genes\nif len(set(edge_info.index) &amp; {selected_gene_path_v, selected_gene_path_j}) != 2:\n# TODO: add a visited node stack to not repeat the same calls and mistakes\nif len(walk) &gt; 2:\nself.genetic_walks_black_list[(walk[-2],selected_gene_path_v,selected_gene_path_j)]\\\n                    = self.genetic_walks_black_list.get((walk[-2],selected_gene_path_v,selected_gene_path_j), []) + [walk[-1]]\ncurrent_state = walk[-2]\nwalk = walk[:-1]\nelse:\nwalk = walk[:1]\ncurrent_state = walk[0]\nselected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\ncontinue\n# get paths containing selected_genes\nidf = edge_info.T[[selected_gene_path_v, selected_gene_path_j]].dropna()\nw = edge_info.loc['weight', idf.index]\nw = w / w.sum()\nif len(w) == 0:\nif len(walk) &gt; 2:\nself.genetic_walks_black_list[(walk[-2],selected_gene_path_v,selected_gene_path_j)] = \\\n                    self.genetic_walks_black_list.get((walk[-2],selected_gene_path_v,selected_gene_path_j), []) + [walk[-1]]\ncurrent_state = walk[-2]\nwalk = walk[:-1]\nelse:\nwalk = walk[:1]\ncurrent_state = walk[0]\nselected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\ncontinue\n# if len(w) == 0:  # no options we can take from here\n#     # go back to the last junction where a different choice can be made\n#     for ax in range(len(walk) - 1, 1, -1):\n#         for final_s in terminal_states:\n#             try:\n#                 SP = nx.dijkstra_path(self.graph, source=walk[ax], target=final_s,\n#                                       weight=lambda x, y, z: 1 - z['weight'])\n#                 walk = walk[:ax] + SP\n#                 sequence = ''.join([clean_node(i) for i in walk])\n#                 raise Exception(f' Ended After Selecting SP '+str(walk))\n#             except nx.NetworkXNoPath:\n#                 continue\ncurrent_state = np.random.choice(w.index, size=1, p=w.values).item()\nwalk.append(current_state)\nreturn walk, selected_gene_path_v, selected_gene_path_j\n</code></pre>"},{"location":"ndplgraph_reference/#LZGraphs.NucleotideDoublePositional.NDPLZGraph.gene_variation","title":"<code>gene_variation(cdr3)</code>","text":"<p>Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count     and one for J gene count. :param cdr3: :return:</p> Source code in <code>LZGraphs\\NucleotideDoublePositional.py</code> <pre><code>def gene_variation(self,cdr3):\n\"\"\"\n    Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count\n        and one for J gene count.\n    :param cdr3:\n    :return:\n    \"\"\"\nif not self.genetic:\nraise Exception('The LZGraph Has No Gene Data')\nencoded_a = self.encode_sequence(cdr3)\nnv_genes = [len(self.marginal_vgenes)]\nnj_genes = [len(self.marginal_jgenes)]\nfor node in encoded_a[1:]:\ninedges = self.graph.in_edges(node)\nv = set()\nj = set()\nfor ea, eb in inedges:\ngenes = pd.Series(self.graph[ea][eb]).drop(index=['Vsum', 'Jsum', 'weight'])\nv = v | set(genes[genes.index.str.contains('V')].index)\nj = j | set(genes[genes.index.str.contains('J')].index)\nnv_genes.append(len(v))\nnj_genes.append(len(j))\nnj_genes = np.array(nj_genes)\nnv_genes = np.array(nv_genes)\nj_df = pd.DataFrame(\n{'genes': list(nv_genes) + list(nj_genes), 'type': ['V'] * len(nv_genes) + ['J'] * len(nj_genes),\n'sp': lempel_ziv_decomposition(cdr3) + lempel_ziv_decomposition(cdr3)})\nreturn j_df\n</code></pre>"},{"location":"ndplgraph_reference/#LZGraphs.NucleotideDoublePositional.NDPLZGraph.path_gene_table","title":"<code>path_gene_table(cdr3_sample, threshold=None)</code>","text":"<p>the function will return two tables of all possible v and j genes     that colud be used to generate the sequence given by \"cdr3_sample\" :param cdr3_sample: a cdr3 sequence :param threshold: drop genes that are missing from threshold % of the sequence :return:</p> Source code in <code>LZGraphs\\NucleotideDoublePositional.py</code> <pre><code>def path_gene_table(self,cdr3_sample,threshold=None):\n\"\"\"\n    the function will return two tables of all possible v and j genes\n        that colud be used to generate the sequence given by \"cdr3_sample\"\n    :param cdr3_sample: a cdr3 sequence\n    :param threshold: drop genes that are missing from threshold % of the sequence\n    :return:\n    \"\"\"\nlength = len(self.encode_sequence(cdr3_sample))\nif threshold is None:\nthreshold = length * (1 / 4)\ngene_table = self.walk_genes(self.encode_sequence(cdr3_sample), dropna=False)\ngene_table = gene_table[gene_table.isna().sum(axis=1) &lt; threshold]\nvgene_table = gene_table[gene_table.index.str.contains('V')]\ngene_table = self.walk_genes(self.encode_sequence(cdr3_sample), dropna=False)\ngene_table = gene_table[gene_table.isna().sum(axis=1) &lt; (length * (1 / 2))]\njgene_table = gene_table[gene_table.index.str.contains('J')]\njgene_table = jgene_table.loc[jgene_table.isna().sum(axis=1).sort_values(ascending=True).index, :]\nvgene_table = vgene_table.loc[vgene_table.isna().sum(axis=1).sort_values(ascending=True).index, :]\nreturn vgene_table,jgene_table\n</code></pre>"},{"location":"ndplgraph_reference/#LZGraphs.NucleotideDoublePositional.NDPLZGraph.sequence_variation_curve","title":"<code>sequence_variation_curve(cdr3_sample)</code>","text":"<p>given a sequence this function will return 2 list, the first is the lz-subpattern path through the graph and the second list is the number of possible choices that can be made at each sub-pattern :param cdr3_sample: :return:</p> Source code in <code>LZGraphs\\NucleotideDoublePositional.py</code> <pre><code>def sequence_variation_curve(self,cdr3_sample):\n\"\"\"\n    given a sequence this function will return 2 list,\n    the first is the lz-subpattern path through the graph and the second list is the number\n    of possible choices that can be made at each sub-pattern\n    :param cdr3_sample:\n    :return:\n    \"\"\"\nencoded = self.self.encode_sequence(cdr3_sample)\ncurve = [self.graph.out_degree(i) for i in encoded]\nreturn encoded,curve\n</code></pre>"},{"location":"ndplgraph_reference/#LZGraphs.NucleotideDoublePositional.NDPLZGraph.unsupervised_random_walk","title":"<code>unsupervised_random_walk()</code>","text":"<p>a random initial state and a random terminal state are selected and a random unsupervised walk is carried out until the randomly selected terminal state is reached.</p> <pre><code>      Parameters:\n              None\n\n      Returns:\n              (list,str) : a list of LZ sub-patterns representing the random walk and a string\n              matching the walk only translated back into a sequence.\n</code></pre> Source code in <code>LZGraphs\\NucleotideDoublePositional.py</code> <pre><code>def unsupervised_random_walk(self):\n\"\"\"\n                 a random initial state and a random terminal state are selected and a random unsupervised walk is\n                carried out until the randomly selected terminal state is reached.\n                          Parameters:\n                                  None\n                          Returns:\n                                  (list,str) : a list of LZ sub-patterns representing the random walk and a string\n                                  matching the walk only translated back into a sequence.\n           \"\"\"\nrandom_initial_state = self._random_initial_state()\ncurrent_state = random_initial_state\nwalk = [random_initial_state]\nsequence = self.clean_node(random_initial_state)\nwhile current_state not in self.terminal_states:\n# take a random step\ncurrent_state = self.random_step(current_state)\nwalk.append(current_state)\nsequence += self.clean_node(current_state)\nreturn walk, sequence\n</code></pre>"},{"location":"ndplgraph_reference/#LZGraphs.NucleotideDoublePositional.NDPLZGraph.walk_genes","title":"<code>walk_genes(walk, dropna=True)</code>","text":"<p>give a walk on the graph (a list of nodes) the function will return a table     representing the possible genes and their probabilities at each edge of the walk. :param walk: :param dropna: :return:</p> Source code in <code>LZGraphs\\NucleotideDoublePositional.py</code> <pre><code>def walk_genes(self, walk,dropna=True):\n\"\"\"\n    give a walk on the graph (a list of nodes) the function will return a table\n        representing the possible genes and their probabilities at each edge of the walk.\n    :param walk:\n    :param dropna:\n    :return:\n    \"\"\"\ntrans_genes = []\ncolumns = []\nfor i in range(0, len(walk) - 1):\nls = self.graph.get_edge_data(walk[i], walk[i + 1]).copy()\ncolumns.append(walk[i] + '-&gt;' + walk[i + 1])\nls.pop('weight')\nls.pop('Vsum')\nls.pop('Jsum')\ntrans_genes.append(pd.Series(ls))\ncc = pd.concat(trans_genes, axis=1)\nif dropna:\ncc = cc.dropna()\nif cc.shape[0] == 0:\nraise Exception('No Constant Gene Flow F')\ncc.columns = columns\ncc['type'] = ['v' if 'v' in x.lower() else 'j' for x in cc.index]\ncc['sum'] = cc.sum(axis=1, numeric_only=True)\ncc = cc.sort_values(by='sum', ascending=False)\nreturn cc\n</code></pre>"},{"location":"ndplgraph_reference/#LZGraphs.NucleotideDoublePositional.NDPLZGraph.walk_probability","title":"<code>walk_probability(walk, verbose=True)</code>","text":"<p>given a walk (a sequence converted into LZ sub-pattern) return the probability of generation (PGEN) of the walk.</p> <p>you can use \"lempel_ziv_decomposition\" from this libraries decomposition module in order to convert a sequence into LZ sub-patterns</p> <pre><code>     Parameters:\n             walk (list): a list of LZ - sub-patterns\n\n     Returns:\n             float : the probability of generating such a walk (PGEN)\n</code></pre> Source code in <code>LZGraphs\\NucleotideDoublePositional.py</code> <pre><code>def walk_probability(self, walk, verbose=True):\n\"\"\"\n         given a walk (a sequence converted into LZ sub-pattern) return the probability of generation (PGEN)\n         of the walk.\n         you can use \"lempel_ziv_decomposition\" from this libraries decomposition module in order to convert a\n         sequence into LZ sub-patterns\n                  Parameters:\n                          walk (list): a list of LZ - sub-patterns\n                  Returns:\n                          float : the probability of generating such a walk (PGEN)\n           \"\"\"\nif type(walk) == str:\nLZ, POS = derive_lz_reading_frame_position(walk)\nwalk_ = [i + str(j) for i, j in zip(LZ, POS)]\nelse:\nwalk_ = walk\nproba = self.subpattern_individual_probability['proba'][walk_[0]]\nfor step1, step2 in window(walk_, 2):\nif self.graph.has_edge(step1, step2):\nproba *= self.graph.get_edge_data(step1, step2)['weight']\nelse:\nif verbose:\nprint('No Edge Connecting| ', step1, '--&gt;', step2)\nreturn 0\nreturn proba\n</code></pre>"},{"location":"ndplgraph_reference/#LZGraphs.NucleotideDoublePositional.derive_lz_reading_frame_position","title":"<code>derive_lz_reading_frame_position(cdr3)</code>","text":"<p>given a string this function will return the LZ sub-patterns, the reading frame position of each sub-pattern and the start position in the sequence of each sub-patterns in the form of 3 lists.</p> <pre><code>     Parameters:\n             cdr3 (str): a string from which to derive sub-patterns\n\n     Returns:\n             (list,list,list) : (lz_subpatterns,reading_frame_position,position_in_sequence)\n</code></pre> Source code in <code>LZGraphs\\NucleotideDoublePositional.py</code> <pre><code>def derive_lz_reading_frame_position(cdr3):\n\"\"\"\n         given a string this function will return the LZ sub-patterns, the reading frame position of each sub-pattern\n         and the start position in the sequence of each sub-patterns in the form of 3 lists.\n                  Parameters:\n                          cdr3 (str): a string from which to derive sub-patterns\n                  Returns:\n                          (list,list,list) : (lz_subpatterns,reading_frame_position,position_in_sequence)\n   \"\"\"\nlzc = lempel_ziv_decomposition(cdr3)\ncumlen = []\nagg=0\nrf = []\nfor sp in lzc:\nagg += len(sp)\ncumlen.append(agg)\nrf.append((agg - len(sp)) % 3)\nreturn lzc, rf, cumlen\n</code></pre>"},{"location":"nodedgesaturation_reference/","title":"Node Edge Saturation Functions","text":"<p>The class supplies methods used to emulate the creation process of an LZGraph without actually running the full creation procedure, rather just accumulate a counter for the number of nodes and edges based on the provided number of sequences.</p> <p>Parameters:</p> Name Type Description Default <code>node_function</code> <code>str</code> <p>the selected node extraction method to use 'naive' - emulate Naive LZGraph extraction / 'ndp'- emulate Nucleotide Double Positional LZGraph / 'aap' - Amino Acid Positional LZGraph.</p> <code>'naive'</code> <p>Attributes:</p> Name Type Description <code>log_memory</code> <code>dict</code> <p>a dictionary containing the results of a single test run</p> Source code in <code>LZGraphs\\NodeEdgeSaturationProbe.py</code> <pre><code>class NodeEdgeSaturationProbe:\n\"\"\"\n      The class supplies methods used to emulate the creation process of an LZGraph without actually running the full\n      creation procedure, rather just accumulate a counter for the number of nodes and edges based on the provided\n      number of sequences.\n      Args:\n          node_function (str): the selected node extraction method to use 'naive' - emulate Naive LZGraph extraction\n           / 'ndp'- emulate Nucleotide Double Positional LZGraph / 'aap' - Amino Acid Positional LZGraph.\n      Attributes:\n          log_memory (dict): a dictionary containing the results of a single test run\n      \"\"\"\ndef __init__(self, node_function='naive', log_level=1, verbose=False):\nself.nodes = set()\nself.edges = set()\nself.log_memory = dict()\nself.verbose = verbose\nself.log_level = log_level\nself.node_function = None\nif node_function == 'naive':\nself.node_function = self.naive_node_extractor\nelif node_function == 'ndp':\nself.node_function = self.ndp_node_extractor\nelif node_function == 'aap':\nself.node_function = self.aap_node_extractor\ndef log(self, args):\nif self.log_level == 1:\nself.log_memory[args] = {'nodes': len(self.nodes), 'edges': len(self.edges)}\n@staticmethod\ndef naive_node_extractor(seq):\n\"\"\" This function implements the node extraction procedure used by the Naive LZGraph.\n                             Args:\n                                 seq (str): An sequence of nucleotides or amino acids\n                             Returns:\n                                 list: a list of nodes extract from the given sequence\n           \"\"\"\nreturn lempel_ziv_decomposition(seq)\n@staticmethod\ndef ndp_node_extractor(seq):\n\"\"\" This function implements the node extraction procedure used by the Nucleotide Double Positional LZGraph.\n                                 Args:\n                                     seq (str): An sequence of nucleotides or amino acids\n                                 Returns:\n                                     list: a list of nodes extract from the given sequence\n               \"\"\"\nLZ, POS, locations = derive_lz_reading_frame_position(seq)\nnodes_local = list(map(lambda x, y, z: x + str(y) + '_' + str(z), LZ, POS, locations))\nreturn nodes_local\n@staticmethod\ndef aap_node_extractor(seq):\n\"\"\" This function implements the node extraction procedure used by the Amino Acid Positional LZGraph.\n                                   Args:\n                                       seq (str): An sequence of nucleotides or amino acids\n                                   Returns:\n                                       list: a list of nodes extract from the given sequence\n                 \"\"\"\nLZ, locations = derive_lz_and_position(seq)\nnodes_local = list(map(lambda x, y: x + '_' + str(y), LZ, locations))\nreturn nodes_local\ndef test_sequences(self, sequence_list, log_every=1000, iteration_number=None):\n\"\"\" Given a list of sequences this function will gradually aggregate the nodes that make up the respective\n        LZGraph and log the node and edge counts every K sequences.\n        The result will be saved in the log_memory attribute of the class.\n                Args:\n                    sequence_list (str): A list of nucleotide  or amino acid sequences\n                    log_every (int): after how many sequences to log the number of nodes and edges\n                Returns:\n                    None:\n        \"\"\"\nslen = len(sequence_list)\nitr = None\nif self.verbose:\nitr = tqdm(enumerate(sequence_list, start=1), leave=False, position=0, total=slen)\nelse:\nitr = enumerate(sequence_list, start=1)\nfor ax, seq in itr:\nnodes_local = self.node_function(seq)\nself.nodes.update(nodes_local)\nself.edges.update((window(nodes_local, 2)))\nif ax % log_every == 0 or ax &gt;= slen:\nself.log(ax)\ndef _reset(self):\nself.nodes = set()\nself.edges = set()\nself.log_memory = dict()\ndef resampling_test(self, sequence_list, n_tests, log_every=1000, sample_size=0):\n\"\"\" Given a list of sequences this function will gradually aggregate the nodes that make up the respective\n        LZGraph and log the node and edge counts every K sequences.\n        The above procedure will be carried out N times each time starting from X randomly sampled sequences from\n        the given sequence list.\n                Args:\n                    sequence_list (str): A list of nucleotide  or amino acid sequences\n                    log_every (int): after how many sequences to log the number of nodes and edges\n                    n_tests (int): the number of realizations to perform\n                    sample_size (int): the number of sequences that will be randomly sampled from sequence_list\n                    at each realization\n                Returns:\n                    list: a list of logs for each realization given by the parameter n_tests\n        \"\"\"\nresult = []\nif sample_size == 0:\nfor n in range(n_tests):\nnp.random.shuffle(sequence_list)\nself.test_sequences(sequence_list, log_every, n)\n# save logs\n# reset aux\nresult.append(self.log_memory.copy())\nself._reset()\nelse:\nfor n in range(n_tests):\nnp.random.shuffle(sequence_list)\nself.test_sequences(random.sample(sequence_list, sample_size), log_every, n)\n# save logs\n# reset aux\nresult.append(self.log_memory.copy())\nself._reset()\nreturn result\n</code></pre>"},{"location":"nodedgesaturation_reference/#LZGraphs.NodeEdgeSaturationProbe.NodeEdgeSaturationProbe.aap_node_extractor","title":"<code>aap_node_extractor(seq)</code>  <code>staticmethod</code>","text":"<p>This function implements the node extraction procedure used by the Amino Acid Positional LZGraph.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> <code>str</code> <p>An sequence of nucleotides or amino acids</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>a list of nodes extract from the given sequence</p> Source code in <code>LZGraphs\\NodeEdgeSaturationProbe.py</code> <pre><code>@staticmethod\ndef aap_node_extractor(seq):\n\"\"\" This function implements the node extraction procedure used by the Amino Acid Positional LZGraph.\n                               Args:\n                                   seq (str): An sequence of nucleotides or amino acids\n                               Returns:\n                                   list: a list of nodes extract from the given sequence\n             \"\"\"\nLZ, locations = derive_lz_and_position(seq)\nnodes_local = list(map(lambda x, y: x + '_' + str(y), LZ, locations))\nreturn nodes_local\n</code></pre>"},{"location":"nodedgesaturation_reference/#LZGraphs.NodeEdgeSaturationProbe.NodeEdgeSaturationProbe.naive_node_extractor","title":"<code>naive_node_extractor(seq)</code>  <code>staticmethod</code>","text":"<p>This function implements the node extraction procedure used by the Naive LZGraph.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> <code>str</code> <p>An sequence of nucleotides or amino acids</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>a list of nodes extract from the given sequence</p> Source code in <code>LZGraphs\\NodeEdgeSaturationProbe.py</code> <pre><code>@staticmethod\ndef naive_node_extractor(seq):\n\"\"\" This function implements the node extraction procedure used by the Naive LZGraph.\n                         Args:\n                             seq (str): An sequence of nucleotides or amino acids\n                         Returns:\n                             list: a list of nodes extract from the given sequence\n       \"\"\"\nreturn lempel_ziv_decomposition(seq)\n</code></pre>"},{"location":"nodedgesaturation_reference/#LZGraphs.NodeEdgeSaturationProbe.NodeEdgeSaturationProbe.ndp_node_extractor","title":"<code>ndp_node_extractor(seq)</code>  <code>staticmethod</code>","text":"<p>This function implements the node extraction procedure used by the Nucleotide Double Positional LZGraph.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> <code>str</code> <p>An sequence of nucleotides or amino acids</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>a list of nodes extract from the given sequence</p> Source code in <code>LZGraphs\\NodeEdgeSaturationProbe.py</code> <pre><code>@staticmethod\ndef ndp_node_extractor(seq):\n\"\"\" This function implements the node extraction procedure used by the Nucleotide Double Positional LZGraph.\n                             Args:\n                                 seq (str): An sequence of nucleotides or amino acids\n                             Returns:\n                                 list: a list of nodes extract from the given sequence\n           \"\"\"\nLZ, POS, locations = derive_lz_reading_frame_position(seq)\nnodes_local = list(map(lambda x, y, z: x + str(y) + '_' + str(z), LZ, POS, locations))\nreturn nodes_local\n</code></pre>"},{"location":"nodedgesaturation_reference/#LZGraphs.NodeEdgeSaturationProbe.NodeEdgeSaturationProbe.resampling_test","title":"<code>resampling_test(sequence_list, n_tests, log_every=1000, sample_size=0)</code>","text":"<p>Given a list of sequences this function will gradually aggregate the nodes that make up the respective LZGraph and log the node and edge counts every K sequences. The above procedure will be carried out N times each time starting from X randomly sampled sequences from the given sequence list.</p> <pre><code>    Args:\n        sequence_list (str): A list of nucleotide  or amino acid sequences\n        log_every (int): after how many sequences to log the number of nodes and edges\n        n_tests (int): the number of realizations to perform\n        sample_size (int): the number of sequences that will be randomly sampled from sequence_list\n        at each realization\n    Returns:\n        list: a list of logs for each realization given by the parameter n_tests\n</code></pre> Source code in <code>LZGraphs\\NodeEdgeSaturationProbe.py</code> <pre><code>def resampling_test(self, sequence_list, n_tests, log_every=1000, sample_size=0):\n\"\"\" Given a list of sequences this function will gradually aggregate the nodes that make up the respective\n    LZGraph and log the node and edge counts every K sequences.\n    The above procedure will be carried out N times each time starting from X randomly sampled sequences from\n    the given sequence list.\n            Args:\n                sequence_list (str): A list of nucleotide  or amino acid sequences\n                log_every (int): after how many sequences to log the number of nodes and edges\n                n_tests (int): the number of realizations to perform\n                sample_size (int): the number of sequences that will be randomly sampled from sequence_list\n                at each realization\n            Returns:\n                list: a list of logs for each realization given by the parameter n_tests\n    \"\"\"\nresult = []\nif sample_size == 0:\nfor n in range(n_tests):\nnp.random.shuffle(sequence_list)\nself.test_sequences(sequence_list, log_every, n)\n# save logs\n# reset aux\nresult.append(self.log_memory.copy())\nself._reset()\nelse:\nfor n in range(n_tests):\nnp.random.shuffle(sequence_list)\nself.test_sequences(random.sample(sequence_list, sample_size), log_every, n)\n# save logs\n# reset aux\nresult.append(self.log_memory.copy())\nself._reset()\nreturn result\n</code></pre>"},{"location":"nodedgesaturation_reference/#LZGraphs.NodeEdgeSaturationProbe.NodeEdgeSaturationProbe.test_sequences","title":"<code>test_sequences(sequence_list, log_every=1000, iteration_number=None)</code>","text":"<p>Given a list of sequences this function will gradually aggregate the nodes that make up the respective LZGraph and log the node and edge counts every K sequences.</p> <p>The result will be saved in the log_memory attribute of the class.</p> <pre><code>    Args:\n        sequence_list (str): A list of nucleotide  or amino acid sequences\n        log_every (int): after how many sequences to log the number of nodes and edges\n    Returns:\n        None:\n</code></pre> Source code in <code>LZGraphs\\NodeEdgeSaturationProbe.py</code> <pre><code>def test_sequences(self, sequence_list, log_every=1000, iteration_number=None):\n\"\"\" Given a list of sequences this function will gradually aggregate the nodes that make up the respective\n    LZGraph and log the node and edge counts every K sequences.\n    The result will be saved in the log_memory attribute of the class.\n            Args:\n                sequence_list (str): A list of nucleotide  or amino acid sequences\n                log_every (int): after how many sequences to log the number of nodes and edges\n            Returns:\n                None:\n    \"\"\"\nslen = len(sequence_list)\nitr = None\nif self.verbose:\nitr = tqdm(enumerate(sequence_list, start=1), leave=False, position=0, total=slen)\nelse:\nitr = enumerate(sequence_list, start=1)\nfor ax, seq in itr:\nnodes_local = self.node_function(seq)\nself.nodes.update(nodes_local)\nself.edges.update((window(nodes_local, 2)))\nif ax % log_every == 0 or ax &gt;= slen:\nself.log(ax)\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>This page aims to provide you with all the details and examples of how you can leverage LZGraphs in your work.</p>"},{"location":"tutorials/#creating-an-lzgraph","title":"Creating An LZGraph","text":"<p>The Amino Acid Positional and the Nucleotide Double Positional graphs share the same construction routine while the Naive graph slightly differ</p>"},{"location":"tutorials/#constructing-amino-acid-positional-and-the-nucleotide-double-positional-graphs","title":"Constructing Amino Acid Positional and the Nucleotide Double Positional Graphs","text":"<p>The bellow example presents the construction of the Amino Acid Positional graph but the same applies for Nucleotide Double Positional Graphs. Note:</p> <ul> <li>For Nucleotide Double Positional Graphs the column corresponding to the sequence should be named \"cdr3_rearrangement\"</li> <li>For Amino Acid Positional Graphs the column corresponding to the sequence should be named \"cdr3_amino_acid\"</li> <li>In both cases V/J genes/alleles should be under the a column \"V\" for V related genes/alleles and \"J\" for    for V related genes/alleles <pre><code>from LZGraphs.AminoAcidPositional import AAPLZGraph\n# from LZGraphs.NucleotideDoublePositional import NDPLZGraph \nimport pandas as pd\ndata = pd.read_csv(\"/path/to/data/file.csv\")\nlzgraph = AAPLZGraph(data,verbose=True)\n</code></pre> Verbose: <pre><code>Gene Information Loaded.. |  0.01  Seconds\nGraph Constructed.. |  0.94  Seconds\nGraph Metadata Derived.. |  0.94  Seconds\nIndividual Subpattern Empirical Probability Derived.. |  0.98  Seconds\nGraph Edge Weight Normalized.. |  1.0  Seconds\nGraph Edge Gene Weights Normalized.. |  1.13  Seconds\nTerminal State Map Derived.. |  1.2  Seconds\nIndividual Subpattern Empirical Probability Derived.. |  1.37  Seconds\nTerminal State Map Derived.. |  1.37  Seconds\nLZGraph Created Successfully.. |  1.37  Seconds\n==============================\n</code></pre></li> </ul> <p>The data file is a pandas DataFrame including the sequences under a column named \"cdr3_amino_acid\" and optionaly a \"V\" and \"J\" column with the relevant genomic information such as Gene / Family / Allele any one of these can be used to create a graph with functionality constrained by the genetic information on the edges.</p> <p>Example of the input DataFrame:</p> cdr3_amino_acid V J CASSLEPSGGTDTQYF TRBV16-1*01 TRBJ1-2*01 CASSDTSGGTDTQYF TRBV1-1*01 TRBJ1-5*01 CASSLEPQTFTDTFFF TRBV16-1*01 TRBJ2-7*01"},{"location":"tutorials/#constructing-a-naive-lzgraph","title":"Constructing a Naive LZGraph","text":"<p>Bellow is an example of a Naive LZGraph construction. <pre><code>from LZGraphs.Naive import NaiveLZGraph,generate_dictionary\nlist_of_sequences = [ 'TGTGCCAGCAGGGCGGGATACGCAGTATTT',\n'TGTGCCAGCAGCCAGCATCGTCGCAGTATTTT'\n'TGTGCCAGCAGCCAGCAGGGCCGGGATACGCAGTATTTT'\n...]\ndictionary = generate_dictionary(6)\nlzgraph = NaiveLZGraph(list_of_sequences, dictionary, verbose=True)\n</code></pre> Note:</p> <ul> <li>The generate_dictionary function takes an integer-(X) and generates all possible patterns   that could be constructed from (X) nucleotides. you can</li> <li>For CDR3 sequences we suggest X=6 as the maximum sub-pattern length observed by us    in the CDR3 region was 6.</li> <li>The dictionary can be replaced with any number of sub-patterns in case not all combinations   are desired.</li> <li>The Naive LZGraph is most relevant in the context of nucleotides as amino acid CDR3   sequences result in sparse graphs.</li> </ul>"},{"location":"tutorials/#exploring-graph-attributes","title":"Exploring Graph Attributes","text":"<p>After constructing an LZGraph there are several attributes that are available  to you for quick inference of repertoire statistical properties as well as the  graph object itself built above the netowrkx DiGraph class.  Below are examples of how you can evaluate and explore those attributes.  ()</p>"},{"location":"tutorials/#amino-acid-positional-and-the-nucleotide-double-positional-graphs","title":"Amino Acid Positional and the Nucleotide Double Positional Graphs","text":""},{"location":"tutorials/#exploring-graph-nodes-and-edges","title":"Exploring Graph Nodes and Edges","text":"<p><pre><code># Retrieving the list of all graph nodes / edges\nnode_list = list(lzgraph.nodes)\nedge_list = list(lzgraph.edges) \nprint('First 10 Nodes: ',list(lzgraph.nodes)[:10])\nprint('First 10 Edges: ',list(lzgraph.edges)[:10])\n</code></pre> Output: <pre><code>First 10 Nodes:  ['C_1', 'A_2', 'S_3', 'SQ_5', 'Q_6', 'G_7', 'R_8', 'D_9', 'T_10', 'QY_12']\nFirst 10 Edges:  [('C_1', 'A_2'), ('C_1', 'T_2'), ('C_1', 'V_2'), ('C_1', 'S_2'), ('C_1', 'R_2'), ('C_1', 'G_2'), ('C_1', 'D_2'), ('C_1', 'F_2'), ('C_1', 'I_2'), ('A_2', 'S_3')]\n</code></pre></p>"},{"location":"tutorials/#distribution-of-observed-sequence-lengths","title":"Distribution of Observed Sequence Lengths:","text":"<p>After fitting an LZGraph to a repertoire you can quickly access the distribution of different sequence lengths observed in the repertoire: <pre><code>print(lzgraph.lengths)\n</code></pre> Output: <pre><code>{13: 2973, 15: 5075, 14: 4412, 16: 2862,\n12: 1147, 17: 1401, 19: 268, 22: 11, 20: 108,\n11: 508, 18: 655, 21: 38, 10: 72,\n24: 1, 9: 14, 7: 2, 4: 1,8: 1}\n</code></pre> Note: The key of the dictionary is an observed sequence length, the value corresponds to the total number of sequences observed matching the key length.</p>"},{"location":"tutorials/#exploring-graph-initial-and-terminal-states","title":"Exploring Graph Initial and Terminal States:","text":"<p>Initial state is defined as the first sub-pattern observed in a sequence,  Terminal state is the last sub-pattern observed in a sequence, the lists and counts  of all observed initial and final states are saved in every LZGraph and can be   accessed:</p>"},{"location":"tutorials/#getting-all-the-initial-states","title":"Getting all the initial states","text":"<p><pre><code># Getting all the initial states\ninit_states = lzgraph.initial_states\nprint(init_states)\n</code></pre> Output: <pre><code>C_1    19523\nR_1       20\ndtype: int64\n</code></pre></p>"},{"location":"tutorials/#getting-all-the-terminal-states","title":"Getting all the terminal states","text":"<p><pre><code>term_states = lzgraph.print(lzgraph.terminal_states)\nprint(term_states)\n</code></pre> Output: <pre><code>F_13      2672\nF_15      4490\nF_14      3860\nF_16      2502\nF_12      1028\n... \nG_9          1\nAFF_12       1\nFF_11        1\nF_8          1\nHF_22        1\nLength: 86, dtype: int64\n</code></pre></p>"},{"location":"tutorials/#graph-v-and-j-marginal-distributions","title":"Graph V and J Marginal Distributions:","text":"<p>If V and J annotation were provided while constructing the graph, the genetic data was embedded into each edge of the graph. The marginal probability of each gene/allele can be observed by the following way: <pre><code># print(lzgraph.marginal_vgenes)\nprint(lzgraph.marginal_jgenes)\n</code></pre> Output: <pre><code>TRBJ1-2*01    0.159804\nTRBJ1-1*01    0.143588\nTRBJ2-7*01    0.141951\nTRBJ2-1*01    0.090081\nTRBJ2-3*01    0.088086\nTRBJ1-5*01    0.076986\nTRBJ2-5*01    0.075963\nTRBJ2-2*01    0.057343\nTRBJ1-4*01    0.050437\nTRBJ1-6*01    0.047675\nTRBJ1-3*01    0.043787\nTRBJ2-6*01    0.015500\nTRBJ2-4*01    0.008798\nName: J, dtype: float64\n</code></pre></p>"},{"location":"tutorials/#calculating-the-k1000-diversity-index","title":"Calculating the K1000 Diversity Index","text":"<p>As presented in the paper LZGraphs can offer the user a new diversity index (K1000). The index value for any repertoire can be derived in the following way:</p> <p><pre><code>import numpy as np\nfrom lzgraphs.NodeEdgeSaturationProbe import NodeEdgeSaturationProbe\ndef get_k1000_diversity(list_of_sequences,lzgraph_encoding_function,draws=25):\n# sample 1000 unique sequences\nNESP = NodeEdgeSaturationProbe()\nresult = NESP.resampling_test(list(set(list_of_sequences)),n_tests=draws,sample_size=1000)\nK_tests = [list(i.values())[-1]['nodes'] for i in result]\nreturn np.mean(K_tests)\nlist_of_seqs = data.cdr3_amino_acid.to_list() # this is the repertoire under inspection\nk1000 = get_k1000_diversity(list_of_seqs,AAPLZGraph.encode_sequence) # this can be replace with AAPLZGraph.encode_sequence for amino acids\nprint('K1000 index for the given repertoire: ',k1000)\n</code></pre> Output: <pre><code>K1000 index for the given repertoire:  217.64\n</code></pre></p> <p>Note:</p> <ul> <li>You can adjust the value of <code>draws</code> to be larger than 25, the higher the value is   the more realizations will be generated for the K1000 index thus the returned   mean value will be a better approximation.</li> <li>the encoding function can be replaced with any one of Naive/NDPLZGraph,AAPLZGraph   encoding functions.</li> </ul>"},{"location":"tutorials/#deriving-sequence-generation-probability-pgen","title":"Deriving Sequence Generation Probability (Pgen)","text":"<p>After an LZGraph is derived for a given repertoire, one can assess the generation probability (Pgen) of a new sequence with respect to that repertoire (LZGraph). <pre><code>new_sequence = \"CASRGERGDNEQFF\"\n# encode the sequence into relevant graph format\nencoded_sequence = AAPLZGraph.encode_sequence(new_sequence)\n#output\n# ['C_1', 'A_2', 'S_3', 'R_4', 'G_5', 'E_6', 'RG_8', 'D_9', 'N_10', 'EQ_12', 'F_13', 'F_14']\npgen = lzgraph.walk_probability(encoded_sequence)\nprint(f'{new_sequence} Pgen: {pgen}')\n</code></pre> Output: <pre><code>CASRGERGDNEQFF Pgen: 6.692834748776949e-13\n</code></pre></p>"},{"location":"tutorials/#generating-new-sequences","title":"Generating New Sequences","text":"<p>An LZGraph constructed from a source repertoire can generate new sequences following the statistical properties observed in the source. Note that that if V and J genes were provided the generation function will be testing that the random sequence and their sub-pattern all are associated to initially random V and J genes selected before generating the sequence. <pre><code>generated_walk,selected_v,selected_j = lzgraph.genomic_random_walk()\n# replace genomic_random_walk with random_walk() if annotation was not provided\nprint(generated_walk,selected_v,selected_j)\n</code></pre> Output: <pre><code>['C_1', 'S_2', 'A_3', 'T_4', 'G_5', 'GI_7', 'Q_8', 'Y_9', 'QE_11', 'TQ_13', 'YF_15'],\n'TRBV29-1*01',\n'TRBJ2-5*01'\n</code></pre> You can transform the resulting walk back into a sequence by cleaning each node and concatenating them into a single string. Each LZGraph has a \"clean_node\" method that accompanies the relevant \"encode_sequence\" method. <pre><code>clean_sequence = ''.join([AAPLZGraph.clean_node(node) for node in generated_walk])\n# Note that AAPLZGraph needs to be replaced in case you used the NDPLZGraph\nprint(clean_sequence)\n</code></pre> Output: <pre><code>CASSPGTGGTGELFF\n</code></pre></p>"},{"location":"tutorials/#feature-vector-from-graph-eigen-centrality","title":"Feature Vector From Graph (Eigen Centrality)","text":"<p>One can derive a vector representation of an LZGraph in order to perform any modeling task. The resulting vector in a sense capture the structural dynamics of  a repertoire. Note that the number of features in the resulting vector equal the number of nodes in the graph, and the value in each node correspond to each node, so it is recommended using the Naive LZGraph, this allows to create LZGraphs to different repertoires while maintaining the same dictionary of sub-patterns (nodes).</p> <p><pre><code>from LZGraphs.Naive import NaiveLZGraph,generate_dictionary\n# Create a dictionary that will be shared between all repertoires\ndictionary = generate_dictionary(6)\n# create a graph, this can be done in a loop over many repertoires\nlzgraph = NaiveLZGraph(list_of_sequences, dictionary, verbose=True)\n# derive the feature vector\nfeature_vector = lzgraph.eigenvector_centrality()\nprint(pd.Series(feature_vector))\n</code></pre> Output: <pre><code>A         3.009520e-01\nT         1.183398e-01\nG         1.186366e-01\nC         2.461758e-01\nAA        1.252643e-01\n              ...     \nCCCCGC    5.252576e-10\nCCCCCA    5.252576e-10\nCCCCCT    5.252576e-10\nCCCCCG    5.252576e-10\nCCCCCC    5.252576e-10\nLength: 5460, dtype: float64\n</code></pre></p> <p>Note: The <code>generate_dictionary</code> function given the value 6 return <code>5460</code> sub-patterns, many of which may not exist in your graph, nonetheless this promises that all the repertoires encoded will produce the same feature vector dimension but the value across the different sub-pattern will be different.</p>"},{"location":"tutorials/#plotting-graph-related-features","title":"Plotting Graph Related Features","text":"<p>The library provides multiple plots that can be useful when analyzing sequence and comparing between sequences.</p>"},{"location":"tutorials/#ancestors-descendants-curves-plot","title":"Ancestors Descendants Curves Plot","text":"<p>In this chart you can examine at each sub-pattern of a given sequence the amount descendants nodes reachable at each node contained in your sequence, as well as the amount of ancestors at each node. Sequence with different attribute differ both by the slope and the convergence rate of these curve as well as by the intersection point between the curves. <pre><code>from LZGraphs.Visualize import ancestors_descendants_curves_plot\nsequence = 'CASTPGTASGYTF'\nancestors_descendants_curves_plot(lzgraph,sequence)\n</code></pre> Output: </p>"},{"location":"tutorials/#sequence-possible-paths-plot","title":"Sequence Possible Paths Plot","text":"<p>In this chart we look at a reduced and immediate version of Descendants curve. For each sub-pattern derived from a given sequence and based on an LZGraph, We can examine the number of alternatives there are at each node, this indicates the rarity of a sequence and is correlated with the difference from the  mean Levenshtein distance of the repertoire as shown in the LZGraphs paper. <pre><code>from LZGraphs.Visualize import sequence_possible_paths_plot\nsequence = 'CASTPGTASGYTF'\nsequence_possible_paths_plot(lzgraph,sequence)\n</code></pre> Output: </p>"},{"location":"tutorials/#node-genomic-variability-plot","title":"Node Genomic Variability Plot","text":"<p>In this chart we look at the number of V and J genes/alleles per node in a given sequence with respect to a given repertoire. Not only can one infer the sub-patterns in a sequence that have the exceptional number of V and J alternatives but also when comparing between the same sequence in different repertoires (different LZGraphs) one can infer the amount difference at each sub-pattern between the two repertoires. <pre><code>from LZGraphs.Visualize import sequence_genomic_node_variability_plot\nsequence = 'CASTPGTASGYTF'\nsequence_genomic_node_variability_plot(lzgraph,sequence)\n</code></pre> Output: </p>"},{"location":"tutorials/#edge-genomic-variability-plot","title":"Edge Genomic Variability Plot","text":"<p>In this chart we look at the number of V and J genes/alleles per edge in a given sequence with respect to a given repertoire.</p> <ul> <li>Allele/gene names colored in red signify that the allele/gene appeared in all the edges in the given sequence.</li> <li>Black cells signify that this spesific allele/gene wasnt observed at that edge.</li> <li>The color gradient at each cell represents the probability of choosing that edge under the constraint of having  that specific V/J. <pre><code>from LZGraphs.Visualize import sequence_genomic_edges_variability_plot\nsequence = 'CASTPGTASGYTF'\nsequence_genomic_edges_variability_plot(lzgraph,sequence)\n</code></pre> Output: </li> </ul>"},{"location":"tutorials/#bow-vectorizer","title":"BOW Vectorizer","text":"<p>The library also provides a convenient class implementing the BOW logic presented in the paper. Note that each instance of the BOW wrapper class has to fitted on a list of sequences (repertoire) before it can transform new lists of sequences into BOW vectors.</p> <pre><code>from LZGraphs.BOWEncoder import LZBOW\nfrom LZGraphs.NucleotideDoublePositional import NDPLZGraph\nsequence_list = data.cdr3_rearrangement.to_list()\n# create vectorizer and choose the Nucleotide Double Positional (ndp) encdoing function (default is Naive)\nvectorizer = LZBOW(encoding_function=NDPLZGraph.encode_sequence)\n# fit on sequence list\nvectorizer.fit(sequence_list)\n# BOW dictionary\nvectorizer.dictionary\nbow_vector = vectorizer.transform(new_list_of_sequences)\n</code></pre>"},{"location":"utilities_reference/","title":"Utilities Functions","text":""},{"location":"utilities_reference/#LZGraphs.Utilities.graph_union","title":"<code>graph_union(graphA, graphB)</code>","text":"<p>This function performs a union operation between two graphs, graphA will be updated to be the equivalent of the union of both. The result is logically equal to constructing a graph out of the union sequences, of two separate repertoires.</p> <pre><code>         Args:\n             graphA (LZGraph): An LZGraph\n             graphB (LZGraph)  An LZGraph of the same class as graphA\n         Returns:\n             LZGraph: The resulting LZGraph from the union of graphA and graphB\n</code></pre> Source code in <code>LZGraphs\\Utilities.py</code> <pre><code>def graph_union(graphA,graphB):\n\"\"\" This function performs a union operation between two graphs, graphA will be updated to be the\n    equivalent of the union of both.\n    The result is logically equal to constructing a graph out of the union sequences, of two separate repertoires.\n                 Args:\n                     graphA (LZGraph): An LZGraph\n                     graphB (LZGraph)  An LZGraph of the same class as graphA\n                 Returns:\n                     LZGraph: The resulting LZGraph from the union of graphA and graphB\n           \"\"\"\nif type(graphA) != type(graphB):\nraise Exception('Both Graphs Must Be of Same Type!')\nif type(graphA) == NaiveLZGraph:\npass\nelse:\n#graphA.genetic_walks_black_list.merge(graphB.genetic_walks_black_list if type(graphB.genetic_walks_black_list) is not None else {})\ngraphA.n_subpatterns += graphB.n_subpatterns\ngraphA.initial_states = graphA.initial_states.combine(graphB.initial_states, lambda x, y: x + y, fill_value=0)\n# not necceseray\n# lengths\n# observed_vgenes\n# observed_jgenes\n# dictionary\n# n_transitions\n# edges_list\ngraphA.marginal_vgenes = (graphA.marginal_vgenes.combine(graphB.marginal_vgenes, lambda x, y: x + y,\nfill_value=0)) / 2\ngraphA.vj_probabilities = (graphA.vj_probabilities.combine(graphB.vj_probabilities, lambda x, y: x + y,\nfill_value=0)) / 2\ngraphA.length_distribution = (\ngraphA.length_distribution.combine(graphB.length_distribution, lambda x, y: x + y, fill_value=0))\ngraphA.terminal_states = (graphA.terminal_states.combine(graphB.terminal_states, lambda x, y: x + y, fill_value=0))\ngraphA.length_distribution_proba = (graphA.length_distribution_proba.combine(graphB.length_distribution_proba,\nlambda x, y: x + y,\nfill_value=0)) / 2\ngraphA.subpattern_individual_probability = (graphA.subpattern_individual_probability.combine(\ngraphB.subpattern_individual_probability, lambda x, y: x + y, fill_value=0)) / 2\n# recalculate\n#terminal_state_map\n#terminal_state_data\nunion_graph = nx.digraph.DiGraph()\nunion_graph.add_nodes_from(set(graphA.nodes) | set(graphB.nodes))\nfor node in tqdm(set(graphA.nodes) | set(graphB.nodes)):\nif (node in graphA.per_node_observed_frequency) and (node in graphB.per_node_observed_frequency):\nh1 = pd.DataFrame(dict(graphA.graph[node]))\nh2 = pd.DataFrame(dict(graphB.graph[node]))\nif len(h1) == 0 and len(h2) == 0:\ncontinue\n# renormalize weight\nh1_node_sum = graphA.per_node_observed_frequency[node]\nh2_node_sum = graphB.per_node_observed_frequency[node]\nif 'weight' in h1.index:\nh1.loc['weight', :] *= h1_node_sum\nh1 = h1.apply(restore_gene_counts)\nif 'weight' in h2.index:\nh2.loc['weight', :] *= h2_node_sum\nh2 = h2.apply(restore_gene_counts)\nfactor = (h1_node_sum + h2_node_sum)\nc = h1.combine(h2, lambda x, y: x + y, fill_value=0).replace(0, np.nan)\nc.loc['weight', :] /= factor\n# gene renormalization\nc = c.apply(renormalize_edege_genes)\nc = c.round(10)\n# save new counts\ngraphA.per_node_observed_frequency[node] = factor\n# update new graph\nfor column in c.columns:\nunion_graph.add_edge(node, column)\nfor key in c.index:\nunion_graph[node][column][key] = c[column][key]\nelif node in graphA.per_node_observed_frequency and node not in graphB.per_node_observed_frequency:\nc = pd.DataFrame(dict(graphA.graph[node]))\n# save new counts\nfor column in c.columns:\nunion_graph.add_edge(node, column)\nfor key in c.index:\nunion_graph[node][column][key] = c[column][key]\ncontinue\nelif node in graphB.per_node_observed_frequency:\nc = pd.DataFrame(dict(graphB.graph[node]))\n# save new counts\ngraphA.per_node_observed_frequency[node] = graphB.per_node_observed_frequency[node]\n# update new graph\nfor column in c.columns:\nunion_graph.add_edge(node, column)\nfor key in c.index:\nunion_graph[node][column][key] = c[column][key]\ngraphA.graph = union_graph\n</code></pre>"},{"location":"utilities_reference/#LZGraphs.Utilities.renormalize_edege_genes","title":"<code>renormalize_edege_genes(column)</code>","text":"<p>This function is used during the graph union operation, it normalizes the gene counts by the total number of observed v / j genes/alleles.                 Args:                     column (pandas Series): An LZGraph                 Returns:                     pandas Series: padnas series of v and j counts instead of probabilites</p> Source code in <code>LZGraphs\\Utilities.py</code> <pre><code>def renormalize_edege_genes(column):\n\"\"\" This function is used during the graph union operation, it normalizes the gene counts by the total number\n    of observed v / j genes/alleles.\n                    Args:\n                        column (pandas Series): An LZGraph\n                    Returns:\n                        pandas Series: padnas series of v and j counts instead of probabilites\n              \"\"\"\nvgs, jgs = [], []\n# total number of observed V genes/alleles\nvsum = column['Vsum']\n# total number of observed J genes/alleles\njsum = column['Jsum']\n# extract v and j columns\nfor col in column.index:\nif 'BV' in col:\nvgs.append(col)\nelif 'BJ' in col:\njgs.append(col)\ncolumn[vgs] /= vsum\ncolumn[jgs] /= jsum\nreturn column\n</code></pre>"},{"location":"utilities_reference/#LZGraphs.Utilities.restore_gene_counts","title":"<code>restore_gene_counts(column)</code>","text":"<p>This function is used during the graph union operation, it converts the gene probability distribution at each edge back to a count vector.                 Args:                     column (pandas Series): An LZGraph                 Returns:                     pandas Series: padnas series of v and j counts instead of probabilites</p> Source code in <code>LZGraphs\\Utilities.py</code> <pre><code>def restore_gene_counts(column):\n\"\"\" This function is used during the graph union operation, it converts the gene probability distribution at each\n        edge back to a count vector.\n                        Args:\n                            column (pandas Series): An LZGraph\n                        Returns:\n                            pandas Series: padnas series of v and j counts instead of probabilites\n      \"\"\"\nvgs, jgs = [], []\n# total number of observed V genes/alleles\nvsum = column['Vsum']\n# total number of observed J genes/alleles\njsum = column['Jsum']\n# extract v and j columns\nfor col in column.index:\nif 'BV' in col:\nvgs.append(col)\nelif 'BJ' in col:\njgs.append(col)\ncolumn[vgs] *= vsum\ncolumn[jgs] *= jsum\nreturn column\n</code></pre>"},{"location":"visualize_reference/","title":"Visualize Functions","text":""},{"location":"visualize_reference/#LZGraphs.Visualize.ancestors_descendants_curves_plot","title":"<code>ancestors_descendants_curves_plot(graph, sequence)</code>","text":"<p>Generate a Matplotlib plot that shows the number of ancestor and descendant nodes for each node in a given sequence.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>LZGraph</code> <p>An LZGraph object that was embedded with gene annotations.</p> required <p>Returns:</p> Name Type Description <code>None</code> <p>Shows figure via plt.show()</p> Source code in <code>LZGraphs\\Visualize.py</code> <pre><code>def ancestors_descendants_curves_plot(graph,sequence):\n\"\"\" Generate a Matplotlib plot that shows the number of ancestor and descendant nodes for each node in a given sequence.\n                 Args:\n                     graph (LZGraph): An LZGraph object that was embedded with gene annotations.\n                     sequence (str) A sequence of nucleotides/amino-acids depending on the LZGraph passed.\n                 Returns:\n                     None: Shows figure via plt.show()\n           \"\"\"\ndescendants_curve = []\nancestors_curve = []\nfor node in graph.encode_sequence(sequence):\ndescendants = nx.descendants(graph.graph, node)\ndescendants_curve.append(len(descendants))\nancestors = nx.ancestors(graph.graph, node)\nancestors_curve.append(len(ancestors))\nancestors_curve = np.array(ancestors_curve)\ndescendants_curve = np.array(descendants_curve)\n# out_values =np.array( [(lzg.graph.out_degree(i)) for i in encode_sequence(sequence)])\nplt.title(sequence)\nax = sns.lineplot(x=np.arange(len(descendants_curve)), y=descendants_curve, label='Descendants Curve',\ncolor='tab:orange')\nax.set_ylabel('Number of Descendants')\nax2 = ax.twinx()\nsns.lineplot(x=np.arange(len(descendants_curve)), y=ancestors_curve, label='Ancestors Curve', ax=ax2)\nax2.set_ylabel('Number of Ancestors')\nplt.xticks(np.arange(len(descendants_curve)), labels=lempel_ziv_decomposition(sequence), rotation=45)\nplt.grid(lw=2, ls=':')\nplt.xlabel('LZ Sub-pattern')\nplt.show()\n</code></pre>"},{"location":"visualize_reference/#LZGraphs.Visualize.draw_graph","title":"<code>draw_graph(graph, file_name='LZGraph.png')</code>","text":"<p>Generate a plot of a given graph and save is in project folder.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>LZGraph</code> <p>An LZGraph object that was embedded with gene annotations.</p> required <p>Returns:</p> Name Type Description <code>None</code> <p>Shows figure via plt.show()</p> Source code in <code>LZGraphs\\Visualize.py</code> <pre><code>def draw_graph(graph,file_name='LZGraph.png'):\n\"\"\" Generate a plot of a given graph and save is in project folder.\n                 Args:\n                     graph (LZGraph): An LZGraph object that was embedded with gene annotations.\n                     file_name (str) the name of the saved image.\n                 Returns:\n                     None: Shows figure via plt.show()\n    \"\"\"\n#initialze Figure\nplt.figure(num=None, figsize=(30, 30), dpi=300)\nplt.axis('off')\nfig = plt.figure(1)\npos = nx.spring_layout(graph)\nnx.draw_networkx_nodes(graph,pos,alpha=0.3,node_size=100)\nnx.draw_networkx_edges(graph,pos,alpha=0.3)\n#nx.draw_networkx_labels(graph,pos)\nplt.savefig(file_name,bbox_inches=\"tight\")\npylab.close()\ndel fig\n</code></pre>"},{"location":"visualize_reference/#LZGraphs.Visualize.sequence_genomic_edges_variability_plot","title":"<code>sequence_genomic_edges_variability_plot(graph, cdr3_sample, threshold=None, figsize=None)</code>","text":"<p>Generate a Matplotlib plot that shows the distribution of V and J genes at each edge in a given sequence.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>LZGraph</code> <p>An LZGraph object that was embedded with gene annotations.</p> required <p>Returns:</p> Name Type Description <code>None</code> <p>Shows figure via plt.show()</p> Source code in <code>LZGraphs\\Visualize.py</code> <pre><code>def sequence_genomic_edges_variability_plot(graph, cdr3_sample, threshold=None, figsize=None):\n\"\"\" Generate a Matplotlib plot that shows the distribution of V and J genes at each edge in a given sequence.\n              Args:\n                  graph (LZGraph): An LZGraph object that was embedded with gene annotations.\n                  cdr3_sample (str) A sequence of nucleotides/amino-acids depending on the LZGraph passed.\n                  threshold (float)  Default = None, if a value between 0-1 that controls the percentage of complete paths to show.\n                  figsize (int) the size of the matplotlib figure.\n              Returns:\n                  None: Shows figure via plt.show()\n        \"\"\"\nvgene_table, jgene_table = graph.path_gene_table(cdr3_sample, threshold)\nplt.figure(figsize=(15, 8) if figsize is None else figsize)\nplt.subplot(1, 2, 1)\nax = sns.heatmap(jgene_table.iloc[:, :-2],\nxticklabels=[graph.clean_node(i.split('-&gt;')[0]) + '-&gt;' + graph.clean_node(i.split('-&gt;')[1]) for i in\njgene_table.columns[:-2]],\ncmap='coolwarm', linewidths=3)\nax.set_facecolor('xkcd:black')\nlabel_col_vals = jgene_table.iloc[:, :-2].isna().any(axis=1)\nfor i in ax.get_yticklabels():\nif not label_col_vals[i.get_text()]:\ni.set_color(\"red\")\nplt.subplot(1, 2, 2)\nax = sns.heatmap(vgene_table.iloc[:, :-2],\nxticklabels=[graph.clean_node(i.split('-&gt;')[0]) + '-&gt;' + graph.clean_node(i.split('-&gt;')[1]) for i in\njgene_table.columns[:-2]],\ncmap='coolwarm', linewidths=3, yticklabels=vgene_table.index)\nlabel_col_vals = vgene_table.iloc[:, :-2].isna().any(axis=1)\nfor i in ax.get_yticklabels():\nif not label_col_vals[i.get_text()]:\ni.set_color(\"red\")\nax.set_facecolor('xkcd:black')\nplt.gcf().suptitle(cdr3_sample, fontsize=26)\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"visualize_reference/#LZGraphs.Visualize.sequence_genomic_node_variability_plot","title":"<code>sequence_genomic_node_variability_plot(graph, cdr3)</code>","text":"<p>Generate a Matplotlib plot that shows the number of unique genes/alleles at each node of a given sequence based on a given graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>LZGraph</code> <p>An LZGraph object that was embedded with gene annotations.</p> required <p>Returns:</p> Name Type Description <code>None</code> <p>Shows figure via plt.show()</p> Source code in <code>LZGraphs\\Visualize.py</code> <pre><code>def sequence_genomic_node_variability_plot(graph, cdr3):\n\"\"\" Generate a Matplotlib plot that shows the number of unique genes/alleles at each node of a given sequence based on a given graph.\n                 Args:\n                     graph (LZGraph): An LZGraph object that was embedded with gene annotations.\n                     cdr3 (str) A sequence of nucleotides/amino-acids depending on the LZGraph passed.\n                 Returns:\n                     None: Shows figure via plt.show()\n           \"\"\"\nj_df = graph.gene_variation(cdr3)\nsns.barplot(data=j_df, x='sp', y='genes', hue='type')\nplt.grid(lw=2, ls=':', axis='y')\nplt.xlabel('LZ Sub Patterns')\nplt.ylabel('Unique Gene/Allele Possibilities')\nplt.legend()\nplt.show()\n</code></pre>"},{"location":"visualize_reference/#LZGraphs.Visualize.sequence_possible_paths_plot","title":"<code>sequence_possible_paths_plot(graph, sequence)</code>","text":"<p>Generate a Matplotlib plot that shows the number of alternative paths a sequence can take at each node based on an LZGraph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>LZGraph</code> <p>An LZGraph object that was embedded with gene annotations.</p> required <p>Returns:</p> Name Type Description <code>None</code> <p>Shows figure via plt.show()</p> Source code in <code>LZGraphs\\Visualize.py</code> <pre><code>def sequence_possible_paths_plot(graph,sequence):\n\"\"\" Generate a Matplotlib plot that shows the number of alternative paths a sequence can take at each node based on an LZGraph.\n                 Args:\n                     graph (LZGraph): An LZGraph object that was embedded with gene annotations.\n                     sequence (str) A sequence of nucleotides/amino-acids depending on the LZGraph passed.\n                 Returns:\n                     None: Shows figure via plt.show()\n           \"\"\"\ncurvec = [(graph.graph.out_degree(i)) for i in graph.encode_sequence(sequence)]\nsns.lineplot(x=np.arange(len(curvec)), y=(curvec), color='tab:blue')\nsns.scatterplot(x=np.arange(len(curvec)), y=(curvec), color='tab:blue')\nplt.xticks(np.arange(len(curvec)),\nlabels=[i for i in lempel_ziv_decomposition(sequence)],\nrotation=0)\nplt.grid(lw=2,ls=':')\nplt.ylabel('# of Paths')\nplt.xlabel('LZ Sub Pattern')\nplt.show()\n</code></pre>"}]}