{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to LZGraphs Documentation","text":"<p>Welcome to the comprehensive guide for LZGraphs, a Python library engineered to revolutionize the analysis of the T-cell receptor beta chain (TCRB) repertoires through the innovative use of the Lempel-Ziv 76 algorithm. LZGraphs is your toolkit for uncovering new insights within TCRB CDR3 analysis, crafted for efficiency and scalability across diverse species.</p> <p></p> <p>At its core, LZGraphs stands apart by focusing purely on sequence analysis, sidestepping the conventional pitfalls of alignment and reliance on genotype references. This makes it a uniquely adaptable tool for immunological research, opening up new avenues of exploration in the field.</p> <p>Dive into our suite of tutorials for a hands-on introduction to LZGraphs, highlighting its capabilities and ease of integration into your research workflows: Start Learning.</p> <p>Our documentation is structured to ensure you have all the tools at your disposal to leverage LZGraphs to its fullest potential, from installation guides to deep dives into its core functions.</p>"},{"location":"#quick-installation-guide","title":"Quick Installation Guide","text":"<p>Embark on your LZGraphs journey with a simple installation command:</p> <pre><code>pip install LZGraphs\n</code></pre>"},{"location":"#connect-with-us","title":"Connect with Us","text":"<p>Your insights and experiences with LZGraphs fuel our innovation. For inquiries, suggestions, or to share your LZGraphs journey, reach out to us:</p> <ul> <li>Email: Thomas Konstantinovsky</li> </ul>"},{"location":"aaplzgraph_reference/","title":"AAPLZGraph Class","text":""},{"location":"aaplzgraph_reference/#src.LZGraphs.Graphs.AminoAcidPositional.AAPLZGraph","title":"<code>AAPLZGraph</code>","text":"<p>             Bases: <code>LZGraphBase</code></p> <pre><code>  This class implements the logic and infrastructure of the \"Amino Acid Positional\" version of the LZGraph\n  The nodes of this graph are LZ sub-patterns based on amino acids with added start position\n  in the sequence, formally: {lz_subpattern}_{start position in sequence},\n  This class best fits analysis and inference of amino acid sequences.\n</code></pre> <p>Args:</p> <pre><code>  walk_probability(walk,verbose=True):\n      returns the PGEN of the given walk (list of sub-patterns)\n\n\n  is_dag():\n    the function checks whether the graph is a Directed acyclic graph\n\n  walk_genes(walk,dropna=True):\n    give a walk on the graph (a list of nodes) the function will return a table\n    representing the possible genes and their probabilities at each edge of the walk.\n\n  path_gene_table(cdr3_sample,threshold=None):\n    the function will return two tables of all possible v and j genes\n    that colud be used to generate the sequence given by \"cdr3_sample\"\n\n\n  path_gene_table_plot(threshold=None,figsize=None):\n    the function plots two heatmap, one for V genes and one for J genes,\n    and represents the probability at each edge to select that gene,\n    the color at each cell is equal to the probability of selecting the gene, a black\n    cell means that the graph didn't see that gene used with that sub-pattern.\n\n    the data used to create the charts can be derived by using the \"path_gene_table\" method.\n\n  gene_variation(cdr3):\n    given a sequence, this will derive a charts that shows the number of V and J genes observed\n    per node (LZ- subpattern).\n\n  gene_variation_plot(cdr3):\n    Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count\n    and one for J gene count.\n\n\n  random_walk(steps):\n     given a number of steps (sub-patterns) returns a random walk on the graph between a random inital state\n     to a random terminal state in the given number of steps\n\n  gene_random_walk(seq_len, initial_state):\n    given a target sequence length and an initial state, the function will select a random\n    V and a random J genes from the observed gene frequency in the graph's \"Training data\" and\n    generate a walk on the graph from the initial state to a terminal state while making sure\n    at each step that both the selected V and J genes were seen used by that specific sub-pattern.\n\n  unsupervised_random_walk():\n    a random initial state and a random terminal state are selected and a random unsupervised walk is\n    carried out until the randomly selected terminal state is reached.\n\n  eigenvector_centrality():\n    return the eigen vector centrality value for each node (this function is used as the feature extractor\n    for the LZGraph)\n\n\n  sequence_variation_curve(cdr3_sample):\n    given a cdr3 sequence, the function will calculate the value of the variation curve and return\n    2 arrays, 1 of the sub-patterns and 1 for the number of out neighbours for each sub-pattern\n\n  graph_summary():\n    the function will return a pandas DataFrame containing the graphs\n    Chromatic Number,Number of Isolates,Max In Deg,Max Out Deg,Number of Edges\n</code></pre> <p>Attributes:             nodes:                 returns the nodes of the graph             edges:                 return the edges of the graph</p> Source code in <code>src\\LZGraphs\\Graphs\\AminoAcidPositional.py</code> <pre><code>class AAPLZGraph(LZGraphBase):\n    \"\"\"\n              This class implements the logic and infrastructure of the \"Amino Acid Positional\" version of the LZGraph\n              The nodes of this graph are LZ sub-patterns based on amino acids with added start position\n              in the sequence, formally: {lz_subpattern}_{start position in sequence},\n              This class best fits analysis and inference of amino acid sequences.\n\n        Args:\n\n              walk_probability(walk,verbose=True):\n                  returns the PGEN of the given walk (list of sub-patterns)\n\n\n              is_dag():\n                the function checks whether the graph is a Directed acyclic graph\n\n              walk_genes(walk,dropna=True):\n                give a walk on the graph (a list of nodes) the function will return a table\n                representing the possible genes and their probabilities at each edge of the walk.\n\n              path_gene_table(cdr3_sample,threshold=None):\n                the function will return two tables of all possible v and j genes\n                that colud be used to generate the sequence given by \"cdr3_sample\"\n\n\n              path_gene_table_plot(threshold=None,figsize=None):\n                the function plots two heatmap, one for V genes and one for J genes,\n                and represents the probability at each edge to select that gene,\n                the color at each cell is equal to the probability of selecting the gene, a black\n                cell means that the graph didn't see that gene used with that sub-pattern.\n\n                the data used to create the charts can be derived by using the \"path_gene_table\" method.\n\n              gene_variation(cdr3):\n                given a sequence, this will derive a charts that shows the number of V and J genes observed\n                per node (LZ- subpattern).\n\n              gene_variation_plot(cdr3):\n                Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count\n                and one for J gene count.\n\n\n              random_walk(steps):\n                 given a number of steps (sub-patterns) returns a random walk on the graph between a random inital state\n                 to a random terminal state in the given number of steps\n\n              gene_random_walk(seq_len, initial_state):\n                given a target sequence length and an initial state, the function will select a random\n                V and a random J genes from the observed gene frequency in the graph's \"Training data\" and\n                generate a walk on the graph from the initial state to a terminal state while making sure\n                at each step that both the selected V and J genes were seen used by that specific sub-pattern.\n\n              unsupervised_random_walk():\n                a random initial state and a random terminal state are selected and a random unsupervised walk is\n                carried out until the randomly selected terminal state is reached.\n\n              eigenvector_centrality():\n                return the eigen vector centrality value for each node (this function is used as the feature extractor\n                for the LZGraph)\n\n\n              sequence_variation_curve(cdr3_sample):\n                given a cdr3 sequence, the function will calculate the value of the variation curve and return\n                2 arrays, 1 of the sub-patterns and 1 for the number of out neighbours for each sub-pattern\n\n              graph_summary():\n                the function will return a pandas DataFrame containing the graphs\n                Chromatic Number,Number of Isolates,Max In Deg,Max Out Deg,Number of Edges\n\n\n         Attributes:\n                    nodes:\n                        returns the nodes of the graph\n                    edges:\n                        return the edges of the graph\n\n\n        \"\"\"\n\n    def __init__(self, data, verbose=True, calculate_trainset_pgen=False):\n        \"\"\"\n        data has to be a pandas dataframe, the cdr3 amino acid sequence has to be under a column named\n        \"cdr3_amino_acid\"\n        and optionally you can add two columns \"V\" and \"J\" with the gene annotation for each sequence\n\n        Args:\n            data (pd.DataFrame): a dataframe containing the sequences for which to consturct an LZGraph and any\n            additional V/J Data given provided under the \"V\" column and a \"J\" column.\n            verbose\n        \"\"\"\n        super().__init__()\n\n        # check for V and J gene data in input\n        self.genetic = True if type(data) == pd.DataFrame and 'V' in data.columns and 'J' in data.columns else False\n\n        if self.genetic:\n            self._load_gene_data(data)\n            self.verbose_driver(0, verbose)\n\n        # construct the graph while iterating over the data\n        self.__simultaneous_graph_construction(data)\n        self.verbose_driver(1, verbose)\n\n        # convert to pandas series and  normalize\n        self.length_distribution = pd.Series(self.lengths)\n        self.terminal_states = pd.Series(self.terminal_states)\n        self.initial_states = pd.Series(self.initial_states)\n        self.length_distribution_proba = self.terminal_states / self.terminal_states.sum()\n        self.initial_states = self.initial_states[self.initial_states &gt; 5]\n        self.initial_states_probability = self.initial_states/self.initial_states.sum()\n\n        self.verbose_driver(2, verbose)\n\n        self._derive_subpattern_individual_probability()\n        self.verbose_driver(8, verbose)\n        self._normalize_edge_weights()\n        self.verbose_driver(3, verbose)\n\n        if self.genetic:\n            # Normalized Gene Weights\n            self._batch_gene_weight_normalization(3, verbose)\n            self.verbose_driver(4, verbose)\n\n        self.edges_list = None\n        self._derive_terminal_state_map()\n        self.verbose_driver(7, verbose)\n        self._derive_stop_probability_data()\n        self.verbose_driver(8, verbose)\n        self.verbose_driver(5, verbose)\n\n        if calculate_trainset_pgen:\n            self.train_pgen = np.array(\n                [self.walk_probability(self.encode_sequence(i), verbose=False) for i in data.cdr3_amino_acid])\n\n        self.constructor_end_time = time()\n        self.verbose_driver(6, verbose)\n        self.verbose_driver(-2, verbose)\n\n    @staticmethod\n    def encode_sequence(amino_acid):\n        \"\"\"\n        This function will take a sequence and return it as LZ sub-patterns with added position\n        the general format is given as {LZ-subpattern}_{start_index}\n\n        Args:\n            amino_acid (str)\n        \"\"\"\n        lz, loc = derive_lz_and_position(amino_acid)\n        return list(map(lambda x, z: x + '_' + str(z), lz, loc))\n    @staticmethod\n    def clean_node(base):\n        \"\"\"\n        This Function will take in a sub-pattern that has position added to it and clean\n        the added values returning only the amino acid value\n        Args:\n            base (str)\n        \"\"\"\n        return re.search(r'[A-Z]*', base).group()\n\n    def _decomposed_sequence_generator(self,data):\n        if self.genetic:\n            for cdr3,v,j in tqdm(zip(data['cdr3_amino_acid'],data['V'],data['J']), leave=False):\n\n                LZ, locs = derive_lz_and_position(cdr3)\n\n                steps = (window(LZ, 2))\n                locations = (window(locs, 2))\n                self.lengths[len(cdr3)] = self.lengths.get(len(cdr3), 0) + 1\n\n                self._update_terminal_states(LZ[-1] + '_' + str(locs[-1]))\n                self._update_initial_states(LZ[0] + '_1')\n                yield steps,locations,v,j\n        else:\n            for cdr3 in tqdm(list(data), leave=False):\n                LZ, locations_ = derive_lz_and_position(cdr3)\n                steps = (window(LZ, 2))\n                locations = (window(locations_, 2))\n\n                self.lengths[len(cdr3)] = self.lengths.get(len(cdr3), 0) + 1\n                self._update_terminal_states(LZ[-1] + '_' + str(locations_[-1]))\n                self._update_initial_states(LZ[0] + '_1')\n                yield steps,locations\n\n    def __simultaneous_graph_construction(self, data):\n        processing_stream = self._decomposed_sequence_generator(data)\n        if self.genetic:\n            for output in processing_stream:\n                steps, locations,v,j = output\n\n                for (A, B), (loc_a, loc_b) in zip(steps, locations):\n                    A_ = A + '_' + str(loc_a)\n                    self.per_node_observed_frequency[A_] = self.per_node_observed_frequency.get(A_, 0) + 1\n                    B_ = B + '_' + str(loc_b)\n                    self._insert_edge_and_information(A_, B_, v, j)\n                self.per_node_observed_frequency[B_] = self.per_node_observed_frequency.get(B_, 0)\n        else:\n\n            for output in processing_stream:\n                steps, locations = output\n                for (A, B), (loc_a, loc_b) in zip(steps, locations):\n                    A_ = A + '_' + str(loc_a)\n                    self.per_node_observed_frequency[A_] = self.per_node_observed_frequency.get(A_, 0) + 1\n                    B_ = B + '_' + str(loc_b)\n                    self._insert_edge_and_information_no_genes(A_, B_)\n                self.per_node_observed_frequency[B_] = self.per_node_observed_frequency.get(B_, 0)\n\n\n\n    def walk_probability(self, walk, verbose=True, use_epsilon=False):\n        \"\"\"\n                    given a walk (a sequence converted into LZ sub-pattern) return the probability of generation (PGEN)\n                    of the walk.\n\n                    you can use \"lempel_ziv_decomposition\" from this libraries decomposition module in order to convert a\n                    sequence into LZ sub-patterns\n\n                             Parameters:\n                                     walk (list): a list of LZ - sub-patterns\n\n                             Returns:\n                                     float : the probability of generating such a walk (PGEN)\n                      \"\"\"\n        if type(walk) == str:\n            LZ, POS = derive_lz_and_position(walk)\n            walk_ = [i + str(j) for i, j in zip(LZ, POS)]\n        else:\n            walk_ = walk\n\n        if walk_[0] not in self.subpattern_individual_probability['proba']:\n            return np.finfo(float).eps ** 2\n        proba = self.subpattern_individual_probability['proba'][walk_[0]]\n        n_missing = 0\n        total = 0\n        for step1, step2 in window(walk_, 2):\n            if self.graph.has_edge(step1, step2):\n                proba *= self.graph.get_edge_data(step1, step2)['weight']\n            else:\n                if verbose:\n                    print('No Edge Connecting| ', step1, '--&gt;', step2)\n                n_missing += 1\n            total += 1\n\n        if n_missing &gt; 0:\n            gmean = np.power(proba, (1 / total))\n            proba = proba * (gmean ** n_missing)\n        return proba\n\n    def walk_gene_probability(self, walk, v, j, verbose=True, use_epsilon=False):\n        if type(walk) == str:\n            LZ, POS = derive_lz_and_position(walk)\n            walk_ = [i + str(j) for i, j in zip(LZ, POS)]\n        else:\n            walk_ = walk\n\n        proba_v = self.marginal_vgenes.loc[v]\n        proba_j = self.marginal_jgenes.loc[j]\n        for step1, step2 in window(walk_, 2):\n            if self.graph.has_edge(step1, step2):\n                proba_v *= self.graph.get_edge_data(step1, step2)[v]\n                proba_j *= self.graph.get_edge_data(step1, step2)[j]\n            else:\n                if verbose:\n                    print('No Edge Connecting| ', step1, '--&gt;', step2)\n                if use_epsilon:\n                    return np.finfo(np.float64).eps\n                else:\n                    return 0\n        return proba_v, proba_j\n\n    # def random_walk(self, seq_len, initial_state):\n    #     \"\"\"\n    #       given a number of steps (sub-patterns) returns a random walk on the graph between a random inital state\n    #         to a random terminal state in the given number of steps\n    #\n    #\n    #                  Parameters:\n    #                          steps (int): number of sub-patterns the resulting walk should contain\n    #                  Returns:\n    #                          (list) : a list of LZ sub-patterns representing the random walk\n    #                   \"\"\"\n    #     current_state = initial_state\n    #     walk = [initial_state]\n    #     sequence = clean_node(initial_state)\n    #\n    #     final_states = self._length_specific_terminal_state(seq_len)\n    #\n    #     if len(final_states) &lt; 1:\n    #         raise Exception('Unfamiliar Seq Length')\n    #\n    #     while current_state not in final_states:\n    #         states, probabilities = self._get_state_weights(current_state)\n    #         # Try add dynamic dictionary of weight that will remove invalid paths\n    #\n    #         # if went into a final path with mismatch length\n    #         if len(probabilities) == 0:  # no options we can take from here\n    #             # go back to the last junction where a different choice can be made\n    #             for ax in range(len(walk) - 1, 1, -1):\n    #                 for final_s in final_states:\n    #                     try:\n    #                         SP = nx.dijkstra_path(self.graph, source=walk[ax], target=final_s,\n    #                                               weight=lambda x, y, z: 1 - z['weight'])\n    #                         walk = walk[:ax] + SP\n    #                         sequence = ''.join([clean_node(i) for i in walk])\n    #                         return walk\n    #                     except nx.NetworkXNoPath:\n    #                         continue\n    #\n    #         current_state = np.random.choice(states, size=1, p=probabilities).item()\n    #         walk.append(current_state)\n    #         sequence += clean_node(current_state)\n    #\n    #     return walk\n\n\n    def multi_gene_random_walk(self, N, seq_len, initial_state=None, vj_init='marginal'):\n\n        selected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\n\n        if seq_len == 'unsupervised':\n            final_states = self.terminal_states.index.to_list().copy()\n        else:\n            final_states = self._length_specific_terminal_state(seq_len)\n\n        # nodes not to consider due to invalidity\n        if self.genetic_walks_black_list is None:\n            self.genetic_walks_black_list = dict()\n\n        results = []\n\n        lengths = pd.Series(self.terminal_states).value_counts()\n        max_length = lengths.idxmax()\n        for _ in tqdm(range(N)):\n            if initial_state is None:\n                current_state = self._random_initial_state()\n                walk = [current_state]\n            else:\n                current_state = initial_state\n                walk = [initial_state]\n\n            # while the walk is not in a valid final state\n            while current_state not in lengths.index:\n                # print('Blacklist: ',blacklist)\n                # print('='*30)\n                # get the node_data for the current state\n                edge_info = pd.DataFrame(dict(self.graph[current_state]))\n\n                if (current_state, selected_gene_path_v, selected_gene_path_j) in self.genetic_walks_black_list:\n                    edge_info = edge_info.drop(columns=self.genetic_walks_black_list[\n                        (current_state, selected_gene_path_v, selected_gene_path_j)])\n                # check selected path has genes\n                if len(set(edge_info.index) &amp; {selected_gene_path_v, selected_gene_path_j}) != 2:\n                    # TODO: add a visited node stack to not repeat the same calls and mistakes\n                    if len(walk) &gt; 2:\n                        self.genetic_walks_black_list[(walk[-2], selected_gene_path_v, selected_gene_path_j)] \\\n                            = self.genetic_walks_black_list.get((walk[-2], selected_gene_path_v, selected_gene_path_j),\n                                                                []) + [walk[-1]]\n                        current_state = walk[-2]\n                        walk = walk[:-1]\n                    else:\n                        walk = walk[:1]\n                        current_state = walk[0]\n                        selected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\n\n                    continue\n\n                # get paths containing selected_genes\n                idf = edge_info.T[[selected_gene_path_v, selected_gene_path_j]].dropna()\n                w = edge_info.loc['weight', idf.index]\n                w = w / w.sum()\n\n                if len(w) == 0:\n                    if len(walk) &gt; 2:\n                        self.genetic_walks_black_list[(walk[-2], selected_gene_path_v, selected_gene_path_j)] = \\\n                            self.genetic_walks_black_list.get((walk[-2], selected_gene_path_v, selected_gene_path_j),\n                                                              []) + [walk[-1]]\n                        current_state = walk[-2]\n                        walk = walk[:-1]\n                    else:\n                        walk = walk[:1]\n                        current_state = walk[0]\n                        selected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\n\n                    continue\n\n                current_state = np.random.choice(w.index, size=1, p=w.values).item()\n                walk.append(current_state)\n\n            results.append((walk, selected_gene_path_v, selected_gene_path_j))\n\n            if walk[-1] in lengths.index and walk[-1] != max_length:  # [lengths &lt;= lengths.max()].index:\n                lengths[walk[-1]] -= 1\n                if lengths[walk[-1]] &lt; 0:\n                    lengths.pop(walk[-1])\n\n        return results\n\n\n    def unsupervised_random_walk(self):\n        \"\"\"\n     a random initial state and a random terminal state are selected and a random unsupervised walk is\n    carried out until the randomly selected terminal state is reached.\n\n              Parameters:\n                      None\n\n              Returns:\n                      (list,str) : a list of LZ sub-patterns representing the random walk and a string\n                      matching the walk only translated back into a sequence.\n                       \"\"\"\n        random_initial_state = self._random_initial_state()\n\n        current_state = random_initial_state\n        walk = [random_initial_state]\n        sequence = self.clean_node(random_initial_state)\n\n        while not self.is_stop_condition(current_state):\n            # take a random step\n            current_state = self.random_step(current_state)\n\n            walk.append(current_state)\n            sequence += self.clean_node(current_state)\n        return walk, sequence\n\n    def walk_genes(self, walk, dropna=True,raise_error=True):\n        \"\"\"\n               give a walk on the graph (a list of nodes) the function will return a table\n                   representing the possible genes and their probabilities at each edge of the walk.\n           Args:\n            walk (list): a list of nodes representing a walk on the graph.\n            dropna (bool): whether to drop the edges that are missing from the graph.\n           \"\"\"\n        trans_genes = dict()\n        for i in range(0, len(walk) - 1):\n            if self.graph.has_edge(walk[i], walk[i + 1]):\n                ls = self.graph.get_edge_data(walk[i], walk[i + 1]).copy()\n                ls.pop('weight')\n                ls.pop('Vsum')\n                ls.pop('Jsum')\n\n                trans_genes[walk[i] + '-&gt;' + walk[i + 1]] = ls\n\n        cc = pd.DataFrame(trans_genes)\n\n        if dropna:\n            cc = cc.dropna()\n        if cc.shape[0] == 0 and raise_error:\n            raise Exception('No Constant Gene Flow F')\n\n        cc['type'] = ['v' if 'v' in x.lower() else 'j' for x in cc.index]\n        cc['sum'] = cc.sum(axis=1, numeric_only=True)\n        #cc = cc.sort_values(by='sum', ascending=False)\n\n        return cc\n\n    def random_walk_distribution_based(self, length_distribution):\n        N = length_distribution.sum()\n        N = N * 3\n\n        rwalks = []\n        rseqs = []\n        for _ in tqdm(range(N)):\n            rw = self.unsupervised_random_walk()\n            rwalks.append(rw[0])\n            rseqs.append(rw[1])\n        R = pd.DataFrame({'Seqs': rseqs, 'Walks': rwalks})\n        R['L'] = R['Seqs'].str.len()\n\n        samples = []\n        for length in length_distribution.index:\n            samples.append(R[R['L'] == length].sample(length_distribution[length]))\n        return pd.concat(samples).iloc[:, :-1].values\n\n    def get_gene_graph(self, v, j):\n        to_drop = []\n        if self.edges_list is None:\n            self.edges_list = list(self.graph.edges(data=True))\n\n        for edge in self.edges_list:\n            if v in edge[2] and j in edge[2]:\n                continue\n            else:\n                to_drop.append((edge[0], edge[1]))\n\n        G = self.graph.copy()\n        G.remove_edges_from(to_drop)\n        G.remove_nodes_from(list(nx.isolates(G)))\n        return G\n\n    def cac_random_gene_walk(self, initial_state=None, vj_init='combined'):\n        selected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\n\n        if (selected_gene_path_v, selected_gene_path_j) not in self.cac_graphs:\n            G = self.get_gene_graph(selected_gene_path_v, selected_gene_path_j)\n            self.cac_graphs[(selected_gene_path_v, selected_gene_path_j)] = G\n        else:\n            G = self.cac_graphs[(selected_gene_path_v, selected_gene_path_j)]\n\n        final_states = self.terminal_states.copy()\n        final_states = list(set(final_states) &amp; set(G.nodes))\n\n        first_states = self.initial_states.copy()\n        first_states = first_states.loc[list(set(first_states.index) &amp; set(G.nodes))]\n        first_states = (first_states / first_states.sum())\n\n        current_state = np.random.choice(first_states.index, size=1, p=first_states.values)[0]\n        walk = [current_state]\n\n        # nodes not to consider due to invalidity\n        if self.genetic_walks_black_list is None:\n            self.genetic_walks_black_list = dict()\n\n        # while the walk is not in a valid final state\n        while current_state not in final_states:\n            # get the node_data for the current state\n            edge_info = pd.DataFrame(dict(G[current_state]))\n\n            if (selected_gene_path_v, selected_gene_path_j, current_state) in self.genetic_walks_black_list:\n                edge_info = edge_info.drop(\n                    columns=self.genetic_walks_black_list[(selected_gene_path_v, selected_gene_path_j, current_state)])\n\n            if edge_info.shape[1] == 0:\n                self.genetic_walks_black_list[(selected_gene_path_v, selected_gene_path_j, walk[-2])] = \\\n                    self.genetic_walks_black_list.get((selected_gene_path_v, selected_gene_path_j, walk[-2]), []) + [\n                        current_state]\n                walk = walk[:-1]\n                current_state = walk[-1]\n                continue\n\n            # get paths containing selected_genes\n            idf = edge_info.T[[selected_gene_path_v, selected_gene_path_j]].dropna()\n            w = edge_info.loc['weight', idf.index]\n            w = w / w.sum()\n\n            current_state = np.random.choice(w.index, size=1, p=w.values).item()\n            walk.append(current_state)\n\n        return walk, selected_gene_path_v, selected_gene_path_j\n\n    def sequence_variation_curve(self, cdr3_sample):\n        \"\"\"\n        given a sequence this function will return 2 list,\n        the first is the lz-subpattern path through the graph and the second list is the number\n        of possible choices that can be made at each sub-pattern\n        :param cdr3_sample:\n        :return:\n        \"\"\"\n        encoded = self.encode_sequence(cdr3_sample)\n        curve = [self.graph.out_degree(i) for i in encoded]\n        return encoded, curve\n\n    def path_gene_table(self, cdr3_sample, threshold=None):\n        \"\"\"\n               the function will return two tables of all possible v and j genes\n                   that colud be used to generate the sequence given by \"cdr3_sample\"\n               :param cdr3_sample: a cdr3 sequence\n               :param threshold: drop genes that are missing from threshold % of the sequence\n               :return:\n               \"\"\"\n        length = len(self.encode_sequence(cdr3_sample))\n\n        if threshold is None:\n            threshold = length * (1 / 4)\n        gene_table = self.walk_genes(self.encode_sequence(cdr3_sample), dropna=False)\n        gene_table = gene_table[gene_table.isna().sum(axis=1) &lt; threshold]\n        vgene_table = gene_table[gene_table.index.str.contains('V')]\n\n        gene_table = self.walk_genes(self.encode_sequence(cdr3_sample), dropna=False)\n        gene_table = gene_table[gene_table.isna().sum(axis=1) &lt; (length * (1 / 2))]\n        jgene_table = gene_table[gene_table.index.str.contains('J')]\n\n        jgene_table = jgene_table.loc[jgene_table.isna().sum(axis=1).sort_values(ascending=True).index, :]\n        vgene_table = vgene_table.loc[vgene_table.isna().sum(axis=1).sort_values(ascending=True).index, :]\n\n        return vgene_table, jgene_table\n\n    def gene_variation(self, cdr3):\n        \"\"\"\n               Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count\n                   and one for J gene count.\n               :param cdr3:\n               :return:\n               \"\"\"\n        if not self.genetic:\n            raise Exception('The LZGraph Has No Gene Data')\n        encoded_a = self.encode_sequence(cdr3)\n        nv_genes = [len(self.marginal_vgenes)]\n        nj_genes = [len(self.marginal_jgenes)]\n        for node in encoded_a[1:]:\n            inedges = self.graph.in_edges(node)\n            v = set()\n            j = set()\n            for ea, eb in inedges:\n                genes = pd.Series(self.graph[ea][eb]).drop(index=['Vsum', 'Jsum', 'weight'])\n                v = v | set(genes[genes.index.str.contains('V')].index)\n                j = j | set(genes[genes.index.str.contains('J')].index)\n            nv_genes.append(len(v))\n            nj_genes.append(len(j))\n\n        nj_genes = np.array(nj_genes)\n        nv_genes = np.array(nv_genes)\n\n        j_df = pd.DataFrame(\n            {'genes': list(nv_genes) + list(nj_genes), 'type': ['V'] * len(nv_genes) + ['J'] * len(nj_genes),\n             'sp': lempel_ziv_decomposition(cdr3) + lempel_ziv_decomposition(cdr3)})\n        return j_df\n</code></pre>"},{"location":"aaplzgraph_reference/#src.LZGraphs.Graphs.AminoAcidPositional.AAPLZGraph.__init__","title":"<code>__init__(data, verbose=True, calculate_trainset_pgen=False)</code>","text":"<p>data has to be a pandas dataframe, the cdr3 amino acid sequence has to be under a column named \"cdr3_amino_acid\" and optionally you can add two columns \"V\" and \"J\" with the gene annotation for each sequence</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>a dataframe containing the sequences for which to consturct an LZGraph and any</p> required Source code in <code>src\\LZGraphs\\Graphs\\AminoAcidPositional.py</code> <pre><code>def __init__(self, data, verbose=True, calculate_trainset_pgen=False):\n    \"\"\"\n    data has to be a pandas dataframe, the cdr3 amino acid sequence has to be under a column named\n    \"cdr3_amino_acid\"\n    and optionally you can add two columns \"V\" and \"J\" with the gene annotation for each sequence\n\n    Args:\n        data (pd.DataFrame): a dataframe containing the sequences for which to consturct an LZGraph and any\n        additional V/J Data given provided under the \"V\" column and a \"J\" column.\n        verbose\n    \"\"\"\n    super().__init__()\n\n    # check for V and J gene data in input\n    self.genetic = True if type(data) == pd.DataFrame and 'V' in data.columns and 'J' in data.columns else False\n\n    if self.genetic:\n        self._load_gene_data(data)\n        self.verbose_driver(0, verbose)\n\n    # construct the graph while iterating over the data\n    self.__simultaneous_graph_construction(data)\n    self.verbose_driver(1, verbose)\n\n    # convert to pandas series and  normalize\n    self.length_distribution = pd.Series(self.lengths)\n    self.terminal_states = pd.Series(self.terminal_states)\n    self.initial_states = pd.Series(self.initial_states)\n    self.length_distribution_proba = self.terminal_states / self.terminal_states.sum()\n    self.initial_states = self.initial_states[self.initial_states &gt; 5]\n    self.initial_states_probability = self.initial_states/self.initial_states.sum()\n\n    self.verbose_driver(2, verbose)\n\n    self._derive_subpattern_individual_probability()\n    self.verbose_driver(8, verbose)\n    self._normalize_edge_weights()\n    self.verbose_driver(3, verbose)\n\n    if self.genetic:\n        # Normalized Gene Weights\n        self._batch_gene_weight_normalization(3, verbose)\n        self.verbose_driver(4, verbose)\n\n    self.edges_list = None\n    self._derive_terminal_state_map()\n    self.verbose_driver(7, verbose)\n    self._derive_stop_probability_data()\n    self.verbose_driver(8, verbose)\n    self.verbose_driver(5, verbose)\n\n    if calculate_trainset_pgen:\n        self.train_pgen = np.array(\n            [self.walk_probability(self.encode_sequence(i), verbose=False) for i in data.cdr3_amino_acid])\n\n    self.constructor_end_time = time()\n    self.verbose_driver(6, verbose)\n    self.verbose_driver(-2, verbose)\n</code></pre>"},{"location":"aaplzgraph_reference/#src.LZGraphs.Graphs.AminoAcidPositional.AAPLZGraph.clean_node","title":"<code>clean_node(base)</code>  <code>staticmethod</code>","text":"<p>This Function will take in a sub-pattern that has position added to it and clean the added values returning only the amino acid value Args:     base (str)</p> Source code in <code>src\\LZGraphs\\Graphs\\AminoAcidPositional.py</code> <pre><code>@staticmethod\ndef clean_node(base):\n    \"\"\"\n    This Function will take in a sub-pattern that has position added to it and clean\n    the added values returning only the amino acid value\n    Args:\n        base (str)\n    \"\"\"\n    return re.search(r'[A-Z]*', base).group()\n</code></pre>"},{"location":"aaplzgraph_reference/#src.LZGraphs.Graphs.AminoAcidPositional.AAPLZGraph.encode_sequence","title":"<code>encode_sequence(amino_acid)</code>  <code>staticmethod</code>","text":"<p>This function will take a sequence and return it as LZ sub-patterns with added position the general format is given as {LZ-subpattern}_{start_index}</p> Source code in <code>src\\LZGraphs\\Graphs\\AminoAcidPositional.py</code> <pre><code>@staticmethod\ndef encode_sequence(amino_acid):\n    \"\"\"\n    This function will take a sequence and return it as LZ sub-patterns with added position\n    the general format is given as {LZ-subpattern}_{start_index}\n\n    Args:\n        amino_acid (str)\n    \"\"\"\n    lz, loc = derive_lz_and_position(amino_acid)\n    return list(map(lambda x, z: x + '_' + str(z), lz, loc))\n</code></pre>"},{"location":"aaplzgraph_reference/#src.LZGraphs.Graphs.AminoAcidPositional.AAPLZGraph.gene_variation","title":"<code>gene_variation(cdr3)</code>","text":"<p>Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count     and one for J gene count. :param cdr3: :return:</p> Source code in <code>src\\LZGraphs\\Graphs\\AminoAcidPositional.py</code> <pre><code>def gene_variation(self, cdr3):\n    \"\"\"\n           Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count\n               and one for J gene count.\n           :param cdr3:\n           :return:\n           \"\"\"\n    if not self.genetic:\n        raise Exception('The LZGraph Has No Gene Data')\n    encoded_a = self.encode_sequence(cdr3)\n    nv_genes = [len(self.marginal_vgenes)]\n    nj_genes = [len(self.marginal_jgenes)]\n    for node in encoded_a[1:]:\n        inedges = self.graph.in_edges(node)\n        v = set()\n        j = set()\n        for ea, eb in inedges:\n            genes = pd.Series(self.graph[ea][eb]).drop(index=['Vsum', 'Jsum', 'weight'])\n            v = v | set(genes[genes.index.str.contains('V')].index)\n            j = j | set(genes[genes.index.str.contains('J')].index)\n        nv_genes.append(len(v))\n        nj_genes.append(len(j))\n\n    nj_genes = np.array(nj_genes)\n    nv_genes = np.array(nv_genes)\n\n    j_df = pd.DataFrame(\n        {'genes': list(nv_genes) + list(nj_genes), 'type': ['V'] * len(nv_genes) + ['J'] * len(nj_genes),\n         'sp': lempel_ziv_decomposition(cdr3) + lempel_ziv_decomposition(cdr3)})\n    return j_df\n</code></pre>"},{"location":"aaplzgraph_reference/#src.LZGraphs.Graphs.AminoAcidPositional.AAPLZGraph.path_gene_table","title":"<code>path_gene_table(cdr3_sample, threshold=None)</code>","text":"<p>the function will return two tables of all possible v and j genes     that colud be used to generate the sequence given by \"cdr3_sample\" :param cdr3_sample: a cdr3 sequence :param threshold: drop genes that are missing from threshold % of the sequence :return:</p> Source code in <code>src\\LZGraphs\\Graphs\\AminoAcidPositional.py</code> <pre><code>def path_gene_table(self, cdr3_sample, threshold=None):\n    \"\"\"\n           the function will return two tables of all possible v and j genes\n               that colud be used to generate the sequence given by \"cdr3_sample\"\n           :param cdr3_sample: a cdr3 sequence\n           :param threshold: drop genes that are missing from threshold % of the sequence\n           :return:\n           \"\"\"\n    length = len(self.encode_sequence(cdr3_sample))\n\n    if threshold is None:\n        threshold = length * (1 / 4)\n    gene_table = self.walk_genes(self.encode_sequence(cdr3_sample), dropna=False)\n    gene_table = gene_table[gene_table.isna().sum(axis=1) &lt; threshold]\n    vgene_table = gene_table[gene_table.index.str.contains('V')]\n\n    gene_table = self.walk_genes(self.encode_sequence(cdr3_sample), dropna=False)\n    gene_table = gene_table[gene_table.isna().sum(axis=1) &lt; (length * (1 / 2))]\n    jgene_table = gene_table[gene_table.index.str.contains('J')]\n\n    jgene_table = jgene_table.loc[jgene_table.isna().sum(axis=1).sort_values(ascending=True).index, :]\n    vgene_table = vgene_table.loc[vgene_table.isna().sum(axis=1).sort_values(ascending=True).index, :]\n\n    return vgene_table, jgene_table\n</code></pre>"},{"location":"aaplzgraph_reference/#src.LZGraphs.Graphs.AminoAcidPositional.AAPLZGraph.sequence_variation_curve","title":"<code>sequence_variation_curve(cdr3_sample)</code>","text":"<p>given a sequence this function will return 2 list, the first is the lz-subpattern path through the graph and the second list is the number of possible choices that can be made at each sub-pattern :param cdr3_sample: :return:</p> Source code in <code>src\\LZGraphs\\Graphs\\AminoAcidPositional.py</code> <pre><code>def sequence_variation_curve(self, cdr3_sample):\n    \"\"\"\n    given a sequence this function will return 2 list,\n    the first is the lz-subpattern path through the graph and the second list is the number\n    of possible choices that can be made at each sub-pattern\n    :param cdr3_sample:\n    :return:\n    \"\"\"\n    encoded = self.encode_sequence(cdr3_sample)\n    curve = [self.graph.out_degree(i) for i in encoded]\n    return encoded, curve\n</code></pre>"},{"location":"aaplzgraph_reference/#src.LZGraphs.Graphs.AminoAcidPositional.AAPLZGraph.unsupervised_random_walk","title":"<code>unsupervised_random_walk()</code>","text":"<p>a random initial state and a random terminal state are selected and a random unsupervised walk is carried out until the randomly selected terminal state is reached.</p> <pre><code>      Parameters:\n              None\n\n      Returns:\n              (list,str) : a list of LZ sub-patterns representing the random walk and a string\n              matching the walk only translated back into a sequence.\n</code></pre> Source code in <code>src\\LZGraphs\\Graphs\\AminoAcidPositional.py</code> <pre><code>def unsupervised_random_walk(self):\n    \"\"\"\n a random initial state and a random terminal state are selected and a random unsupervised walk is\ncarried out until the randomly selected terminal state is reached.\n\n          Parameters:\n                  None\n\n          Returns:\n                  (list,str) : a list of LZ sub-patterns representing the random walk and a string\n                  matching the walk only translated back into a sequence.\n                   \"\"\"\n    random_initial_state = self._random_initial_state()\n\n    current_state = random_initial_state\n    walk = [random_initial_state]\n    sequence = self.clean_node(random_initial_state)\n\n    while not self.is_stop_condition(current_state):\n        # take a random step\n        current_state = self.random_step(current_state)\n\n        walk.append(current_state)\n        sequence += self.clean_node(current_state)\n    return walk, sequence\n</code></pre>"},{"location":"aaplzgraph_reference/#src.LZGraphs.Graphs.AminoAcidPositional.AAPLZGraph.walk_genes","title":"<code>walk_genes(walk, dropna=True, raise_error=True)</code>","text":"<pre><code>give a walk on the graph (a list of nodes) the function will return a table\n    representing the possible genes and their probabilities at each edge of the walk.\n</code></pre> <p>Args:  walk (list): a list of nodes representing a walk on the graph.  dropna (bool): whether to drop the edges that are missing from the graph.</p> Source code in <code>src\\LZGraphs\\Graphs\\AminoAcidPositional.py</code> <pre><code>def walk_genes(self, walk, dropna=True,raise_error=True):\n    \"\"\"\n           give a walk on the graph (a list of nodes) the function will return a table\n               representing the possible genes and their probabilities at each edge of the walk.\n       Args:\n        walk (list): a list of nodes representing a walk on the graph.\n        dropna (bool): whether to drop the edges that are missing from the graph.\n       \"\"\"\n    trans_genes = dict()\n    for i in range(0, len(walk) - 1):\n        if self.graph.has_edge(walk[i], walk[i + 1]):\n            ls = self.graph.get_edge_data(walk[i], walk[i + 1]).copy()\n            ls.pop('weight')\n            ls.pop('Vsum')\n            ls.pop('Jsum')\n\n            trans_genes[walk[i] + '-&gt;' + walk[i + 1]] = ls\n\n    cc = pd.DataFrame(trans_genes)\n\n    if dropna:\n        cc = cc.dropna()\n    if cc.shape[0] == 0 and raise_error:\n        raise Exception('No Constant Gene Flow F')\n\n    cc['type'] = ['v' if 'v' in x.lower() else 'j' for x in cc.index]\n    cc['sum'] = cc.sum(axis=1, numeric_only=True)\n    #cc = cc.sort_values(by='sum', ascending=False)\n\n    return cc\n</code></pre>"},{"location":"aaplzgraph_reference/#src.LZGraphs.Graphs.AminoAcidPositional.AAPLZGraph.walk_probability","title":"<code>walk_probability(walk, verbose=True, use_epsilon=False)</code>","text":"<p>given a walk (a sequence converted into LZ sub-pattern) return the probability of generation (PGEN) of the walk.</p> <p>you can use \"lempel_ziv_decomposition\" from this libraries decomposition module in order to convert a sequence into LZ sub-patterns</p> <pre><code>     Parameters:\n             walk (list): a list of LZ - sub-patterns\n\n     Returns:\n             float : the probability of generating such a walk (PGEN)\n</code></pre> Source code in <code>src\\LZGraphs\\Graphs\\AminoAcidPositional.py</code> <pre><code>def walk_probability(self, walk, verbose=True, use_epsilon=False):\n    \"\"\"\n                given a walk (a sequence converted into LZ sub-pattern) return the probability of generation (PGEN)\n                of the walk.\n\n                you can use \"lempel_ziv_decomposition\" from this libraries decomposition module in order to convert a\n                sequence into LZ sub-patterns\n\n                         Parameters:\n                                 walk (list): a list of LZ - sub-patterns\n\n                         Returns:\n                                 float : the probability of generating such a walk (PGEN)\n                  \"\"\"\n    if type(walk) == str:\n        LZ, POS = derive_lz_and_position(walk)\n        walk_ = [i + str(j) for i, j in zip(LZ, POS)]\n    else:\n        walk_ = walk\n\n    if walk_[0] not in self.subpattern_individual_probability['proba']:\n        return np.finfo(float).eps ** 2\n    proba = self.subpattern_individual_probability['proba'][walk_[0]]\n    n_missing = 0\n    total = 0\n    for step1, step2 in window(walk_, 2):\n        if self.graph.has_edge(step1, step2):\n            proba *= self.graph.get_edge_data(step1, step2)['weight']\n        else:\n            if verbose:\n                print('No Edge Connecting| ', step1, '--&gt;', step2)\n            n_missing += 1\n        total += 1\n\n    if n_missing &gt; 0:\n        gmean = np.power(proba, (1 / total))\n        proba = proba * (gmean ** n_missing)\n    return proba\n</code></pre>"},{"location":"bowencoder_reference/","title":"BOW Encoder Functions","text":""},{"location":"bowencoder_reference/#src.LZGraphs.BagOfWords.BOWEncoder.LZBOW","title":"<code>LZBOW</code>","text":"<p>This class supplies a full suite for the conversion of repertoires into a bag of words representation based on a given sub-pattern (graph node) deriving function. This class requires fitting on a set of sequences in order to derive the dictionary of unique sub patterns used to generate the bag of words representation. After the class been fitted on a source set of sequences each time a transformation is needed one can use the transform method to get the vector representation.</p> <p>Parameters:</p> Name Type Description Default <code>encoding_function</code> <code>str</code> <p>the selected node extraction method to use 'naive' - emulate Naive LZGraph extraction / 'ndp'- emulate Nucleotide Double Positional LZGraph / 'aap' - Amino Acid Positional LZGraph.</p> <code>lempel_ziv_decomposition</code> <p>Attributes:</p> <pre><code>dictionary (set): a set of sub-patterns (graph nodes) representing the dictionary of the BOW vector\ndictionary_size (int): The size of the dictionary\nobserved_sequences (int): The number of sequences used to derive the dictionary\nencoding_function (func): the function used to derive sub-patterns from a sequence (in the context of this\nlibrary it is one of the 3: Naive, Nucleotide Double Positional, Amino Acid Positional\ndictionary_index_map (dict): a dictionary that maps the set of sub-patterns to numerical positions in\nthe BOW vector.\ndictionary_index_inverse_map (dict): a dictionary that maps numerical positions to the sub-patterns from\nthe dictionary set\n</code></pre> Source code in <code>src\\LZGraphs\\BagOfWords\\BOWEncoder.py</code> <pre><code>class LZBOW:\n    \"\"\"\n\n         This class supplies a full suite for the conversion of repertoires into a bag of words representation\n         based on a given sub-pattern (graph node) deriving function.\n         This class requires fitting on a set of sequences in order to derive the dictionary of unique sub patterns used\n         to generate the bag of words representation.\n         After the class been fitted on a source set of sequences each time a transformation is needed one can use\n         the transform method to get the vector representation.\n\n         Args:\n             encoding_function (str): the selected node extraction method to use 'naive' - emulate Naive LZGraph extraction\n              / 'ndp'- emulate Nucleotide Double Positional LZGraph / 'aap' - Amino Acid Positional LZGraph.\n\n         Attributes:\n\n             dictionary (set): a set of sub-patterns (graph nodes) representing the dictionary of the BOW vector\n             dictionary_size (int): The size of the dictionary\n             observed_sequences (int): The number of sequences used to derive the dictionary\n             encoding_function (func): the function used to derive sub-patterns from a sequence (in the context of this\n             library it is one of the 3: Naive, Nucleotide Double Positional, Amino Acid Positional\n             dictionary_index_map (dict): a dictionary that maps the set of sub-patterns to numerical positions in\n             the BOW vector.\n             dictionary_index_inverse_map (dict): a dictionary that maps numerical positions to the sub-patterns from\n             the dictionary set\n\n\n         \"\"\"\n    def __init__(self, encoding_function=lempel_ziv_decomposition):\n        self.dictionary = set()\n        self.dictionary_size = 0\n        self.observed_sequences = 0\n        self.encoding_function = encoding_function\n\n        self.dictionary_index_map = dict()\n        self.dictionary_index_inverse_map = dict()\n\n    def _derive_index_maps(self):\n        self.dictionary_index_map = {pattern: idx for idx, pattern in enumerate(self.dictionary)}\n        self.dictionary_index_inverse_map = {idx: pattern for idx, pattern in enumerate(self.dictionary)}\n        self.dictionary_size = len(self.dictionary)\n\n    def fit(self, data):\n        if type(data) == str:\n            encoded = self.encoding_function(data)\n            self.dictionary = self.dictionary | set(encoded)\n            self._derive_index_maps()\n\n        elif isinstance(data, Iterable):\n            for seq in tqdm(data, leave=False, position=0):\n                encoded = self.encoding_function(seq)\n                self.dictionary = self.dictionary | set(encoded)\n                self.observed_sequences += 1\n            self._derive_index_maps()\n\n    def _seq_to_index(self, seq):\n        encoded = self.encoding_function(seq)\n        return [self.dictionary_index_map[i] for i in encoded if i in self.dictionary]\n\n    def transform(self, data, normalize=False):\n        if type(data) == str:\n            result = np.zeros(self.dictionary_size)\n            result[self._seq_to_index(data)] += 1\n            return result\n        elif isinstance(data, Iterable):\n            result = np.zeros(self.dictionary_size)\n            for seq in tqdm(data, leave=False, position=0):\n                result[self._seq_to_index(seq)] += 1\n            if normalize:\n                return result / result.sum()\n            else:\n                return result\n\n    def load_from(self, other):\n        self.dictionary = other.dictionary\n        self.dictionary_size = other.dictionary_size\n        self.observed_sequences = other.observed_sequences\n        self.encoding_function = other.encoding_function\n\n        self.dictionary_index_map = other.dictionary_index_map\n        self.dictionary_index_inverse_map = other.dictionary_index_inverse_map\n\n    def __add__(self, other):\n        if self.encoding_function != other.encoding_function:\n            raise Exception('Encoding Function Mismatch Between BOW Objects')\n        union = LZBOW(self.encoding_function)\n        union.dictionary = self.dictionary | other.dictionary\n        union.observed_sequences = self.observed_sequences + other.observed_sequences\n        union.dictionary_index_map = {pattern: idx for idx, pattern in enumerate(union.dictionary)}\n        union.dictionary_index_inverse_map = {idx: pattern for idx, pattern in enumerate(union.dictionary)}\n        union.dictionary_size = len(self.dictionary)\n        return union\n</code></pre>"},{"location":"explanation/","title":"Explanation","text":"<p>This part of the project documentation focuses on a learning-oriented approach. You'll learn how to get started with the code in this project.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Help newcomers with getting started</li> <li>Teach readers about your library by making them     write code</li> <li>Inspire confidence through examples that work for     everyone, repeatably</li> <li>Give readers an immediate sense of achievement</li> <li>Show concrete examples, no abstractions</li> <li>Provide the minimum necessary explanation</li> <li>Avoid any distractions</li> </ul>"},{"location":"lzgraphbase_reference/","title":"LZGraph Base Class","text":""},{"location":"lzgraphbase_reference/#src.LZGraphs.Graphs.LZGraphBase.LZGraphBase","title":"<code>LZGraphBase</code>","text":"<p>This abstract class provides the base functionality and attributes shared between the different LZGraphs (excluding the Naive LZGraph).</p> <p>Attributes:</p> <pre><code>constructor_start_time (int): An integer recording the time in seconds the constructor was initiated\n(returned via the python time library time function)\ngraph (netowrkx.DiGraph): An empty DiGraph based on the networkx library, this object will keep the information\nwe derive throughout the constructor routine\ngenetic (bool): if True this flag will allow genetic function to be used as V and J annotation were provoided\nalong with the sequences. False means no genetic information is encoded into the graph.\ngenetic_walks_black_list (dict): This dictionary maps (edge / edge+vj) to another edge that leads a\ngenerated random walk to a \"dead-end\" as no more steps can be taken due to missing v/j information.\n(this applies only to genomic random walk where the randomly selected v and j genes have to appear at each edge).\nThe more sequences are generated by a particular LZGraph the more dead ends will be found, the quicker\nthe sequences will be generated.\nn_subpatterns (int):  The total number of sequences used to construct the LZGraph.\ninitial_states (dict): A dictionary containing all initial state and the number of time each one of them\nwas observed.\nterminal_states (dict): A dictionary containing all terminal state and the number of time each one of them\nwas observed.\ninitial_states_probability (pd.Series): A pandas series containing the normalized counts of the initial\nstates.\nlengths (dict): a dictionary that maps the different observed sequences length to the number of time\nthat length has been observed.\ncac_graphs (dict): This is dictionary used to keep different sub-graphs based on the condition in the\nkey, currently deprecated.\nn_transitions (int): The total number of transition observed while constructing the graph.\nn_neighbours (dict): Keep track of the number of neighbours given a certain condition in the key.\ncurrently deprecated.\nlength_distribution_proba (pd.Series): A pandas series mapping sequence length to a probability value\nbased on the sequence used to construct the LZGraph.\nsubpattern_individual_probability (pd.Series): A pandas series mapping the different graph nodes to the\nemperical probability of observing that specific node independent of the graph structure.\n</code></pre> Source code in <code>src\\LZGraphs\\Graphs\\LZGraphBase.py</code> <pre><code>class LZGraphBase:\n    \"\"\"\n\n         This abstract class provides the base functionality and attributes shared between the different LZGraphs\n         (excluding the Naive LZGraph).\n\n         Args:\n             Abstract Class\n\n         Attributes:\n\n             constructor_start_time (int): An integer recording the time in seconds the constructor was initiated\n             (returned via the python time library time function)\n             graph (netowrkx.DiGraph): An empty DiGraph based on the networkx library, this object will keep the information\n             we derive throughout the constructor routine\n             genetic (bool): if True this flag will allow genetic function to be used as V and J annotation were provoided\n             along with the sequences. False means no genetic information is encoded into the graph.\n             genetic_walks_black_list (dict): This dictionary maps (edge / edge+vj) to another edge that leads a\n             generated random walk to a \"dead-end\" as no more steps can be taken due to missing v/j information.\n             (this applies only to genomic random walk where the randomly selected v and j genes have to appear at each edge).\n             The more sequences are generated by a particular LZGraph the more dead ends will be found, the quicker\n             the sequences will be generated.\n             n_subpatterns (int):  The total number of sequences used to construct the LZGraph.\n             initial_states (dict): A dictionary containing all initial state and the number of time each one of them\n             was observed.\n             terminal_states (dict): A dictionary containing all terminal state and the number of time each one of them\n             was observed.\n             initial_states_probability (pd.Series): A pandas series containing the normalized counts of the initial\n             states.\n             lengths (dict): a dictionary that maps the different observed sequences length to the number of time\n             that length has been observed.\n             cac_graphs (dict): This is dictionary used to keep different sub-graphs based on the condition in the\n             key, currently deprecated.\n             n_transitions (int): The total number of transition observed while constructing the graph.\n             n_neighbours (dict): Keep track of the number of neighbours given a certain condition in the key.\n             currently deprecated.\n             length_distribution_proba (pd.Series): A pandas series mapping sequence length to a probability value\n             based on the sequence used to construct the LZGraph.\n             subpattern_individual_probability (pd.Series): A pandas series mapping the different graph nodes to the\n             emperical probability of observing that specific node independent of the graph structure.\n\n\n         \"\"\"\n    def __init__(self):\n        # start time of constructor\n        self.constructor_start_time = time()\n        # create graph\n        self.graph = nx.DiGraph()\n        # check for V and J gene data in input\n        self.genetic = False\n        # a list of invalid genetic walks\n        self.genetic_walks_black_list = {}\n        # total number of sub-patterns\n        self.n_subpatterns = 0\n\n        self.initial_states, self.terminal_states = dict(), dict()\n        self.initial_states_probability = pd.Series()\n        self.lengths = dict()\n        self.cac_graphs = dict()\n        self.n_transitions = 0\n        self.n_neighbours = dict()\n        self.length_distribution_proba = pd.Series()\n        self.subpattern_individual_probability = pd.Series()\n        # per node observed frequency for unity operation\n        self.per_node_observed_frequency = dict()\n\n    def __eq__(self, other):\n        \"\"\" This method test whether two LZGraph are equal, i.e. have the same node,edges and metadata on the edges.\n                                    Returns:\n                                        bool: True if graph equal else False\n          \"\"\"\n        if nx.utils.graphs_equal(self.graph, other.graph):\n            aux = 0\n            aux += self.genetic_walks_black_list != other.genetic_walks_black_list\n            aux += self.n_subpatterns != other.n_subpatterns\n            aux += not self.initial_states.round(3).equals(other.initial_states.round(3))\n            aux += not self.terminal_states.round(3).equals(other.terminal_states.round(3))\n\n            # test marginal_vgenes\n            aux += not other.marginal_vgenes.round(3).equals(self.marginal_vgenes.round(3))\n\n            # test vj_probabilities\n            aux += not other.vj_probabilities.round(3).equals(self.vj_probabilities.round(3))\n\n            # test length_distribution\n            aux += not other.length_distribution.round(3).equals(self.length_distribution.round(3))\n\n            # test final_state\n            aux += not other.terminal_states.round(3).equals(self.terminal_states.round(3))\n\n            # test length_distribution_proba\n            aux += not other.length_distribution_proba.round(3).equals(self.length_distribution_proba.round(3))\n\n            if aux == 0:\n                return True\n            else:\n                return False\n\n        else:\n            return False\n\n    @staticmethod\n    def encode_sequence(sequence):\n        \"\"\"\n          This method is abstract, when creating a new LZGraph class, one should override this method with a method\n          that process a sequence of symbols (nucleotides/amino acids) and return a list of string where each\n          string represents a node in the graph. note that it is implied that each pair of sequential string in the\n          returned list are connect by an edge.\n\n                  Args:\n                          sequence (str): a string from which to derive sub-patterns\n\n                  Returns:\n                          list : a list of unique sub-patterns\n       \"\"\"\n        raise NotImplementedError\n\n    @staticmethod\n    def clean_node(base):\n        \"\"\"\n          given a sub-pattern that has reading frame and position added to it, cleans it and returns\n          only the nucleotides from the string\n\n                  Args:\n                          base (str): a node from the NDPLZGraph\n\n                  Returns:\n                          str : only the nucleotides of the node\n     \"\"\"\n        return re.search(r'[ATGC]*', base).group()\n\n    def _decomposed_sequence_generator(self,data):\n        \"\"\"\n           This abstract method should be overwritten in any LZGraph class inheriting this baseclass,\n           this method should return a generator that will take all the data provided to the constractor and\n           yield the relevant node and edge data each time it is called to be added to graph.\n\n                   Args:\n                           data (pd.DataFrame): a pandas Dataframe containing all information relevant for the\n                           construction of an LZGraph (sequences / genomic data etc).\n\n                   Returns:\n                           generator : a generator the yield the information needed to add nodes and edges to the graph\n                           attribute.\n      \"\"\"\n        raise NotImplementedError\n\n    def _simultaneous_graph_construction(self, data):\n        \"\"\"\n                  This method leverage the generator implemented in _decomposed_sequence_generator\n                  in order to iterate over the information returned by the generator and each iteration insert\n                  the node and edge data into the networkx DiGraph and embed and genetic information provided.\n\n                          Args:\n                                  data (pd.DataFrame): a pandas Dataframe containing all information relevant for the\n                                  construction of an LZGraph (sequences / genomic data etc).\n\n                          Returns:\n                                  None\n             \"\"\"\n        processing_stream = self._decomposed_sequence_generator(data)\n        if self.genetic:\n            for output in processing_stream:\n                steps, locations,v,j = output\n\n                for (A, B), (loc_a, loc_b) in zip(steps, locations):\n                    A_ = A + '_' + str(loc_a)\n                    self.per_node_observed_frequency[A_] = self.per_node_observed_frequency.get(A_, 0) + 1\n                    B_ = B + '_' + str(loc_b)\n                    self._insert_edge_and_information(A_, B_, v, j)\n                self.per_node_observed_frequency[B_] = self.per_node_observed_frequency.get(B_, 0)\n        else:\n\n            for output in processing_stream:\n                steps, locations = output\n                for (A, B), (loc_a, loc_b) in zip(steps, locations):\n                    A_ = A + '_' + str(loc_a)\n                    self.per_node_observed_frequency[A_] = self.per_node_observed_frequency.get(A_, 0) + 1\n                    B_ = B + '_' + str(loc_b)\n                    self._insert_edge_and_information_no_genes(A_, B_)\n                self.per_node_observed_frequency[B_] = self.per_node_observed_frequency.get(B_, 0)\n\n\n    def _normalize_edge_weights(self):\n        \"\"\"\n             This method iterates over all the edges in the graph, normalizing edge edgre by the total number\n             of observed edges at the source node of that edge. the resulting graph will contain nodes that the sum\n             of weights for all edges expanding fit that node sum to 1.\n            \"\"\"\n        for edge_a, edge_b in self.graph.edges:\n            node_observed_total = self.per_node_observed_frequency[edge_a]\n            self.graph[edge_a][edge_b]['weight'] /= node_observed_total\n\n    def _get_node_info_df(self, node_a, V=None, J=None, condition='and'):\n        \"\"\"\n           This method returns a dataframe containing the information encoded in each edge spaning from a given node,\n           the indecies of the dataframe are the edges and the column are the different attributes.\n\n                   Args:\n                           node_a (str): a string matching a node in the graph\n                           V (str): optional, if provided together with J this can be used to filter out node edges\n                           J (str): optional, if provided together with V this can be used to filter out node edges\n                           condition (str):optional, one of the values = (\"and\"/\"or\"), based on the value the function\n                           will return the edges of the given node that have information for V and J (the other\n                           two parameters passed) or for edge containing V or J/\n\n                   Returns:\n                           pd.DataFrame : a DataFrame containing all edges and their metadata for a specific node.\n            \"\"\"\n        if V is None or J is None:\n            return pd.DataFrame(dict(self.graph[node_a]))\n        else:\n            node_data = self.graph[node_a]\n            if condition == 'and':\n                partial_dict = {pk: node_data[pk] for pk in node_data if V in node_data[pk] and J in node_data[pk]}\n            else:\n                partial_dict = {pk: node_data[pk] for pk in node_data if V in node_data[pk] or J in node_data[pk]}\n            return pd.DataFrame(partial_dict)\n\n    def _get_node_feature_info_df(self, node_a, feature, V=None, J=None, asdict=False):\n        if V is None or J is None:\n            return pd.DataFrame(dict(self.graph[node_a]))\n        else:\n            node_data = self.graph[node_a]\n            partial_dict = {pk: {feature: node_data[pk][feature]} for pk in node_data \\\n                            if V in node_data[pk] and J in node_data[pk]}\n            if asdict:\n                return partial_dict\n            else:\n                return pd.DataFrame(partial_dict)\n\n    def is_stop_condition(self, state, selected_v=None, selected_j=None):\n        if state not in self.terminal_states:\n            return False\n        if self.genetic:\n            if selected_j is not None:\n                # edge_info = self._get_node_info_df(state, selected_v, selected_j,condition='or')\n                edge_info = dict(self.graph[state])  # pd.DataFrame()\n                observed_gene_paths = set(get_dictionary_subkeys(edge_info))\n                if len(set(observed_gene_paths) &amp; {selected_v, selected_j}) != 2:\n                    neighbours = 0\n                else:\n                    neighbours = 2\n            else:\n                neighbours = self.graph.out_degree(state)\n            if (neighbours) == 0:\n                return True\n            else:\n                stop_probability = self.terminal_state_data.loc[state, 'wsif/sep']\n                decision = np.random.binomial(1, stop_probability) == 1\n                return decision\n        else:\n            stop_probability = self.terminal_state_data.loc[state, 'wsif/sep']\n            decision = np.random.binomial(1, stop_probability) == 1\n            return decision\n\n    def genomic_random_walk(self, initial_state=None, vj_init='marginal'):\n        \"\"\"\n             given a target sequence length and an initial state, the function will select a random\n             V and a random J genes from the observed gene frequency in the graph's \"Training data\" and\n             generate a walk on the graph from the initial state to a terminal state while making sure\n             at each step that both the selected V and J genes were seen used by that specific sub-pattern.\n\n             if seq_len is equal to \"unsupervised\" than a random seq len will be returned\n        \"\"\"\n        self._raise_genetic_mode_error()\n        selected_v, selected_j = self._select_random_vj_genes(vj_init)\n\n        if initial_state is None:\n            current_state = self._random_initial_state()\n            walk = [current_state]\n        else:\n            current_state = initial_state\n            walk = [initial_state]\n\n        # while the walk is not in a valid final state\n        while not self.is_stop_condition(current_state, selected_v, selected_j):\n            # get the node_data for the current state\n            edge_info = self._get_node_feature_info_df(current_state, 'weight', selected_v, selected_j, asdict=True)\n\n            if (current_state, selected_v, selected_j) in self.genetic_walks_black_list:\n                for col in self.genetic_walks_black_list[(current_state, selected_v, selected_j)]:\n                    edge_info.pop(col)\n                # edge_info = edge_info.drop(\n                #     columns=self.genetic_walks_black_list[(current_state, selected_v, selected_j)])\n            # check selected path has genes\n            if len(edge_info) == 0:\n                if len(walk) &gt; 2:\n                    self.genetic_walks_black_list[(walk[-2], selected_v, selected_j)] \\\n                        = self.genetic_walks_black_list.get((walk[-2], selected_v, selected_j),\n                                                            []) + [walk[-1]]\n                    current_state = walk[-2]\n                    walk = walk[:-1]\n                else:\n                    walk = walk[:1]\n                    current_state = walk[0]\n                    selected_v, selected_j = self._select_random_vj_genes(vj_init)\n\n                continue\n\n            w = np.array([edge_info[i]['weight'] for i in edge_info])\n            w = w / w.sum()\n            current_state = choice([*edge_info], w)\n            walk.append(current_state)\n\n        return walk, selected_v, selected_j\n\n    def random_walk(self, initial_state=None, vj_init='marginal'):\n        if initial_state is None:\n            current_state = self._random_initial_state()\n            walk = [current_state]\n        else:\n            current_state = initial_state\n            walk = [initial_state]\n\n        # while the walk is not in a valid final state\n        while not self.is_stop_condition(current_state):\n            # get the node_data for the current state\n            edge_info = self._get_node_feature_info_df(current_state, 'weight', asdict=True)\n\n            if (current_state) in self.genetic_walks_black_list:\n                for col in self.genetic_walks_black_list[(current_state)]:\n                    edge_info.pop(col)\n                # edge_info = edge_info.drop(\n                #     columns=self.genetic_walks_black_list[(current_state, selected_v, selected_j)])\n            # check selected path has genes\n            if len(edge_info) == 0:\n                if len(walk) &gt; 2:\n                    self.genetic_walks_black_list[(walk[-2])] \\\n                        = self.genetic_walks_black_list.get((walk[-2]),\n                                                            []) + [walk[-1]]\n                    current_state = walk[-2]\n                    walk = walk[:-1]\n                else:\n                    walk = walk[:1]\n                    current_state = walk[0]\n                    selected_v, selected_j = self._select_random_vj_genes(vj_init)\n\n                continue\n\n            w = np.array([edge_info[i]['weight'] for i in edge_info])\n            w = w / w.sum()\n            current_state = choice([*edge_info], w)\n            walk.append(current_state)\n\n        return walk\n\n    def _derive_subpattern_individual_probability(self):\n        weight_df = pd.Series(nx.get_edge_attributes(self.graph, 'weight')).reset_index()\n        self.subpattern_individual_probability = weight_df.groupby('level_0').sum().rename(columns={0: 'proba'})\n        self.subpattern_individual_probability.proba /= self.subpattern_individual_probability.proba.sum()\n\n    def verbose_driver(self, message_number, verbose):\n        if not verbose:\n            return None\n\n        if message_number == -2:\n            print(\"===\" * 10)\n            print('\\n')\n        elif message_number == 0:\n            CT = round(time() - self.constructor_start_time, 2)\n            print(\"Gene Information Loaded..\", '| ', CT, ' Seconds')\n        elif message_number == 1:\n            CT = round(time() - self.constructor_start_time, 2)\n            print(\"Graph Constructed..\", '| ', CT, ' Seconds')\n        elif message_number == 2:\n            CT = round(time() - self.constructor_start_time, 2)\n            print(\"Graph Metadata Derived..\", '| ', CT, ' Seconds')\n        elif message_number == 3:\n            CT = round(time() - self.constructor_start_time, 2)\n            print(\"Graph Edge Weight Normalized..\", '| ', CT, ' Seconds')\n        elif message_number == 4:\n            CT = round(time() - self.constructor_start_time, 2)\n            print(\"Graph Edge Gene Weights Normalized..\", '| ', CT, ' Seconds')\n        elif message_number == 5:\n            CT = round(time() - self.constructor_start_time, 2)\n            print(\"Terminal State Map Derived..\", '| ', CT, ' Seconds')\n        elif message_number == 6:\n            CT = round(self.constructor_end_time - self.constructor_start_time, 2)\n            print(\"LZGraph Created Successfully..\", '| ', CT, ' Seconds')\n        elif message_number == 7:\n            CT = round(time() - self.constructor_start_time, 2)\n            print(\"Terminal State Map Derived..\", '| ', CT, ' Seconds')\n        elif message_number == 8:\n            CT = round(time() - self.constructor_start_time, 2)\n            print(\"Individual Subpattern Empirical Probability Derived..\", '| ', CT, ' Seconds')\n        elif message_number == 9:\n            CT = round(time() - self.constructor_start_time, 2)\n            print(\"Terminal State Conditional Probabilities Map Derived..\", '| ', CT, ' Seconds')\n\n    def random_step(self, state):\n        \"\"\"\n           Given the current state, pick and take a random step based on the translation probabilities\n           :param state:\n           :return:\n                       \"\"\"\n        states, probabilities = self._get_state_weights(state)\n        return choice(states, probabilities)\n\n    def _random_initial_state(self):\n        \"\"\"\n       Select a random initial state based on the marginal distribution of initial states.\n       :return:\n       \"\"\"\n        return choice(self.initial_states_probability.index, self.initial_states_probability.values)\n\n    def _select_random_vj_genes(self, type='marginal'):\n        self._raise_genetic_mode_error()\n        if type == 'marginal':\n            V = choice(self.marginal_vgenes.index, self.marginal_vgenes.values)\n            J = choice(self.marginal_jgenes.index, self.marginal_jgenes.values)\n            return V, J\n        elif type == 'combined':\n            VJ = choice(self.vj_probabilities.index, self.vj_probabilities.values)\n            V, J = VJ.split('_')\n            return V, J\n\n    def _insert_edge_and_information(self, A_, B_, Vgene, Jgene):\n        # if self.graph.has_edge(A_, B_):\n        try:  # assuming edge exists\n            edge_pointer = self.graph[A_][B_]\n            edge_pointer[\"weight\"] += 1\n            edge_pointer[Vgene] = edge_pointer.get(Vgene, 0) + 1\n            edge_pointer[Jgene] = edge_pointer.get(Jgene, 0) + 1\n            edge_pointer['Vsum'] += 1\n            edge_pointer['Jsum'] += 1\n        except KeyError as e:  # edge not fount\n            attr = {'weight': 1, 'Vsum': 1, 'Jsum': 1}\n            attr[Vgene] = 1\n            attr[Jgene] = 1\n            self.graph.add_edge(A_, B_, **attr)\n\n        self.n_transitions += 1\n\n    def _insert_edge_and_information_no_genes(self, A_, B_):\n        if self.graph.has_edge(A_, B_):\n            self.graph[A_][B_][\"weight\"] += 1\n        else:\n            self.graph.add_edge(A_, B_, weight=1)\n        self.n_transitions += 1\n\n    def _get_state_weights(self, node, v=None, j=None):\n        \"\"\"\n        Given a node, return all the possible translation from that node and their respective weights\n        :param node:\n        :param v:\n        :param j:\n        :return:\n                    \"\"\"\n        if v is None and j is None:\n            node_data = self.graph[node]\n            states = list(node_data.keys())\n            probabilities = [node_data[i]['weight'] for i in states]\n            return states, probabilities\n        else:\n            return pd.DataFrame(dict(self.graph[node])).T\n\n    def _batch_gene_weight_normalization(self, n_process=3, verbose=False):\n        batches = chunkify(list(self.graph.edges), len(self.graph.edges) // 3)\n        pool = ThreadPool(n_process)\n        pool.map(self._normalize_gene_weights, list(batches))\n        # self.normalize_gene_weights(self.graph.edges)\n\n    def _normalize_gene_weights(self, edge_list):\n        for n_a, n_b in (edge_list):\n            e_data = self.graph.get_edge_data(n_a, n_b)\n            vsum = e_data['Vsum']\n            jsum = e_data['Jsum']\n            genes = set(e_data) - {'Vsum', 'Jsum', 'weight'}\n\n            for key in genes:\n                if 'V' in key:\n                    self.graph[n_a][n_b][key] /= vsum\n                else:\n                    self.graph[n_a][n_b][key] /= jsum\n\n    def _update_terminal_states(self, terminal_state):\n        self.terminal_states[terminal_state] = self.terminal_states.get(terminal_state, 0) + 1\n\n    def _update_initial_states(self, initial_state):\n        self.initial_states[initial_state] = self.initial_states.get(initial_state, 0) + 1\n\n    def _load_gene_data(self, data):\n        self.observed_vgenes = list(set(data['V']))\n        self.observed_jgenes = list(set(data['J']))\n\n        self.marginal_vgenes = data['V'].value_counts()\n        self.marginal_jgenes = data['J'].value_counts()\n        self.marginal_vgenes /= self.marginal_vgenes.sum()\n        self.marginal_jgenes /= self.marginal_jgenes.sum()\n\n        self.vj_probabilities = (data['V'] + '_' + data['J']).value_counts()\n        self.vj_probabilities /= self.vj_probabilities.sum()\n\n    def _derive_terminal_state_map(self):\n        \"\"\"\n        create a matrix map between all terminal state,\n        given that we have  K terminal states, the matrix will be of dim KxK\n        where at each row reachability will be denoted by 1, i.e\n        if I can reach e  state K_i from state k, the value at K[k][K_i] = 1\n        :return:\n        \"\"\"\n        terminal_state_map = np.zeros((len(self.terminal_states), len(self.terminal_states)))\n        ts_index = {i: ax for ax, i in enumerate(self.terminal_states.index)}\n\n        for pos_1, terminal_1 in enumerate(self.terminal_states.index):\n            dfs_node = list(nx.dfs_preorder_nodes(self.graph, source=terminal_1))\n            # for pos_2, terminal_2 in enumerate(self.terminal_states.index):\n            #     terminal_state_map[pos_1][pos_2] = nx.has_path(self.graph, source=terminal_1, target=terminal_2)\n            reachable_terminal_state = set(dfs_node) &amp; set(self.terminal_states.index)\n            for node in reachable_terminal_state:\n                terminal_state_map[pos_1][ts_index[node]] = 1\n\n        terminal_state_map = pd.DataFrame(terminal_state_map,\n                                          columns=self.terminal_states.index,\n                                          index=self.terminal_states.index).apply(\n            lambda x: x.apply(lambda y: x.name if y == 1 else np.nan), axis=0)\n        # np.fill_diagonal(terminal_state_map.values, np.nan)\n\n        self.terminal_state_map = pd.Series(terminal_state_map.apply(lambda x: (x.dropna().to_list()), axis=1),\n                                            index=self.terminal_states.index)\n\n    def _derive_stop_probability_data(self):\n        def freq_normalize(target):\n            # all possible alternative future terminal states from current state\n            D = self.length_distribution_proba.loc[target].copy()\n            # normalize observed frequencey\n            D /= D.sum()\n            return D\n\n        def wont_stop_at_future_states(state, es):\n            D = freq_normalize(es.decendent_end_states[state])\n            # remove current state\n            current_freq = D.pop(state)\n            if len(D) &gt;= 1:\n                D = 1 - D\n                return D.product()\n            else:\n                return 1\n\n        def didnt_stop_at_past(state, es):\n            # all possible alternative future terminal states from current state\n            D = freq_normalize(es.ancestor_end_state[state])\n            # remove current state\n            if state in D:\n                D.pop(state)\n            if len(D) &gt;= 1:\n                D = 1 - D\n                return D.product()\n            else:\n                return 1\n\n        es = self.terminal_state_map.to_frame().rename(columns={0: 'decendent_end_states'})\n        es['n_alternative'] = es['decendent_end_states'].apply(lambda x: len(x) - 1)\n        es['end_freq'] = self.length_distribution_proba\n        es['wont_stop_in_future'] = 0\n        es['wont_stop_in_future'] = es.index.to_series().apply(lambda x: wont_stop_at_future_states(x, es))\n\n        es['state_end_proba'] = es.index.to_series().apply(lambda x: freq_normalize(es.decendent_end_states[x])[x])\n        es['ancestor_end_state'] = es.index.to_series() \\\n            .apply(\n            lambda x: list(set([ax for ax, i in zip(es.index, es['decendent_end_states']) if x in i])))\n\n        es['state_end_proba_ancestor'] = es.index.to_series().apply(\n            lambda x: freq_normalize(es.ancestor_end_state[x])[x])\n\n        es['didnt_stop_at_past'] = 1\n        es['didnt_stop_at_past'] = es.index.to_series().apply(lambda x: didnt_stop_at_past(x, es))\n        # state end freq normalized by wont stop in future\n\n        es['wsif/sep'] = es['state_end_proba'] / es['wont_stop_in_future']\n        es.loc[es['wsif/sep'] &gt;= 1, 'wsif/sep'] = 1\n\n        # ancestor and decendent product\n        # es['normalized'] = (es['state_end_proba']*es['state_end_proba_ancestor']) / (es['wont_stop_in_future']*es['didnt_stop_at_past'])\n\n        self.terminal_state_data = es\n\n    def _length_specific_terminal_state(self, length):\n\n        return self.terminal_states[\n            self.terminal_states.index.to_series().str.split('_').apply(lambda x: int(x[-1])) == length].index.to_list()\n\n    def _max_sum_gene_prediction(self, walk, top_n=1):\n        v_gene_agg = dict()\n        j_gene_agg = dict()\n        for i in range(0, len(walk) - 1):\n            if self.graph.has_edge(walk[i], walk[i + 1]):\n                ls = self.graph.get_edge_data(walk[i], walk[i + 1]).copy()\n                for key in {*ls} - {'weight', 'Vsum', 'Jsum'}:\n                    if 'V' in key:\n                        v_gene_agg[key] = v_gene_agg.get(key, 0) + ls[key]\n                    else:\n                        j_gene_agg[key] = j_gene_agg.get(key, 0) + ls[key]\n\n        if top_n == 1:\n            return max(v_gene_agg, key=v_gene_agg.get), max(j_gene_agg, key=j_gene_agg.get)\n        else:\n            vs = {k for k in heapq.nlargest(top_n, v_gene_agg, key=lambda k: v_gene_agg[k])}\n            js = {k for k in heapq.nlargest(top_n, j_gene_agg, key=lambda k: j_gene_agg[k])}\n            return vs, js\n\n    def _max_product_gene_prediction(self, walk, top_n=1):\n        v_gene_agg = dict()\n        j_gene_agg = dict()\n        for i in range(0, len(walk) - 1):\n            if self.graph.has_edge(walk[i], walk[i + 1]):\n                ls = self.graph.get_edge_data(walk[i], walk[i + 1]).copy()\n                for key in {*ls} - {'weight', 'Vsum', 'Jsum'}:\n                    if 'V' in key:\n                        v_gene_agg[key] = v_gene_agg.get(key, 1) * ls[key]\n                    else:\n                        j_gene_agg[key] = j_gene_agg.get(key, 1) * ls[key]\n\n        if top_n == 1:\n            return max(v_gene_agg, key=v_gene_agg.get), max(j_gene_agg, key=j_gene_agg.get)\n\n        else:\n            vs = {k for k in heapq.nlargest(top_n, v_gene_agg, key=lambda k: v_gene_agg[k])}\n            js = {k for k in heapq.nlargest(top_n, j_gene_agg, key=lambda k: j_gene_agg[k])}\n            return vs, js\n\n    def _sampling_gene_prediction(self, walk, top_n=1):\n        V = []\n        J = []\n        for i in range(0, len(walk) - 1):\n            if self.graph.has_edge(walk[i], walk[i + 1]):\n                ls = self.graph.get_edge_data(walk[i], walk[i + 1]).copy()\n                vkeys = dict()\n                jkeys = dict()\n                for k in ls:\n                    if k not in {'weight', 'Vsum', 'Jsum'}:\n                        if 'V' in k:\n                            vkeys[k] = ls[k]\n                        else:\n                            jkeys[k] = ls[k]\n\n                for _ in range(25):\n                    V.append(choice(list(vkeys.keys()), list(vkeys.values())))\n                    J.append(choice(list(jkeys.keys()), list(jkeys.values())))\n        vcounter = Counter(V)\n        jcounter = Counter(J)\n\n        if top_n == 1:\n\n            return vcounter.most_common(1)[0][0], jcounter.most_common(1)[0][0]\n\n\n        else:\n            vs = [i[0] for i in vcounter]\n            js = [i[0] for i in jcounter]\n            return vs, js\n\n    def _full_appearance_gene_prediction(self, walk, alpha=0):\n        vgenes = list()\n        jgenes = list()\n        wl = len(walk) - (1 + alpha)\n        for i in range(0, wl):\n            if self.graph.has_edge(walk[i], walk[i + 1]):\n                ls = self.graph.get_edge_data(walk[i], walk[i + 1]).copy()\n                vgenes += [i for i in ({*ls} - {'weight', 'Vsum', 'Jsum'}) if 'V' in i]\n                jgenes += [i for i in ({*ls} - {'weight', 'Vsum', 'Jsum'}) if 'J' in i]\n\n        vcount = Counter(vgenes)\n        jcount = Counter(vgenes)\n        return [w for w in vcount if vcount[w] == wl], [w for w in jcount if jcount[w] == wl]\n\n    def _raise_genetic_mode_error(self):\n        if not self.genetic:\n            raise Exception('Genomic Data Function Requires Gene Annotation Data, The Graph Has No Such Data')\n\n    def predict_vj_genes(self, walk, top_n=1, mode='max', alpha=0):\n\n        if mode == 'max_sum':\n            return self._max_sum_gene_prediction(walk, top_n=top_n)\n        elif mode == 'max_product':\n            return self._max_product_gene_prediction(walk, top_n=top_n)\n        elif mode == 'sampling':\n            return self._sampling_gene_prediction(walk, top_n=top_n)\n        elif mode == 'full':\n            return self._full_appearance_gene_prediction(walk, alpha)\n\n    def eigenvector_centrality(self,max_iter=500):\n        return nx.algorithms.eigenvector_centrality(self.graph, weight='weight',max_iter=max_iter)\n\n    def isolates(self):\n        \"\"\"\n           A function that returns the list of all isolates in the graph.\n           an isolate is a node that is connected to 0 edges (unseen sub-pattern).\n\n                   Parameters:\n                           None\n\n                   Returns:\n                           list : a list of isolates\n                    \"\"\"\n        return list(nx.isolates(self.graph))\n\n    def drop_isolates(self):\n        \"\"\"\n         A function to drop all isolates from the graph.\n\n                 Parameters:\n                         None\n\n                 Returns:\n                         None\n                  \"\"\"\n        self.graph.remove_nodes_from(self.isolates())\n\n    def is_dag(self):\n        \"\"\"\n           the function checks whether the graph is a Directed acyclic graph\n\n               :return:\n               \"\"\"\n        return nx.is_directed_acyclic_graph(self.graph)\n\n    @property\n    def nodes(self):\n        return self.graph.nodes\n\n    @property\n    def edges(self):\n        return self.graph.edges\n\n    def graph_summary(self):\n        \"\"\"\n                          the function will return a pandas DataFrame containing the graphs\n                            Chromatic Number,Number of Isolates,Max In Deg,Max Out Deg,Number of Edges\n                        \"\"\"\n        R = pd.Series({\n            'Chromatic Number': max(nx.greedy_color(self.graph).values()) + 1,\n            'Number of Isolates': nx.number_of_isolates(self.graph),\n            'Max In Deg': max(dict(self.graph.in_degree).values()),\n            'Max Out Deg': max(dict(self.graph.out_degree).values()),\n            'Number of Edges': len(self.graph.edges),\n        })\n        return R\n\n    def voterank(self, n_nodes=25):\n        \"\"\"\n                         Uses the VoteRank algorithm to return the top N influential nodes in the graph, where N is equal to n_nodes\n\n                                  Parameters:\n                                          n_nodes (int): the number of most influential nodes to find\n\n                                  Returns:\n                                          list : a list of top influential nodes\n                        \"\"\"\n        return nx.algorithms.voterank(self.graph, number_of_nodes=n_nodes)\n</code></pre>"},{"location":"lzgraphbase_reference/#src.LZGraphs.Graphs.LZGraphBase.LZGraphBase.__eq__","title":"<code>__eq__(other)</code>","text":"<p>This method test whether two LZGraph are equal, i.e. have the same node,edges and metadata on the edges. Returns:     bool: True if graph equal else False</p> Source code in <code>src\\LZGraphs\\Graphs\\LZGraphBase.py</code> <pre><code>def __eq__(self, other):\n    \"\"\" This method test whether two LZGraph are equal, i.e. have the same node,edges and metadata on the edges.\n                                Returns:\n                                    bool: True if graph equal else False\n      \"\"\"\n    if nx.utils.graphs_equal(self.graph, other.graph):\n        aux = 0\n        aux += self.genetic_walks_black_list != other.genetic_walks_black_list\n        aux += self.n_subpatterns != other.n_subpatterns\n        aux += not self.initial_states.round(3).equals(other.initial_states.round(3))\n        aux += not self.terminal_states.round(3).equals(other.terminal_states.round(3))\n\n        # test marginal_vgenes\n        aux += not other.marginal_vgenes.round(3).equals(self.marginal_vgenes.round(3))\n\n        # test vj_probabilities\n        aux += not other.vj_probabilities.round(3).equals(self.vj_probabilities.round(3))\n\n        # test length_distribution\n        aux += not other.length_distribution.round(3).equals(self.length_distribution.round(3))\n\n        # test final_state\n        aux += not other.terminal_states.round(3).equals(self.terminal_states.round(3))\n\n        # test length_distribution_proba\n        aux += not other.length_distribution_proba.round(3).equals(self.length_distribution_proba.round(3))\n\n        if aux == 0:\n            return True\n        else:\n            return False\n\n    else:\n        return False\n</code></pre>"},{"location":"lzgraphbase_reference/#src.LZGraphs.Graphs.LZGraphBase.LZGraphBase.clean_node","title":"<code>clean_node(base)</code>  <code>staticmethod</code>","text":"<p>given a sub-pattern that has reading frame and position added to it, cleans it and returns only the nucleotides from the string</p> <pre><code>    Args:\n            base (str): a node from the NDPLZGraph\n\n    Returns:\n            str : only the nucleotides of the node\n</code></pre> Source code in <code>src\\LZGraphs\\Graphs\\LZGraphBase.py</code> <pre><code>@staticmethod\ndef clean_node(base):\n    \"\"\"\n      given a sub-pattern that has reading frame and position added to it, cleans it and returns\n      only the nucleotides from the string\n\n              Args:\n                      base (str): a node from the NDPLZGraph\n\n              Returns:\n                      str : only the nucleotides of the node\n \"\"\"\n    return re.search(r'[ATGC]*', base).group()\n</code></pre>"},{"location":"lzgraphbase_reference/#src.LZGraphs.Graphs.LZGraphBase.LZGraphBase.drop_isolates","title":"<code>drop_isolates()</code>","text":"<p>A function to drop all isolates from the graph.</p> <pre><code>    Parameters:\n            None\n\n    Returns:\n            None\n</code></pre> Source code in <code>src\\LZGraphs\\Graphs\\LZGraphBase.py</code> <pre><code>def drop_isolates(self):\n    \"\"\"\n     A function to drop all isolates from the graph.\n\n             Parameters:\n                     None\n\n             Returns:\n                     None\n              \"\"\"\n    self.graph.remove_nodes_from(self.isolates())\n</code></pre>"},{"location":"lzgraphbase_reference/#src.LZGraphs.Graphs.LZGraphBase.LZGraphBase.encode_sequence","title":"<code>encode_sequence(sequence)</code>  <code>staticmethod</code>","text":"<p>This method is abstract, when creating a new LZGraph class, one should override this method with a method that process a sequence of symbols (nucleotides/amino acids) and return a list of string where each string represents a node in the graph. note that it is implied that each pair of sequential string in the returned list are connect by an edge.</p> <pre><code>    Args:\n            sequence (str): a string from which to derive sub-patterns\n\n    Returns:\n            list : a list of unique sub-patterns\n</code></pre> Source code in <code>src\\LZGraphs\\Graphs\\LZGraphBase.py</code> <pre><code>@staticmethod\ndef encode_sequence(sequence):\n    \"\"\"\n      This method is abstract, when creating a new LZGraph class, one should override this method with a method\n      that process a sequence of symbols (nucleotides/amino acids) and return a list of string where each\n      string represents a node in the graph. note that it is implied that each pair of sequential string in the\n      returned list are connect by an edge.\n\n              Args:\n                      sequence (str): a string from which to derive sub-patterns\n\n              Returns:\n                      list : a list of unique sub-patterns\n   \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"lzgraphbase_reference/#src.LZGraphs.Graphs.LZGraphBase.LZGraphBase.genomic_random_walk","title":"<code>genomic_random_walk(initial_state=None, vj_init='marginal')</code>","text":"<p>given a target sequence length and an initial state, the function will select a random V and a random J genes from the observed gene frequency in the graph's \"Training data\" and generate a walk on the graph from the initial state to a terminal state while making sure at each step that both the selected V and J genes were seen used by that specific sub-pattern.</p> <p>if seq_len is equal to \"unsupervised\" than a random seq len will be returned</p> Source code in <code>src\\LZGraphs\\Graphs\\LZGraphBase.py</code> <pre><code>def genomic_random_walk(self, initial_state=None, vj_init='marginal'):\n    \"\"\"\n         given a target sequence length and an initial state, the function will select a random\n         V and a random J genes from the observed gene frequency in the graph's \"Training data\" and\n         generate a walk on the graph from the initial state to a terminal state while making sure\n         at each step that both the selected V and J genes were seen used by that specific sub-pattern.\n\n         if seq_len is equal to \"unsupervised\" than a random seq len will be returned\n    \"\"\"\n    self._raise_genetic_mode_error()\n    selected_v, selected_j = self._select_random_vj_genes(vj_init)\n\n    if initial_state is None:\n        current_state = self._random_initial_state()\n        walk = [current_state]\n    else:\n        current_state = initial_state\n        walk = [initial_state]\n\n    # while the walk is not in a valid final state\n    while not self.is_stop_condition(current_state, selected_v, selected_j):\n        # get the node_data for the current state\n        edge_info = self._get_node_feature_info_df(current_state, 'weight', selected_v, selected_j, asdict=True)\n\n        if (current_state, selected_v, selected_j) in self.genetic_walks_black_list:\n            for col in self.genetic_walks_black_list[(current_state, selected_v, selected_j)]:\n                edge_info.pop(col)\n            # edge_info = edge_info.drop(\n            #     columns=self.genetic_walks_black_list[(current_state, selected_v, selected_j)])\n        # check selected path has genes\n        if len(edge_info) == 0:\n            if len(walk) &gt; 2:\n                self.genetic_walks_black_list[(walk[-2], selected_v, selected_j)] \\\n                    = self.genetic_walks_black_list.get((walk[-2], selected_v, selected_j),\n                                                        []) + [walk[-1]]\n                current_state = walk[-2]\n                walk = walk[:-1]\n            else:\n                walk = walk[:1]\n                current_state = walk[0]\n                selected_v, selected_j = self._select_random_vj_genes(vj_init)\n\n            continue\n\n        w = np.array([edge_info[i]['weight'] for i in edge_info])\n        w = w / w.sum()\n        current_state = choice([*edge_info], w)\n        walk.append(current_state)\n\n    return walk, selected_v, selected_j\n</code></pre>"},{"location":"lzgraphbase_reference/#src.LZGraphs.Graphs.LZGraphBase.LZGraphBase.graph_summary","title":"<code>graph_summary()</code>","text":"<p>the function will return a pandas DataFrame containing the graphs   Chromatic Number,Number of Isolates,Max In Deg,Max Out Deg,Number of Edges</p> Source code in <code>src\\LZGraphs\\Graphs\\LZGraphBase.py</code> <pre><code>def graph_summary(self):\n    \"\"\"\n                      the function will return a pandas DataFrame containing the graphs\n                        Chromatic Number,Number of Isolates,Max In Deg,Max Out Deg,Number of Edges\n                    \"\"\"\n    R = pd.Series({\n        'Chromatic Number': max(nx.greedy_color(self.graph).values()) + 1,\n        'Number of Isolates': nx.number_of_isolates(self.graph),\n        'Max In Deg': max(dict(self.graph.in_degree).values()),\n        'Max Out Deg': max(dict(self.graph.out_degree).values()),\n        'Number of Edges': len(self.graph.edges),\n    })\n    return R\n</code></pre>"},{"location":"lzgraphbase_reference/#src.LZGraphs.Graphs.LZGraphBase.LZGraphBase.is_dag","title":"<code>is_dag()</code>","text":"<p>the function checks whether the graph is a Directed acyclic graph</p> <pre><code>:return:\n</code></pre> Source code in <code>src\\LZGraphs\\Graphs\\LZGraphBase.py</code> <pre><code>def is_dag(self):\n    \"\"\"\n       the function checks whether the graph is a Directed acyclic graph\n\n           :return:\n           \"\"\"\n    return nx.is_directed_acyclic_graph(self.graph)\n</code></pre>"},{"location":"lzgraphbase_reference/#src.LZGraphs.Graphs.LZGraphBase.LZGraphBase.isolates","title":"<code>isolates()</code>","text":"<p>A function that returns the list of all isolates in the graph. an isolate is a node that is connected to 0 edges (unseen sub-pattern).</p> <pre><code>    Parameters:\n            None\n\n    Returns:\n            list : a list of isolates\n</code></pre> Source code in <code>src\\LZGraphs\\Graphs\\LZGraphBase.py</code> <pre><code>def isolates(self):\n    \"\"\"\n       A function that returns the list of all isolates in the graph.\n       an isolate is a node that is connected to 0 edges (unseen sub-pattern).\n\n               Parameters:\n                       None\n\n               Returns:\n                       list : a list of isolates\n                \"\"\"\n    return list(nx.isolates(self.graph))\n</code></pre>"},{"location":"lzgraphbase_reference/#src.LZGraphs.Graphs.LZGraphBase.LZGraphBase.random_step","title":"<code>random_step(state)</code>","text":"<p>Given the current state, pick and take a random step based on the translation probabilities :param state: :return:</p> Source code in <code>src\\LZGraphs\\Graphs\\LZGraphBase.py</code> <pre><code>def random_step(self, state):\n    \"\"\"\n       Given the current state, pick and take a random step based on the translation probabilities\n       :param state:\n       :return:\n                   \"\"\"\n    states, probabilities = self._get_state_weights(state)\n    return choice(states, probabilities)\n</code></pre>"},{"location":"lzgraphbase_reference/#src.LZGraphs.Graphs.LZGraphBase.LZGraphBase.voterank","title":"<code>voterank(n_nodes=25)</code>","text":"<p>Uses the VoteRank algorithm to return the top N influential nodes in the graph, where N is equal to n_nodes</p> <pre><code>     Parameters:\n             n_nodes (int): the number of most influential nodes to find\n\n     Returns:\n             list : a list of top influential nodes\n</code></pre> Source code in <code>src\\LZGraphs\\Graphs\\LZGraphBase.py</code> <pre><code>def voterank(self, n_nodes=25):\n    \"\"\"\n                     Uses the VoteRank algorithm to return the top N influential nodes in the graph, where N is equal to n_nodes\n\n                              Parameters:\n                                      n_nodes (int): the number of most influential nodes to find\n\n                              Returns:\n                                      list : a list of top influential nodes\n                    \"\"\"\n    return nx.algorithms.voterank(self.graph, number_of_nodes=n_nodes)\n</code></pre>"},{"location":"metrics_reference/","title":"LZ Metrics","text":""},{"location":"metrics_reference/#src.LZGraphs.Metircs.Metrics.K1000_Diversity","title":"<code>K1000_Diversity(list_of_sequences, lzgraph_encoding_function, draws=25)</code>","text":"<p>Calculates the K1000 Diversity index of a list of CDR3 sequences based on the provided LZGraph encoding function.</p> <p>Parameters:</p> Name Type Description Default <code>list_of_sequences</code> <code>list</code> <p>A list of CDR3 sequences.</p> required <code>lzgraph_encoding_function</code> <code>function</code> <p>The LZGraph encoding function to be used. (e.g., AAPLZGraph.encode_sequence)</p> required <code>draws</code> <code>int</code> <p>The number of draws for the resampling test. Defaults to 25.</p> <code>25</code> <p>Returns:</p> Name Type Description <code>float</code> <p>The average K1000 Diversity index calculated from the resampling tests.</p> <p>The K1000 Diversity index is computed by resampling the list of sequences and building LZGraphs based on the provided encoding function. The resampling is performed <code>draws</code> number of times, with each resampled set containing 1000 unique sequences. For each resampled set, the K1000 Diversity index is calculated using the 'nodes' value of the last item in the result dictionary obtained from the NodeEdgeSaturationProbe's resampling test. The average K1000 Diversity index from all the resampling tests is then returned using <code>np.mean</code>.</p> Example <p>sequences = [\"ACGT\", \"CGTA\", \"GTAC\"] encoding_function = NDPLZGraph.encode_sequence diversity = K1000_diversity(sequences, encoding_function, draws=30) print(diversity)</p> Source code in <code>src\\LZGraphs\\Metircs\\Metrics.py</code> <pre><code>def K1000_Diversity(list_of_sequences,lzgraph_encoding_function,draws=25):\n    \"\"\"\n      Calculates the K1000 Diversity index of a list of CDR3 sequences based on the provided LZGraph encoding function.\n\n      Args:\n          list_of_sequences (list): A list of CDR3 sequences.\n          lzgraph_encoding_function (function): The LZGraph encoding function to be used. (e.g., AAPLZGraph.encode_sequence)\n          draws (int, optional): The number of draws for the resampling test. Defaults to 25.\n\n      Returns:\n          float: The average K1000 Diversity index calculated from the resampling tests.\n\n      The K1000 Diversity index is computed by resampling the list of sequences and building LZGraphs based on the provided\n      encoding function. The resampling is performed `draws` number of times, with each resampled set containing 1000 unique\n      sequences. For each resampled set, the K1000 Diversity index is calculated using the 'nodes' value of the last item in\n      the result dictionary obtained from the NodeEdgeSaturationProbe's resampling test. The average K1000 Diversity index\n      from all the resampling tests is then returned using `np.mean`.\n\n      Example:\n          &gt;&gt;&gt; sequences = [\"ACGT\", \"CGTA\", \"GTAC\"]\n          &gt;&gt;&gt; encoding_function = NDPLZGraph.encode_sequence\n          &gt;&gt;&gt; diversity = K1000_diversity(sequences, encoding_function, draws=30)\n          &gt;&gt;&gt; print(diversity)\n      \"\"\"\n    # sample 1000 unique sequences\n    NESP = NodeEdgeSaturationProbe(node_function=lzgraph_encoding_function)\n    result = NESP.resampling_test(list(set(list_of_sequences)),n_tests=draws,sample_size=1000)\n    K_tests = [list(i.values())[-1]['nodes'] for i in result]\n    return np.mean(K_tests)\n</code></pre>"},{"location":"metrics_reference/#src.LZGraphs.Metircs.Metrics.LZCentrality","title":"<code>LZCentrality(lzgraph, sequence)</code>","text":"<p>Calculates the LZCentrality of a given CDR3 sequence in a repertoire represented by an LZGraph.</p> <p>Parameters:</p> Name Type Description Default <code>lzgraph</code> <code>LZGraph</code> <p>The LZGraph representing the repertoire.</p> required <code>sequence</code> <code>str</code> <p>The CDR3 sequence for which LZCentrality needs to be calculated.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>The LZCentrality value for the given sequence.</p> <p>Calculates the out degree at each node of the given sequence using the <code>sequence_variation_curve</code> method of the lzgraph object. Missing nodes are penalized by assigning a value of -1. The average of the out degrees is then computed using <code>np.mean</code> and returned.</p> Example <p>graph = NDPLZGraph(Repertoire) sequence = \"ACCGACAGGATTTACGT\" lzcentrality = LZCentrality(graph, sequence) print(lzcentrality)</p> Source code in <code>src\\LZGraphs\\Metircs\\Metrics.py</code> <pre><code>def LZCentrality(lzgraph,sequence):\n    \"\"\"\n    Calculates the LZCentrality of a given CDR3 sequence in a repertoire represented by an LZGraph.\n\n    Args:\n        lzgraph (LZGraph): The LZGraph representing the repertoire.\n        sequence (str): The CDR3 sequence for which LZCentrality needs to be calculated.\n\n    Returns:\n        float: The LZCentrality value for the given sequence.\n\n    Calculates the out degree at each node of the given sequence using the `sequence_variation_curve` method\n    of the lzgraph object. Missing nodes are penalized by assigning a value of -1. The average of the out degrees\n    is then computed using `np.mean` and returned.\n\n    Example:\n       &gt;&gt;&gt; graph = NDPLZGraph(Repertoire)\n       &gt;&gt;&gt; sequence = \"ACCGACAGGATTTACGT\"\n       &gt;&gt;&gt; lzcentrality = LZCentrality(graph, sequence)\n       &gt;&gt;&gt; print(lzcentrality)\n       \"\"\"\n    # calculate out degree at each node of the sequence\n    svc= lzgraph.sequence_variation_curve(sequence)[1]\n    # penalize for missing nodes\n    svc = [-1 if type(i) != int else i for i in svc ]\n    return np.mean(svc)\n</code></pre>"},{"location":"misc_reference/","title":"Misc Functions","text":"<p>Provide support for other library functionality.</p> <p>This module support various other operations in this library, any function with no specific scope appears here.</p> <p>The module contains the following functions:</p> <ul> <li><code>choice(options,probs)</code> - choose a random element from a list given a probability distribution over the elements.</li> <li><code>window(iterable, size)</code> - Return a sliding window generator of size \"size\".</li> <li><code>get_dictionary_subkeys(target)</code> - Returns a list of all sub dictionary keys.</li> <li><code>chunkify(L, n)</code> - Yield successive n-sized chunks from L.</li> </ul>"},{"location":"misc_reference/#src.LZGraphs.Utilities.misc.choice","title":"<code>choice(options, probs)</code>","text":"<p>Choose a single random variable from a list given a probability distribution</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>list</code> <p>The list of values from which a single random one should be chosen</p> required <code>probs</code> <code>float</code> <p>Probability distribution.</p> required <p>Returns:</p> Name Type Description <code>element</code> <p>a random variable from list \"options\" with probability p in probas.</p> Source code in <code>src\\LZGraphs\\Utilities\\misc.py</code> <pre><code>def choice(options,probs):\n    \"\"\"Choose a single random variable from a list given a probability distribution\n\n      Args:\n          options (list): The list of values from which a single random one should be chosen\n          probs (float): Probability distribution.\n\n      Returns:\n          element: a random variable from list \"options\" with probability p in probas.\n      \"\"\"\n    x = np.random.rand()\n    cum = 0\n    i = None\n    for i,p in enumerate(probs):\n        cum += p\n        if x &lt; cum:\n            break\n    return options[i]\n</code></pre>"},{"location":"misc_reference/#src.LZGraphs.Utilities.misc.chunkify","title":"<code>chunkify(L, n)</code>","text":"<p>Yield successive n-sized chunks from L.</p> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>iterable</code> <p>An iterable of elements to partition into n-sized chunks</p> required <p>Returns:     generator: a generator that will return the next chunck each time its called until all of L is returned.</p> Source code in <code>src\\LZGraphs\\Utilities\\misc.py</code> <pre><code>def chunkify(L, n):\n    \"\"\" Yield successive n-sized chunks from L.\n\n          Args:\n              L (iterable): An iterable of elements to partition into n-sized chunks\n              n (int) the size of each chunck.\n          Returns:\n              generator: a generator that will return the next chunck each time its called until all of L is returned.\n    \"\"\"\n    for i in range(0, len(L), n):\n        yield L[i:i+n]\n</code></pre>"},{"location":"misc_reference/#src.LZGraphs.Utilities.misc.get_dictionary_subkeys","title":"<code>get_dictionary_subkeys(target)</code>","text":"<p>Returns a list of all sub dictionary keys.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>dict</code> <p>a dictionary of dictionaries.</p> required <p>Returns:     list: a list of all the keys contained in the sub dictionaries.</p> Source code in <code>src\\LZGraphs\\Utilities\\misc.py</code> <pre><code>def get_dictionary_subkeys(target):\n    \"\"\"Returns a list of all sub dictionary keys.\n\n          Args:\n              target (dict): a dictionary of dictionaries.\n          Returns:\n              list: a list of all the keys contained in the sub dictionaries.\n          \"\"\"\n    subkeys = []\n    for key in target:\n        subkeys +=[*target[key]]\n    return subkeys\n</code></pre>"},{"location":"misc_reference/#src.LZGraphs.Utilities.misc.window","title":"<code>window(iterable, size)</code>","text":"<p>Return a sliding window generator of size \"size\".</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>iterable</code> <p>An iterable of elements</p> required <code>size</code> <code>int</code> <p>The size of the sliding window.</p> required <p>Returns:</p> Name Type Description <code>zip</code> <p>a zip of all windows of size \"size\"</p> Source code in <code>src\\LZGraphs\\Utilities\\misc.py</code> <pre><code>def window(iterable, size):\n    \"\"\"Return a sliding window generator of size \"size\".\n\n          Args:\n              iterable (iterable): An iterable of elements\n              size (int): The size of the sliding window.\n\n          Returns:\n              zip: a zip of all windows of size \"size\"\n          \"\"\"\n    iters = tee(iterable, size)\n    for i in range(1, size):\n        for each in iters[i:]:\n            next(each, None)\n    return zip(*iters)\n</code></pre>"},{"location":"ndplgraph_reference/","title":"NDPLZGraph Class","text":""},{"location":"ndplgraph_reference/#src.LZGraphs.Graphs.NucleotideDoublePositional.NDPLZGraph","title":"<code>NDPLZGraph</code>","text":"<p>             Bases: <code>LZGraphBase</code></p> <p>This class implements the logic and infrastructure of the \"Nucleotide Double Positional\" version of the LZGraph   The nodes of this graph are LZ sub-patterns with added reading frame start position and the start position   in the sequence, formally: {lz_subpattern}{reading frame start}_{start position in sequence},   This class best fits analysis and inference of nucleotide sequences.</p> <p>...</p> <p>Args:</p> <p>walk_probability(walk,verbose=True):       returns the PGEN of the given walk (list of sub-patterns)</p> <p>is_dag():     the function checks whether the graph is a Directed acyclic graph</p> <p>walk_genes(walk,dropna=True):     give a walk on the graph (a list of nodes) the function will return a table     representing the possible genes and their probabilities at each edge of the walk.</p> <p>path_gene_table(cdr3_sample,threshold=None):     the function will return two tables of all possible v and j genes     that colud be used to generate the sequence given by \"cdr3_sample\"</p> <p>path_gene_table_plot(threshold=None,figsize=None):     the function plots two heatmap, one for V genes and one for J genes,     and represents the probability at each edge to select that gene,     the color at each cell is equal to the probability of selecting the gene, a black     cell means that the graph didn't see that gene used with that sub-pattern.</p> <pre><code>the data used to create the charts can be derived by using the \"path_gene_table\" method.\n</code></pre> <p>gene_variation(cdr3):     given a sequence, this will derive a charts that shows the number of V and J genes observed     per node (LZ- subpattern).</p> <p>gene_variation_plot(cdr3):     Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count     and one for J gene count.</p> <p>random_walk(steps):      given a number of steps (sub-patterns) returns a random walk on the graph between a random inital state      to a random terminal state in the given number of steps</p> <p>gene_random_walk(seq_len, initial_state):     given a target sequence length and an initial state, the function will select a random     V and a random J genes from the observed gene frequency in the graph's \"Training data\" and     generate a walk on the graph from the initial state to a terminal state while making sure     at each step that both the selected V and J genes were seen used by that specific sub-pattern.</p> <p>unsupervised_random_walk():     a random initial state and a random terminal state are selected and a random unsupervised walk is     carried out until the randomly selected terminal state is reached.</p> <p>eigenvector_centrality():     return the eigen vector centrality value for each node (this function is used as the feature extractor     for the LZGraph)</p> <p>sequence_variation_curve(cdr3_sample):     given a cdr3 sequence, the function will calculate the value of the variation curve and return     2 arrays, 1 of the sub-patterns and 1 for the number of out neighbours for each sub-pattern</p> <p>graph_summary():     the function will return a pandas DataFrame containing the graphs     Chromatic Number,Number of Isolates,Max In Deg,Max Out Deg,Number of Edges</p> <pre><code>Attributes:\n\n    nodes:\n        returns the nodes of the graph\n    edges:\n        return the edges of the graph\n</code></pre> Source code in <code>src\\LZGraphs\\Graphs\\NucleotideDoublePositional.py</code> <pre><code>class NDPLZGraph(LZGraphBase):\n    \"\"\"\n          This class implements the logic and infrastructure of the \"Nucleotide Double Positional\" version of the LZGraph\n          The nodes of this graph are LZ sub-patterns with added reading frame start position and the start position\n          in the sequence, formally: {lz_subpattern}{reading frame start}_{start position in sequence},\n          This class best fits analysis and inference of nucleotide sequences.\n\n          ...\n\n        Args:\n\n          walk_probability(walk,verbose=True):\n              returns the PGEN of the given walk (list of sub-patterns)\n\n\n          is_dag():\n            the function checks whether the graph is a Directed acyclic graph\n\n          walk_genes(walk,dropna=True):\n            give a walk on the graph (a list of nodes) the function will return a table\n            representing the possible genes and their probabilities at each edge of the walk.\n\n          path_gene_table(cdr3_sample,threshold=None):\n            the function will return two tables of all possible v and j genes\n            that colud be used to generate the sequence given by \"cdr3_sample\"\n\n\n          path_gene_table_plot(threshold=None,figsize=None):\n            the function plots two heatmap, one for V genes and one for J genes,\n            and represents the probability at each edge to select that gene,\n            the color at each cell is equal to the probability of selecting the gene, a black\n            cell means that the graph didn't see that gene used with that sub-pattern.\n\n            the data used to create the charts can be derived by using the \"path_gene_table\" method.\n\n          gene_variation(cdr3):\n            given a sequence, this will derive a charts that shows the number of V and J genes observed\n            per node (LZ- subpattern).\n\n          gene_variation_plot(cdr3):\n            Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count\n            and one for J gene count.\n\n\n          random_walk(steps):\n             given a number of steps (sub-patterns) returns a random walk on the graph between a random inital state\n             to a random terminal state in the given number of steps\n\n          gene_random_walk(seq_len, initial_state):\n            given a target sequence length and an initial state, the function will select a random\n            V and a random J genes from the observed gene frequency in the graph's \"Training data\" and\n            generate a walk on the graph from the initial state to a terminal state while making sure\n            at each step that both the selected V and J genes were seen used by that specific sub-pattern.\n\n          unsupervised_random_walk():\n            a random initial state and a random terminal state are selected and a random unsupervised walk is\n            carried out until the randomly selected terminal state is reached.\n\n          eigenvector_centrality():\n            return the eigen vector centrality value for each node (this function is used as the feature extractor\n            for the LZGraph)\n\n\n          sequence_variation_curve(cdr3_sample):\n            given a cdr3 sequence, the function will calculate the value of the variation curve and return\n            2 arrays, 1 of the sub-patterns and 1 for the number of out neighbours for each sub-pattern\n\n          graph_summary():\n            the function will return a pandas DataFrame containing the graphs\n            Chromatic Number,Number of Isolates,Max In Deg,Max Out Deg,Number of Edges\n\n\n            Attributes:\n\n                nodes:\n                    returns the nodes of the graph\n                edges:\n                    return the edges of the graph\n\n\n    \"\"\"\n    def __init__(self, data, verbose=True, calculate_trainset_pgen=False):\n\n        \"\"\"\n\n        :param data: a padnas dataframe with 1 mandatory column \"cdr3_rearrangement\" which is all the cdr3 neuclitode\n        sequences , optinaly genes can be added to graph for gene inference via adding a \"V\" and \"J\" column\n        :param verbose:\n        :param dictionary:\n        \"\"\"\n        super().__init__()\n\n        # check for V and J gene data in input\n        self.genetic = True if type(data) == pd.DataFrame and 'V' in data.columns and 'J' in data.columns else False\n\n        if self.genetic:\n            self._load_gene_data(data)\n            self.verbose_driver(0, verbose)\n\n        # construct the graph while iterating over the data\n        self.__simultaneous_graph_construction(data)\n        self.verbose_driver(1, verbose)\n\n        # convert to pandas series and  normalize\n        self.length_distribution = pd.Series(self.lengths)\n        self.terminal_states = pd.Series(self.terminal_states)\n        self.initial_states = pd.Series(self.initial_states)\n        self.length_distribution_proba = self.terminal_states / self.terminal_states.sum()\n        self.initial_states = self.initial_states[self.initial_states &gt; 5]\n        self.initial_states_probability = self.initial_states/self.initial_states.sum()\n\n        self.verbose_driver(2, verbose)\n\n\n        self._derive_subpattern_individual_probability()\n        self.verbose_driver(8, verbose)\n        self._normalize_edge_weights()\n        self.verbose_driver(3, verbose)\n\n        if self.genetic:\n            # Normalized Gene Weights\n            self._batch_gene_weight_normalization(3, verbose)\n            self.verbose_driver(4, verbose)\n\n        self.edges_list = None\n        self._derive_terminal_state_map()\n        self.verbose_driver(7, verbose)\n        self._derive_stop_probability_data()\n        self.verbose_driver(8, verbose)\n        self.verbose_driver(5, verbose)\n\n        self.constructor_end_time = time()\n        self.verbose_driver(6, verbose)\n\n\n        if calculate_trainset_pgen:\n            self.train_pgen = np.array(\n                [self.walk_probability(self.encode_sequence(i), verbose=False) for i in data['cdr3_rearrangement']])\n\n        self.verbose_driver(-2, verbose)\n\n    @staticmethod\n    def encode_sequence(cdr3):\n        \"\"\"\n              given a sequence of nucleotides this function will encode it into the following format:\n              {lz_subpattern}{reading frame start}_{start position in sequence}\n              matching the requirement of the NDPLZGraph.\n\n\n                      Parameters:\n                              cdr3 (str): a string to encode into the NDPLZGraph format\n\n                      Returns:\n                              list : a list of unique sub-patterns in the NDPLZGraph format\n       \"\"\"\n        lz, rf, pos = derive_lz_reading_frame_position(cdr3)\n        return list(map(lambda x, y, z: x + str(y) + '_' + str(z), lz, rf, pos))\n    @staticmethod\n    def clean_node(base):\n        \"\"\"\n          given a sub-pattern that has reading frame and position added to it, cleans it and returns\n          only the nucleotides from the string\n\n                  Parameters:\n                          base (str): a node from the NDPLZGraph\n\n                  Returns:\n                          str : only the nucleotides of the node\n     \"\"\"\n        return re.search(r'[ATGC]*', base).group()\n\n    def _decomposed_sequence_generator(self,data):\n        if self.genetic:\n            for cdr3, v, j in tqdm(zip(data['cdr3_rearrangement'], data['V'], data['J']), leave=False):\n                subpattern, reading_frame, position = derive_lz_reading_frame_position(cdr3)\n                steps = (window(subpattern, 2))\n                reading_frames = (window(reading_frame, 2))\n                locations = (window(position, 2))\n\n                self.lengths[len(cdr3)] = self.lengths.get(len(cdr3), 0) + 1\n\n\n                self._update_terminal_states(subpattern[-1] + str(reading_frame[-1]) + '_' + str(position[-1]))\n                self._update_initial_states(subpattern[0] + str(reading_frame[0]) + '_1')\n                yield steps,reading_frames, locations, v, j\n        else:\n            for cdr3 in tqdm(list(data), leave=False):\n                subpattern, reading_frame, position = derive_lz_reading_frame_position(cdr3)\n                steps = (window(subpattern, 2))\n                reading_frames = (window(reading_frame, 2))\n                locations = (window(position, 2))\n\n                self.lengths[len(cdr3)] = self.lengths.get(len(cdr3), 0) + 1\n\n                self._update_terminal_states(subpattern[-1] + str(reading_frame[-1]) + '_' + str(position[-1]))\n                self._update_initial_states(subpattern[0] + str(reading_frame[0]) + '_1')\n                yield steps,reading_frames,locations\n\n    def __simultaneous_graph_construction(self,data):\n        processing_stream = self._decomposed_sequence_generator(data)\n        if self.genetic:\n            for output in processing_stream:\n                steps,reading_frames,locations,v,j = output\n\n                for (A, B), (pos_a, pos_b), (loc_a, loc_b) in zip(steps, reading_frames, locations):\n                    A_ = A + str(pos_a) + '_' + str(loc_a)\n                    self.per_node_observed_frequency[A_] = self.per_node_observed_frequency.get(A_,0)+1\n                    B_ = B + str(pos_b) + '_' + str(loc_b)\n                    self._insert_edge_and_information(A_, B_, v, j)\n                self.per_node_observed_frequency[B_] = self.per_node_observed_frequency.get(B_, 0)\n\n        else:\n            for output in processing_stream:\n                steps, reading_frames, locations = output\n                for (A, B), (pos_a, pos_b), (loc_a, loc_b) in zip(steps, reading_frames, locations):\n                        A_ = A + str(pos_a) + '_' + str(loc_a)\n                        self.per_node_observed_frequency[A_] = self.per_node_observed_frequency.get(A_,0)+1\n                        B_ = B + str(pos_b) + '_' + str(loc_b)\n                        self._insert_edge_and_information_no_genes(A_, B_)\n\n\n    def walk_probability(self, walk, verbose=True):\n        \"\"\"\n             given a walk (a sequence converted into LZ sub-pattern) return the probability of generation (PGEN)\n             of the walk.\n\n             you can use \"lempel_ziv_decomposition\" from this libraries decomposition module in order to convert a\n             sequence into LZ sub-patterns\n\n                      Parameters:\n                              walk (list): a list of LZ - sub-patterns\n\n                      Returns:\n                              float : the probability of generating such a walk (PGEN)\n               \"\"\"\n        if type(walk) == str:\n            LZ, POS = derive_lz_reading_frame_position(walk)\n            walk_ = [i + str(j) for i, j in zip(LZ, POS)]\n        else:\n            walk_ = walk\n\n        proba = self.subpattern_individual_probability['proba'][walk_[0]]\n        for step1, step2 in window(walk_, 2):\n            if self.graph.has_edge(step1, step2):\n                proba *= self.graph.get_edge_data(step1, step2)['weight']\n            else:\n                if verbose:\n                    print('No Edge Connecting| ', step1, '--&gt;', step2)\n                return 0\n        return proba\n\n    # def random_walk(self, seq_len, initial_state):\n    #     \"\"\"\n    #       given a number of steps (sub-patterns) returns a random walk on the graph between a random inital state\n    #         to a random terminal state in the given number of steps\n    #\n    #\n    #                  Parameters:\n    #                          steps (int): number of sub-patterns the resulting walk should contain\n    #                  Returns:\n    #                          (list) : a list of LZ sub-patterns representing the random walk\n    #           \"\"\"\n    #     current_state = initial_state\n    #     walk = [initial_state]\n    #     sequence = clean_node(initial_state)\n    #\n    #     terminal_states = self._length_specific_terminal_state(seq_len)\n    #\n    #     if len(terminal_states) &lt; 1:\n    #         raise Exception('Unfamiliar Seq Length')\n    #\n    #     while current_state not in terminal_states:\n    #         states, probabilities = self._get_state_weights(current_state)\n    #         # Try add dynamic dictionary of weight that will remove invalid paths\n    #\n    #         # if went into a final path with mismatch length\n    #         if len(probabilities) == 0:  # no options we can take from here\n    #             # go back to the last junction where a different choice can be made\n    #             for ax in range(len(walk) - 1, 1, -1):\n    #                 for final_s in terminal_states:\n    #                     try:\n    #                         SP = nx.dijkstra_path(self.graph, source=walk[ax], target=final_s,\n    #                                               weight=lambda x, y, z: 1 - z['weight'])\n    #                         walk = walk[:ax] + SP\n    #                         sequence = ''.join([clean_node(i) for i in walk])\n    #                         return walk\n    #                     except nx.NetworkXNoPath:\n    #                         continue\n    #\n    #         current_state = np.random.choice(states, size=1, p=probabilities).item()\n    #         walk.append(current_state)\n    #         sequence += clean_node(current_state)\n    #\n    #     return walk\n\n    def gene_random_walk(self, seq_len, initial_state=None, vj_init='marginal'):\n        \"\"\"\n            given a target sequence length and an initial state, the function will select a random\n            V and a random J genes from the observed gene frequency in the graph's \"Training data\" and\n            generate a walk on the graph from the initial state to a terminal state while making sure\n            at each step that both the selected V and J genes were seen used by that specific sub-pattern.\n\n            if seq_len is equal to \"unsupervised\" than a random seq len will be returned\n       \"\"\"\n\n        selected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\n\n        if seq_len == 'unsupervised':\n            terminal_states = self.terminal_states\n            initial_state = self._random_initial_state()\n        else:\n            terminal_states = self._length_specific_terminal_state(seq_len)\n\n        current_state = initial_state\n        walk = [initial_state]\n\n        # nodes not to consider due to invalidity\n        if self.genetic_walks_black_list is None:\n            self.genetic_walks_black_list = dict()\n\n\n        # while the walk is not in a valid final state\n        while current_state not in terminal_states:\n            # print('Blacklist: ',blacklist)\n            # print('='*30)\n            # get the node_data for the current state\n            edge_info = pd.DataFrame(dict(self.graph[current_state]))\n\n            if (current_state,selected_gene_path_v,selected_gene_path_j) in self.genetic_walks_black_list:\n                edge_info = edge_info.drop(columns=self.genetic_walks_black_list[(current_state,selected_gene_path_v,selected_gene_path_j)])\n            # check selected path has genes\n            if len(set(edge_info.index) &amp; {selected_gene_path_v, selected_gene_path_j}) != 2:\n                # TODO: add a visited node stack to not repeat the same calls and mistakes\n                if len(walk) &gt; 2:\n                    self.genetic_walks_black_list[(walk[-2],selected_gene_path_v,selected_gene_path_j)]\\\n                        = self.genetic_walks_black_list.get((walk[-2],selected_gene_path_v,selected_gene_path_j), []) + [walk[-1]]\n                    current_state = walk[-2]\n                    walk = walk[:-1]\n                else:\n                    walk = walk[:1]\n                    current_state = walk[0]\n                    selected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\n\n                continue\n\n            # get paths containing selected_genes\n            idf = edge_info.T[[selected_gene_path_v, selected_gene_path_j]].dropna()\n            w = edge_info.loc['weight', idf.index]\n            w = w / w.sum()\n\n            if len(w) == 0:\n                if len(walk) &gt; 2:\n                    self.genetic_walks_black_list[(walk[-2],selected_gene_path_v,selected_gene_path_j)] = \\\n                        self.genetic_walks_black_list.get((walk[-2],selected_gene_path_v,selected_gene_path_j), []) + [walk[-1]]\n                    current_state = walk[-2]\n                    walk = walk[:-1]\n                else:\n                    walk = walk[:1]\n                    current_state = walk[0]\n                    selected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\n\n                continue\n\n            # if len(w) == 0:  # no options we can take from here\n            #     # go back to the last junction where a different choice can be made\n            #     for ax in range(len(walk) - 1, 1, -1):\n            #         for final_s in terminal_states:\n            #             try:\n            #                 SP = nx.dijkstra_path(self.graph, source=walk[ax], target=final_s,\n            #                                       weight=lambda x, y, z: 1 - z['weight'])\n            #                 walk = walk[:ax] + SP\n            #                 sequence = ''.join([clean_node(i) for i in walk])\n            #                 raise Exception(f' Ended After Selecting SP '+str(walk))\n            #             except nx.NetworkXNoPath:\n            #                 continue\n\n            current_state = np.random.choice(w.index, size=1, p=w.values).item()\n            walk.append(current_state)\n\n        return walk, selected_gene_path_v, selected_gene_path_j\n\n    def unsupervised_random_walk(self):\n        \"\"\"\n                     a random initial state and a random terminal state are selected and a random unsupervised walk is\n                    carried out until the randomly selected terminal state is reached.\n\n                              Parameters:\n                                      None\n\n                              Returns:\n                                      (list,str) : a list of LZ sub-patterns representing the random walk and a string\n                                      matching the walk only translated back into a sequence.\n               \"\"\"\n        random_initial_state = self._random_initial_state()\n\n        current_state = random_initial_state\n        walk = [random_initial_state]\n        sequence = self.clean_node(random_initial_state)\n\n        while current_state not in self.terminal_states:\n            # take a random step\n            current_state = self.random_step(current_state)\n\n            walk.append(current_state)\n            sequence += self.clean_node(current_state)\n        return walk, sequence\n\n    def walk_genes(self, walk,dropna=True):\n        \"\"\"\n        give a walk on the graph (a list of nodes) the function will return a table\n            representing the possible genes and their probabilities at each edge of the walk.\n        :param walk:\n        :param dropna:\n        :return:\n        \"\"\"\n        trans_genes = []\n        columns = []\n        for i in range(0, len(walk) - 1):\n            ls = self.graph.get_edge_data(walk[i], walk[i + 1]).copy()\n            columns.append(walk[i] + '-&gt;' + walk[i + 1])\n            ls.pop('weight')\n            ls.pop('Vsum')\n            ls.pop('Jsum')\n\n            trans_genes.append(pd.Series(ls))\n\n        cc = pd.concat(trans_genes, axis=1)\n        if dropna:\n            cc = cc.dropna()\n        if cc.shape[0] == 0:\n            raise Exception('No Constant Gene Flow F')\n\n        cc.columns = columns\n        cc['type'] = ['v' if 'v' in x.lower() else 'j' for x in cc.index]\n        cc['sum'] = cc.sum(axis=1, numeric_only=True)\n        cc = cc.sort_values(by='sum', ascending=False)\n\n        return cc\n\n    def sequence_variation_curve(self,cdr3_sample):\n        \"\"\"\n        given a sequence this function will return 2 list,\n        the first is the lz-subpattern path through the graph and the second list is the number\n        of possible choices that can be made at each sub-pattern\n        :param cdr3_sample:\n        :return:\n        \"\"\"\n        encoded = self.encode_sequence(cdr3_sample)\n        curve = [self.graph.out_degree(i) for i in encoded]\n        return encoded,curve\n\n    def path_gene_table(self,cdr3_sample,threshold=None):\n        \"\"\"\n        the function will return two tables of all possible v and j genes\n            that colud be used to generate the sequence given by \"cdr3_sample\"\n        :param cdr3_sample: a cdr3 sequence\n        :param threshold: drop genes that are missing from threshold % of the sequence\n        :return:\n        \"\"\"\n        length = len(self.encode_sequence(cdr3_sample))\n\n        if threshold is None:\n            threshold = length * (1 / 4)\n        gene_table = self.walk_genes(self.encode_sequence(cdr3_sample), dropna=False)\n        gene_table = gene_table[gene_table.isna().sum(axis=1) &lt; threshold]\n        vgene_table = gene_table[gene_table.index.str.contains('V')]\n\n        gene_table = self.walk_genes(self.encode_sequence(cdr3_sample), dropna=False)\n        gene_table = gene_table[gene_table.isna().sum(axis=1) &lt; (length * (1 / 2))]\n        jgene_table = gene_table[gene_table.index.str.contains('J')]\n\n        jgene_table = jgene_table.loc[jgene_table.isna().sum(axis=1).sort_values(ascending=True).index, :]\n        vgene_table = vgene_table.loc[vgene_table.isna().sum(axis=1).sort_values(ascending=True).index, :]\n\n        return vgene_table,jgene_table\n\n\n    def gene_variation(self,cdr3):\n        \"\"\"\n        Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count\n            and one for J gene count.\n        :param cdr3:\n        :return:\n        \"\"\"\n        if not self.genetic:\n            raise Exception('The LZGraph Has No Gene Data')\n        encoded_a = self.encode_sequence(cdr3)\n        nv_genes = [len(self.marginal_vgenes)]\n        nj_genes = [len(self.marginal_jgenes)]\n        for node in encoded_a[1:]:\n            inedges = self.graph.in_edges(node)\n            v = set()\n            j = set()\n            for ea, eb in inedges:\n                genes = pd.Series(self.graph[ea][eb]).drop(index=['Vsum', 'Jsum', 'weight'])\n                v = v | set(genes[genes.index.str.contains('V')].index)\n                j = j | set(genes[genes.index.str.contains('J')].index)\n            nv_genes.append(len(v))\n            nj_genes.append(len(j))\n\n        nj_genes = np.array(nj_genes)\n        nv_genes = np.array(nv_genes)\n\n        j_df = pd.DataFrame(\n            {'genes': list(nv_genes) + list(nj_genes), 'type': ['V'] * len(nv_genes) + ['J'] * len(nj_genes),\n             'sp': lempel_ziv_decomposition(cdr3) + lempel_ziv_decomposition(cdr3)})\n        return j_df\n</code></pre>"},{"location":"ndplgraph_reference/#src.LZGraphs.Graphs.NucleotideDoublePositional.NDPLZGraph.__init__","title":"<code>__init__(data, verbose=True, calculate_trainset_pgen=False)</code>","text":"<p>:param data: a padnas dataframe with 1 mandatory column \"cdr3_rearrangement\" which is all the cdr3 neuclitode sequences , optinaly genes can be added to graph for gene inference via adding a \"V\" and \"J\" column :param verbose: :param dictionary:</p> Source code in <code>src\\LZGraphs\\Graphs\\NucleotideDoublePositional.py</code> <pre><code>def __init__(self, data, verbose=True, calculate_trainset_pgen=False):\n\n    \"\"\"\n\n    :param data: a padnas dataframe with 1 mandatory column \"cdr3_rearrangement\" which is all the cdr3 neuclitode\n    sequences , optinaly genes can be added to graph for gene inference via adding a \"V\" and \"J\" column\n    :param verbose:\n    :param dictionary:\n    \"\"\"\n    super().__init__()\n\n    # check for V and J gene data in input\n    self.genetic = True if type(data) == pd.DataFrame and 'V' in data.columns and 'J' in data.columns else False\n\n    if self.genetic:\n        self._load_gene_data(data)\n        self.verbose_driver(0, verbose)\n\n    # construct the graph while iterating over the data\n    self.__simultaneous_graph_construction(data)\n    self.verbose_driver(1, verbose)\n\n    # convert to pandas series and  normalize\n    self.length_distribution = pd.Series(self.lengths)\n    self.terminal_states = pd.Series(self.terminal_states)\n    self.initial_states = pd.Series(self.initial_states)\n    self.length_distribution_proba = self.terminal_states / self.terminal_states.sum()\n    self.initial_states = self.initial_states[self.initial_states &gt; 5]\n    self.initial_states_probability = self.initial_states/self.initial_states.sum()\n\n    self.verbose_driver(2, verbose)\n\n\n    self._derive_subpattern_individual_probability()\n    self.verbose_driver(8, verbose)\n    self._normalize_edge_weights()\n    self.verbose_driver(3, verbose)\n\n    if self.genetic:\n        # Normalized Gene Weights\n        self._batch_gene_weight_normalization(3, verbose)\n        self.verbose_driver(4, verbose)\n\n    self.edges_list = None\n    self._derive_terminal_state_map()\n    self.verbose_driver(7, verbose)\n    self._derive_stop_probability_data()\n    self.verbose_driver(8, verbose)\n    self.verbose_driver(5, verbose)\n\n    self.constructor_end_time = time()\n    self.verbose_driver(6, verbose)\n\n\n    if calculate_trainset_pgen:\n        self.train_pgen = np.array(\n            [self.walk_probability(self.encode_sequence(i), verbose=False) for i in data['cdr3_rearrangement']])\n\n    self.verbose_driver(-2, verbose)\n</code></pre>"},{"location":"ndplgraph_reference/#src.LZGraphs.Graphs.NucleotideDoublePositional.NDPLZGraph.clean_node","title":"<code>clean_node(base)</code>  <code>staticmethod</code>","text":"<p>given a sub-pattern that has reading frame and position added to it, cleans it and returns only the nucleotides from the string</p> <pre><code>    Parameters:\n            base (str): a node from the NDPLZGraph\n\n    Returns:\n            str : only the nucleotides of the node\n</code></pre> Source code in <code>src\\LZGraphs\\Graphs\\NucleotideDoublePositional.py</code> <pre><code>@staticmethod\ndef clean_node(base):\n    \"\"\"\n      given a sub-pattern that has reading frame and position added to it, cleans it and returns\n      only the nucleotides from the string\n\n              Parameters:\n                      base (str): a node from the NDPLZGraph\n\n              Returns:\n                      str : only the nucleotides of the node\n \"\"\"\n    return re.search(r'[ATGC]*', base).group()\n</code></pre>"},{"location":"ndplgraph_reference/#src.LZGraphs.Graphs.NucleotideDoublePositional.NDPLZGraph.encode_sequence","title":"<code>encode_sequence(cdr3)</code>  <code>staticmethod</code>","text":"<p>given a sequence of nucleotides this function will encode it into the following format: {lz_subpattern}{reading frame start}_{start position in sequence} matching the requirement of the NDPLZGraph.</p> <pre><code>    Parameters:\n            cdr3 (str): a string to encode into the NDPLZGraph format\n\n    Returns:\n            list : a list of unique sub-patterns in the NDPLZGraph format\n</code></pre> Source code in <code>src\\LZGraphs\\Graphs\\NucleotideDoublePositional.py</code> <pre><code>@staticmethod\ndef encode_sequence(cdr3):\n    \"\"\"\n          given a sequence of nucleotides this function will encode it into the following format:\n          {lz_subpattern}{reading frame start}_{start position in sequence}\n          matching the requirement of the NDPLZGraph.\n\n\n                  Parameters:\n                          cdr3 (str): a string to encode into the NDPLZGraph format\n\n                  Returns:\n                          list : a list of unique sub-patterns in the NDPLZGraph format\n   \"\"\"\n    lz, rf, pos = derive_lz_reading_frame_position(cdr3)\n    return list(map(lambda x, y, z: x + str(y) + '_' + str(z), lz, rf, pos))\n</code></pre>"},{"location":"ndplgraph_reference/#src.LZGraphs.Graphs.NucleotideDoublePositional.NDPLZGraph.gene_random_walk","title":"<code>gene_random_walk(seq_len, initial_state=None, vj_init='marginal')</code>","text":"<p>given a target sequence length and an initial state, the function will select a random V and a random J genes from the observed gene frequency in the graph's \"Training data\" and generate a walk on the graph from the initial state to a terminal state while making sure at each step that both the selected V and J genes were seen used by that specific sub-pattern.</p> <p>if seq_len is equal to \"unsupervised\" than a random seq len will be returned</p> Source code in <code>src\\LZGraphs\\Graphs\\NucleotideDoublePositional.py</code> <pre><code>def gene_random_walk(self, seq_len, initial_state=None, vj_init='marginal'):\n    \"\"\"\n        given a target sequence length and an initial state, the function will select a random\n        V and a random J genes from the observed gene frequency in the graph's \"Training data\" and\n        generate a walk on the graph from the initial state to a terminal state while making sure\n        at each step that both the selected V and J genes were seen used by that specific sub-pattern.\n\n        if seq_len is equal to \"unsupervised\" than a random seq len will be returned\n   \"\"\"\n\n    selected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\n\n    if seq_len == 'unsupervised':\n        terminal_states = self.terminal_states\n        initial_state = self._random_initial_state()\n    else:\n        terminal_states = self._length_specific_terminal_state(seq_len)\n\n    current_state = initial_state\n    walk = [initial_state]\n\n    # nodes not to consider due to invalidity\n    if self.genetic_walks_black_list is None:\n        self.genetic_walks_black_list = dict()\n\n\n    # while the walk is not in a valid final state\n    while current_state not in terminal_states:\n        # print('Blacklist: ',blacklist)\n        # print('='*30)\n        # get the node_data for the current state\n        edge_info = pd.DataFrame(dict(self.graph[current_state]))\n\n        if (current_state,selected_gene_path_v,selected_gene_path_j) in self.genetic_walks_black_list:\n            edge_info = edge_info.drop(columns=self.genetic_walks_black_list[(current_state,selected_gene_path_v,selected_gene_path_j)])\n        # check selected path has genes\n        if len(set(edge_info.index) &amp; {selected_gene_path_v, selected_gene_path_j}) != 2:\n            # TODO: add a visited node stack to not repeat the same calls and mistakes\n            if len(walk) &gt; 2:\n                self.genetic_walks_black_list[(walk[-2],selected_gene_path_v,selected_gene_path_j)]\\\n                    = self.genetic_walks_black_list.get((walk[-2],selected_gene_path_v,selected_gene_path_j), []) + [walk[-1]]\n                current_state = walk[-2]\n                walk = walk[:-1]\n            else:\n                walk = walk[:1]\n                current_state = walk[0]\n                selected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\n\n            continue\n\n        # get paths containing selected_genes\n        idf = edge_info.T[[selected_gene_path_v, selected_gene_path_j]].dropna()\n        w = edge_info.loc['weight', idf.index]\n        w = w / w.sum()\n\n        if len(w) == 0:\n            if len(walk) &gt; 2:\n                self.genetic_walks_black_list[(walk[-2],selected_gene_path_v,selected_gene_path_j)] = \\\n                    self.genetic_walks_black_list.get((walk[-2],selected_gene_path_v,selected_gene_path_j), []) + [walk[-1]]\n                current_state = walk[-2]\n                walk = walk[:-1]\n            else:\n                walk = walk[:1]\n                current_state = walk[0]\n                selected_gene_path_v, selected_gene_path_j = self._select_random_vj_genes(vj_init)\n\n            continue\n\n        # if len(w) == 0:  # no options we can take from here\n        #     # go back to the last junction where a different choice can be made\n        #     for ax in range(len(walk) - 1, 1, -1):\n        #         for final_s in terminal_states:\n        #             try:\n        #                 SP = nx.dijkstra_path(self.graph, source=walk[ax], target=final_s,\n        #                                       weight=lambda x, y, z: 1 - z['weight'])\n        #                 walk = walk[:ax] + SP\n        #                 sequence = ''.join([clean_node(i) for i in walk])\n        #                 raise Exception(f' Ended After Selecting SP '+str(walk))\n        #             except nx.NetworkXNoPath:\n        #                 continue\n\n        current_state = np.random.choice(w.index, size=1, p=w.values).item()\n        walk.append(current_state)\n\n    return walk, selected_gene_path_v, selected_gene_path_j\n</code></pre>"},{"location":"ndplgraph_reference/#src.LZGraphs.Graphs.NucleotideDoublePositional.NDPLZGraph.gene_variation","title":"<code>gene_variation(cdr3)</code>","text":"<p>Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count     and one for J gene count. :param cdr3: :return:</p> Source code in <code>src\\LZGraphs\\Graphs\\NucleotideDoublePositional.py</code> <pre><code>def gene_variation(self,cdr3):\n    \"\"\"\n    Plots the data derived at the \"gene_variation\" method as two bar charts overlayed, one for V gene count\n        and one for J gene count.\n    :param cdr3:\n    :return:\n    \"\"\"\n    if not self.genetic:\n        raise Exception('The LZGraph Has No Gene Data')\n    encoded_a = self.encode_sequence(cdr3)\n    nv_genes = [len(self.marginal_vgenes)]\n    nj_genes = [len(self.marginal_jgenes)]\n    for node in encoded_a[1:]:\n        inedges = self.graph.in_edges(node)\n        v = set()\n        j = set()\n        for ea, eb in inedges:\n            genes = pd.Series(self.graph[ea][eb]).drop(index=['Vsum', 'Jsum', 'weight'])\n            v = v | set(genes[genes.index.str.contains('V')].index)\n            j = j | set(genes[genes.index.str.contains('J')].index)\n        nv_genes.append(len(v))\n        nj_genes.append(len(j))\n\n    nj_genes = np.array(nj_genes)\n    nv_genes = np.array(nv_genes)\n\n    j_df = pd.DataFrame(\n        {'genes': list(nv_genes) + list(nj_genes), 'type': ['V'] * len(nv_genes) + ['J'] * len(nj_genes),\n         'sp': lempel_ziv_decomposition(cdr3) + lempel_ziv_decomposition(cdr3)})\n    return j_df\n</code></pre>"},{"location":"ndplgraph_reference/#src.LZGraphs.Graphs.NucleotideDoublePositional.NDPLZGraph.path_gene_table","title":"<code>path_gene_table(cdr3_sample, threshold=None)</code>","text":"<p>the function will return two tables of all possible v and j genes     that colud be used to generate the sequence given by \"cdr3_sample\" :param cdr3_sample: a cdr3 sequence :param threshold: drop genes that are missing from threshold % of the sequence :return:</p> Source code in <code>src\\LZGraphs\\Graphs\\NucleotideDoublePositional.py</code> <pre><code>def path_gene_table(self,cdr3_sample,threshold=None):\n    \"\"\"\n    the function will return two tables of all possible v and j genes\n        that colud be used to generate the sequence given by \"cdr3_sample\"\n    :param cdr3_sample: a cdr3 sequence\n    :param threshold: drop genes that are missing from threshold % of the sequence\n    :return:\n    \"\"\"\n    length = len(self.encode_sequence(cdr3_sample))\n\n    if threshold is None:\n        threshold = length * (1 / 4)\n    gene_table = self.walk_genes(self.encode_sequence(cdr3_sample), dropna=False)\n    gene_table = gene_table[gene_table.isna().sum(axis=1) &lt; threshold]\n    vgene_table = gene_table[gene_table.index.str.contains('V')]\n\n    gene_table = self.walk_genes(self.encode_sequence(cdr3_sample), dropna=False)\n    gene_table = gene_table[gene_table.isna().sum(axis=1) &lt; (length * (1 / 2))]\n    jgene_table = gene_table[gene_table.index.str.contains('J')]\n\n    jgene_table = jgene_table.loc[jgene_table.isna().sum(axis=1).sort_values(ascending=True).index, :]\n    vgene_table = vgene_table.loc[vgene_table.isna().sum(axis=1).sort_values(ascending=True).index, :]\n\n    return vgene_table,jgene_table\n</code></pre>"},{"location":"ndplgraph_reference/#src.LZGraphs.Graphs.NucleotideDoublePositional.NDPLZGraph.sequence_variation_curve","title":"<code>sequence_variation_curve(cdr3_sample)</code>","text":"<p>given a sequence this function will return 2 list, the first is the lz-subpattern path through the graph and the second list is the number of possible choices that can be made at each sub-pattern :param cdr3_sample: :return:</p> Source code in <code>src\\LZGraphs\\Graphs\\NucleotideDoublePositional.py</code> <pre><code>def sequence_variation_curve(self,cdr3_sample):\n    \"\"\"\n    given a sequence this function will return 2 list,\n    the first is the lz-subpattern path through the graph and the second list is the number\n    of possible choices that can be made at each sub-pattern\n    :param cdr3_sample:\n    :return:\n    \"\"\"\n    encoded = self.encode_sequence(cdr3_sample)\n    curve = [self.graph.out_degree(i) for i in encoded]\n    return encoded,curve\n</code></pre>"},{"location":"ndplgraph_reference/#src.LZGraphs.Graphs.NucleotideDoublePositional.NDPLZGraph.unsupervised_random_walk","title":"<code>unsupervised_random_walk()</code>","text":"<p>a random initial state and a random terminal state are selected and a random unsupervised walk is carried out until the randomly selected terminal state is reached.</p> <pre><code>      Parameters:\n              None\n\n      Returns:\n              (list,str) : a list of LZ sub-patterns representing the random walk and a string\n              matching the walk only translated back into a sequence.\n</code></pre> Source code in <code>src\\LZGraphs\\Graphs\\NucleotideDoublePositional.py</code> <pre><code>def unsupervised_random_walk(self):\n    \"\"\"\n                 a random initial state and a random terminal state are selected and a random unsupervised walk is\n                carried out until the randomly selected terminal state is reached.\n\n                          Parameters:\n                                  None\n\n                          Returns:\n                                  (list,str) : a list of LZ sub-patterns representing the random walk and a string\n                                  matching the walk only translated back into a sequence.\n           \"\"\"\n    random_initial_state = self._random_initial_state()\n\n    current_state = random_initial_state\n    walk = [random_initial_state]\n    sequence = self.clean_node(random_initial_state)\n\n    while current_state not in self.terminal_states:\n        # take a random step\n        current_state = self.random_step(current_state)\n\n        walk.append(current_state)\n        sequence += self.clean_node(current_state)\n    return walk, sequence\n</code></pre>"},{"location":"ndplgraph_reference/#src.LZGraphs.Graphs.NucleotideDoublePositional.NDPLZGraph.walk_genes","title":"<code>walk_genes(walk, dropna=True)</code>","text":"<p>give a walk on the graph (a list of nodes) the function will return a table     representing the possible genes and their probabilities at each edge of the walk. :param walk: :param dropna: :return:</p> Source code in <code>src\\LZGraphs\\Graphs\\NucleotideDoublePositional.py</code> <pre><code>def walk_genes(self, walk,dropna=True):\n    \"\"\"\n    give a walk on the graph (a list of nodes) the function will return a table\n        representing the possible genes and their probabilities at each edge of the walk.\n    :param walk:\n    :param dropna:\n    :return:\n    \"\"\"\n    trans_genes = []\n    columns = []\n    for i in range(0, len(walk) - 1):\n        ls = self.graph.get_edge_data(walk[i], walk[i + 1]).copy()\n        columns.append(walk[i] + '-&gt;' + walk[i + 1])\n        ls.pop('weight')\n        ls.pop('Vsum')\n        ls.pop('Jsum')\n\n        trans_genes.append(pd.Series(ls))\n\n    cc = pd.concat(trans_genes, axis=1)\n    if dropna:\n        cc = cc.dropna()\n    if cc.shape[0] == 0:\n        raise Exception('No Constant Gene Flow F')\n\n    cc.columns = columns\n    cc['type'] = ['v' if 'v' in x.lower() else 'j' for x in cc.index]\n    cc['sum'] = cc.sum(axis=1, numeric_only=True)\n    cc = cc.sort_values(by='sum', ascending=False)\n\n    return cc\n</code></pre>"},{"location":"ndplgraph_reference/#src.LZGraphs.Graphs.NucleotideDoublePositional.NDPLZGraph.walk_probability","title":"<code>walk_probability(walk, verbose=True)</code>","text":"<p>given a walk (a sequence converted into LZ sub-pattern) return the probability of generation (PGEN) of the walk.</p> <p>you can use \"lempel_ziv_decomposition\" from this libraries decomposition module in order to convert a sequence into LZ sub-patterns</p> <pre><code>     Parameters:\n             walk (list): a list of LZ - sub-patterns\n\n     Returns:\n             float : the probability of generating such a walk (PGEN)\n</code></pre> Source code in <code>src\\LZGraphs\\Graphs\\NucleotideDoublePositional.py</code> <pre><code>def walk_probability(self, walk, verbose=True):\n    \"\"\"\n         given a walk (a sequence converted into LZ sub-pattern) return the probability of generation (PGEN)\n         of the walk.\n\n         you can use \"lempel_ziv_decomposition\" from this libraries decomposition module in order to convert a\n         sequence into LZ sub-patterns\n\n                  Parameters:\n                          walk (list): a list of LZ - sub-patterns\n\n                  Returns:\n                          float : the probability of generating such a walk (PGEN)\n           \"\"\"\n    if type(walk) == str:\n        LZ, POS = derive_lz_reading_frame_position(walk)\n        walk_ = [i + str(j) for i, j in zip(LZ, POS)]\n    else:\n        walk_ = walk\n\n    proba = self.subpattern_individual_probability['proba'][walk_[0]]\n    for step1, step2 in window(walk_, 2):\n        if self.graph.has_edge(step1, step2):\n            proba *= self.graph.get_edge_data(step1, step2)['weight']\n        else:\n            if verbose:\n                print('No Edge Connecting| ', step1, '--&gt;', step2)\n            return 0\n    return proba\n</code></pre>"},{"location":"ndplgraph_reference/#src.LZGraphs.Graphs.NucleotideDoublePositional.derive_lz_reading_frame_position","title":"<code>derive_lz_reading_frame_position(cdr3)</code>","text":"<p>given a string this function will return the LZ sub-patterns, the reading frame position of each sub-pattern and the start position in the sequence of each sub-patterns in the form of 3 lists.</p> <pre><code>     Parameters:\n             cdr3 (str): a string from which to derive sub-patterns\n\n     Returns:\n             (list,list,list) : (lz_subpatterns,reading_frame_position,position_in_sequence)\n</code></pre> Source code in <code>src\\LZGraphs\\Graphs\\NucleotideDoublePositional.py</code> <pre><code>def derive_lz_reading_frame_position(cdr3):\n    \"\"\"\n         given a string this function will return the LZ sub-patterns, the reading frame position of each sub-pattern\n         and the start position in the sequence of each sub-patterns in the form of 3 lists.\n\n                  Parameters:\n                          cdr3 (str): a string from which to derive sub-patterns\n\n                  Returns:\n                          (list,list,list) : (lz_subpatterns,reading_frame_position,position_in_sequence)\n   \"\"\"\n    lzc = lempel_ziv_decomposition(cdr3)\n    cumlen = []\n    agg=0\n    rf = []\n    for sp in lzc:\n        agg += len(sp)\n        cumlen.append(agg)\n        rf.append((agg - len(sp)) % 3)\n    return lzc, rf, cumlen\n</code></pre>"},{"location":"nodedgesaturation_reference/","title":"Node Edge Saturation Functions","text":""},{"location":"nodedgesaturation_reference/#src.LZGraphs.Utilities.NodeEdgeSaturationProbe.NodeEdgeSaturationProbe","title":"<code>NodeEdgeSaturationProbe</code>","text":"<p>The class supplies methods used to emulate the creation process of an LZGraph without actually running the full creation procedure, rather just accumulate a counter for the number of nodes and edges based on the provided number of sequences.</p> <p>Parameters:</p> Name Type Description Default <code>node_function</code> <code>str</code> <p>the selected node extraction method to use 'naive' - emulate Naive LZGraph extraction / 'ndp'- emulate Nucleotide Double Positional LZGraph / 'aap' - Amino Acid Positional LZGraph.</p> <code>'naive'</code> <p>Attributes:</p> <pre><code>log_memory (dict): a dictionary containing the results of a single test run\n</code></pre> Source code in <code>src\\LZGraphs\\Utilities\\NodeEdgeSaturationProbe.py</code> <pre><code>class NodeEdgeSaturationProbe:\n    \"\"\"\n\n      The class supplies methods used to emulate the creation process of an LZGraph without actually running the full\n      creation procedure, rather just accumulate a counter for the number of nodes and edges based on the provided\n      number of sequences.\n\n      Args:\n          node_function (str): the selected node extraction method to use 'naive' - emulate Naive LZGraph extraction\n           / 'ndp'- emulate Nucleotide Double Positional LZGraph / 'aap' - Amino Acid Positional LZGraph.\n\n      Attributes:\n\n          log_memory (dict): a dictionary containing the results of a single test run\n\n\n      \"\"\"\n\n    def __init__(self, node_function='naive', log_level=1, verbose=False):\n        self.nodes = set()\n        self.edges = set()\n        self.log_memory = dict()\n        self.verbose = verbose\n        self.log_level = log_level\n        self.node_function = None\n        if node_function == 'naive':\n            self.node_function = self.naive_node_extractor\n        elif node_function == 'ndp':\n            self.node_function = self.ndp_node_extractor\n        elif node_function == 'aap':\n            self.node_function = self.aap_node_extractor\n        else:\n            self.node_function = node_function\n\n    def log(self, args):\n        if self.log_level == 1:\n            self.log_memory[args] = {'nodes': len(self.nodes), 'edges': len(self.edges)}\n\n    @staticmethod\n    def naive_node_extractor(seq):\n        \"\"\" This function implements the node extraction procedure used by the Naive LZGraph.\n                             Args:\n                                 seq (str): An sequence of nucleotides or amino acids\n                             Returns:\n                                 list: a list of nodes extract from the given sequence\n           \"\"\"\n        return lempel_ziv_decomposition(seq)\n\n    @staticmethod\n    def ndp_node_extractor(seq):\n        \"\"\" This function implements the node extraction procedure used by the Nucleotide Double Positional LZGraph.\n                                 Args:\n                                     seq (str): An sequence of nucleotides or amino acids\n                                 Returns:\n                                     list: a list of nodes extract from the given sequence\n               \"\"\"\n        LZ, POS, locations = derive_lz_reading_frame_position(seq)\n        nodes_local = list(map(lambda x, y, z: x + str(y) + '_' + str(z), LZ, POS, locations))\n        return nodes_local\n\n    @staticmethod\n    def aap_node_extractor(seq):\n        \"\"\" This function implements the node extraction procedure used by the Amino Acid Positional LZGraph.\n                                   Args:\n                                       seq (str): An sequence of nucleotides or amino acids\n                                   Returns:\n                                       list: a list of nodes extract from the given sequence\n                 \"\"\"\n        LZ, locations = derive_lz_and_position(seq)\n        nodes_local = list(map(lambda x, y: x + '_' + str(y), LZ, locations))\n        return nodes_local\n\n    def test_sequences(self, sequence_list, log_every=1000, iteration_number=None):\n        \"\"\" Given a list of sequences this function will gradually aggregate the nodes that make up the respective\n        LZGraph and log the node and edge counts every K sequences.\n\n        The result will be saved in the log_memory attribute of the class.\n\n\n                Args:\n                    sequence_list (str): A list of nucleotide  or amino acid sequences\n                    log_every (int): after how many sequences to log the number of nodes and edges\n                Returns:\n                    None:\n        \"\"\"\n\n        slen = len(sequence_list)\n        itr = None\n\n        if self.verbose:\n            itr = tqdm(enumerate(sequence_list, start=1), leave=False, position=0, total=slen)\n        else:\n            itr = enumerate(sequence_list, start=1)\n\n        for ax, seq in itr:\n            nodes_local = self.node_function(seq)\n            self.nodes.update(nodes_local)\n            self.edges.update((window(nodes_local, 2)))\n\n            if ax % log_every == 0 or ax &gt;= slen:\n                self.log(ax)\n\n    def _reset(self):\n        self.nodes = set()\n        self.edges = set()\n        self.log_memory = dict()\n\n    def resampling_test(self, sequence_list, n_tests, log_every=1000, sample_size=0):\n        \"\"\" Given a list of sequences this function will gradually aggregate the nodes that make up the respective\n        LZGraph and log the node and edge counts every K sequences.\n        The above procedure will be carried out N times each time starting from X randomly sampled sequences from\n        the given sequence list.\n\n                Args:\n                    sequence_list (str): A list of nucleotide  or amino acid sequences\n                    log_every (int): after how many sequences to log the number of nodes and edges\n                    n_tests (int): the number of realizations to perform\n                    sample_size (int): the number of sequences that will be randomly sampled from sequence_list\n                    at each realization\n                Returns:\n                    list: a list of logs for each realization given by the parameter n_tests\n        \"\"\"\n\n        result = []\n        if sample_size == 0:\n            for n in range(n_tests):\n                np.random.shuffle(sequence_list)\n                self.test_sequences(sequence_list, log_every, n)\n                # save logs\n                # reset aux\n                result.append(self.log_memory.copy())\n                self._reset()\n        else:\n            for n in range(n_tests):\n                np.random.shuffle(sequence_list)\n                self.test_sequences(random.sample(sequence_list, sample_size), log_every, n)\n                # save logs\n                # reset aux\n                result.append(self.log_memory.copy())\n                self._reset()\n        return result\n</code></pre>"},{"location":"nodedgesaturation_reference/#src.LZGraphs.Utilities.NodeEdgeSaturationProbe.NodeEdgeSaturationProbe.aap_node_extractor","title":"<code>aap_node_extractor(seq)</code>  <code>staticmethod</code>","text":"<p>This function implements the node extraction procedure used by the Amino Acid Positional LZGraph. Args:     seq (str): An sequence of nucleotides or amino acids Returns:     list: a list of nodes extract from the given sequence</p> Source code in <code>src\\LZGraphs\\Utilities\\NodeEdgeSaturationProbe.py</code> <pre><code>@staticmethod\ndef aap_node_extractor(seq):\n    \"\"\" This function implements the node extraction procedure used by the Amino Acid Positional LZGraph.\n                               Args:\n                                   seq (str): An sequence of nucleotides or amino acids\n                               Returns:\n                                   list: a list of nodes extract from the given sequence\n             \"\"\"\n    LZ, locations = derive_lz_and_position(seq)\n    nodes_local = list(map(lambda x, y: x + '_' + str(y), LZ, locations))\n    return nodes_local\n</code></pre>"},{"location":"nodedgesaturation_reference/#src.LZGraphs.Utilities.NodeEdgeSaturationProbe.NodeEdgeSaturationProbe.naive_node_extractor","title":"<code>naive_node_extractor(seq)</code>  <code>staticmethod</code>","text":"<p>This function implements the node extraction procedure used by the Naive LZGraph. Args:     seq (str): An sequence of nucleotides or amino acids Returns:     list: a list of nodes extract from the given sequence</p> Source code in <code>src\\LZGraphs\\Utilities\\NodeEdgeSaturationProbe.py</code> <pre><code>@staticmethod\ndef naive_node_extractor(seq):\n    \"\"\" This function implements the node extraction procedure used by the Naive LZGraph.\n                         Args:\n                             seq (str): An sequence of nucleotides or amino acids\n                         Returns:\n                             list: a list of nodes extract from the given sequence\n       \"\"\"\n    return lempel_ziv_decomposition(seq)\n</code></pre>"},{"location":"nodedgesaturation_reference/#src.LZGraphs.Utilities.NodeEdgeSaturationProbe.NodeEdgeSaturationProbe.ndp_node_extractor","title":"<code>ndp_node_extractor(seq)</code>  <code>staticmethod</code>","text":"<p>This function implements the node extraction procedure used by the Nucleotide Double Positional LZGraph. Args:     seq (str): An sequence of nucleotides or amino acids Returns:     list: a list of nodes extract from the given sequence</p> Source code in <code>src\\LZGraphs\\Utilities\\NodeEdgeSaturationProbe.py</code> <pre><code>@staticmethod\ndef ndp_node_extractor(seq):\n    \"\"\" This function implements the node extraction procedure used by the Nucleotide Double Positional LZGraph.\n                             Args:\n                                 seq (str): An sequence of nucleotides or amino acids\n                             Returns:\n                                 list: a list of nodes extract from the given sequence\n           \"\"\"\n    LZ, POS, locations = derive_lz_reading_frame_position(seq)\n    nodes_local = list(map(lambda x, y, z: x + str(y) + '_' + str(z), LZ, POS, locations))\n    return nodes_local\n</code></pre>"},{"location":"nodedgesaturation_reference/#src.LZGraphs.Utilities.NodeEdgeSaturationProbe.NodeEdgeSaturationProbe.resampling_test","title":"<code>resampling_test(sequence_list, n_tests, log_every=1000, sample_size=0)</code>","text":"<p>Given a list of sequences this function will gradually aggregate the nodes that make up the respective LZGraph and log the node and edge counts every K sequences. The above procedure will be carried out N times each time starting from X randomly sampled sequences from the given sequence list.</p> <pre><code>    Args:\n        sequence_list (str): A list of nucleotide  or amino acid sequences\n        log_every (int): after how many sequences to log the number of nodes and edges\n        n_tests (int): the number of realizations to perform\n        sample_size (int): the number of sequences that will be randomly sampled from sequence_list\n        at each realization\n    Returns:\n        list: a list of logs for each realization given by the parameter n_tests\n</code></pre> Source code in <code>src\\LZGraphs\\Utilities\\NodeEdgeSaturationProbe.py</code> <pre><code>def resampling_test(self, sequence_list, n_tests, log_every=1000, sample_size=0):\n    \"\"\" Given a list of sequences this function will gradually aggregate the nodes that make up the respective\n    LZGraph and log the node and edge counts every K sequences.\n    The above procedure will be carried out N times each time starting from X randomly sampled sequences from\n    the given sequence list.\n\n            Args:\n                sequence_list (str): A list of nucleotide  or amino acid sequences\n                log_every (int): after how many sequences to log the number of nodes and edges\n                n_tests (int): the number of realizations to perform\n                sample_size (int): the number of sequences that will be randomly sampled from sequence_list\n                at each realization\n            Returns:\n                list: a list of logs for each realization given by the parameter n_tests\n    \"\"\"\n\n    result = []\n    if sample_size == 0:\n        for n in range(n_tests):\n            np.random.shuffle(sequence_list)\n            self.test_sequences(sequence_list, log_every, n)\n            # save logs\n            # reset aux\n            result.append(self.log_memory.copy())\n            self._reset()\n    else:\n        for n in range(n_tests):\n            np.random.shuffle(sequence_list)\n            self.test_sequences(random.sample(sequence_list, sample_size), log_every, n)\n            # save logs\n            # reset aux\n            result.append(self.log_memory.copy())\n            self._reset()\n    return result\n</code></pre>"},{"location":"nodedgesaturation_reference/#src.LZGraphs.Utilities.NodeEdgeSaturationProbe.NodeEdgeSaturationProbe.test_sequences","title":"<code>test_sequences(sequence_list, log_every=1000, iteration_number=None)</code>","text":"<p>Given a list of sequences this function will gradually aggregate the nodes that make up the respective LZGraph and log the node and edge counts every K sequences.</p> <p>The result will be saved in the log_memory attribute of the class.</p> <pre><code>    Args:\n        sequence_list (str): A list of nucleotide  or amino acid sequences\n        log_every (int): after how many sequences to log the number of nodes and edges\n    Returns:\n        None:\n</code></pre> Source code in <code>src\\LZGraphs\\Utilities\\NodeEdgeSaturationProbe.py</code> <pre><code>def test_sequences(self, sequence_list, log_every=1000, iteration_number=None):\n    \"\"\" Given a list of sequences this function will gradually aggregate the nodes that make up the respective\n    LZGraph and log the node and edge counts every K sequences.\n\n    The result will be saved in the log_memory attribute of the class.\n\n\n            Args:\n                sequence_list (str): A list of nucleotide  or amino acid sequences\n                log_every (int): after how many sequences to log the number of nodes and edges\n            Returns:\n                None:\n    \"\"\"\n\n    slen = len(sequence_list)\n    itr = None\n\n    if self.verbose:\n        itr = tqdm(enumerate(sequence_list, start=1), leave=False, position=0, total=slen)\n    else:\n        itr = enumerate(sequence_list, start=1)\n\n    for ax, seq in itr:\n        nodes_local = self.node_function(seq)\n        self.nodes.update(nodes_local)\n        self.edges.update((window(nodes_local, 2)))\n\n        if ax % log_every == 0 or ax &gt;= slen:\n            self.log(ax)\n</code></pre>"},{"location":"tutorials/","title":"Tutorials for LZGraphs","text":"<p>Welcome to the tutorials page for LZGraphs, where you will find step-by-step guides on leveraging the power of LZGraphs for T-cell receptor beta chain (TCRB) repertoire analysis. Whether you are constructing graphs or exploring advanced features, these tutorials are designed to enhance your understanding and utilization of LZGraphs in your research endeavors.</p>"},{"location":"tutorials/#getting-started-with-graph-construction","title":"Getting Started with Graph Construction","text":"<p>LZGraphs offers various graph types to suit your analysis needs, including Amino Acid Positional, Nucleotide Double Positional, and Naive graphs. Each graph type is tailored to specific aspects of TCRB repertoire analysis, providing a versatile toolkit for your research.</p>"},{"location":"tutorials/#amino-acid-positional-and-nucleotide-double-positional-graphs","title":"Amino Acid Positional and Nucleotide Double Positional Graphs","text":"<p>These graph types are pivotal for in-depth TCRB repertoire analysis. Follow the example below to construct an Amino Acid Positional graph. The process is analogous for Nucleotide Double Positional Graphs, with minor adjustments as noted.</p>"},{"location":"tutorials/#essential-points","title":"Essential Points:","text":"<ul> <li>For Nucleotide Double Positional Graphs, use \"cdr3_rearrangement\" as the column name for sequences.</li> <li>For Amino Acid Positional Graphs, the sequence column should be \"cdr3_amino_acid\".</li> <li>V and J genes/alleles are categorized under \"V\" and \"J\" columns, respectively. This genetic information enriches the graph and enhances sequence generation and genomic insights.</li> <li>Including V/J genes/alleles is optional but recommended for comprehensive analysis.</li> </ul> <p><pre><code>from LZGraphs import AAPLZGraph\nimport pandas as pd\n\n# Load your data\ndata = pd.read_csv(\"/path/to/data/file.csv\")\n\n# Construct the graph\nlzgraph = AAPLZGraph(data, verbose=True)\n</code></pre> Verbose: <pre><code>Gene Information Loaded.. |  0.01  Seconds\nGraph Constructed.. |  0.94  Seconds\nGraph Metadata Derived.. |  0.94  Seconds\nIndividual Subpattern Empirical Probability Derived.. |  0.98  Seconds\nGraph Edge Weight Normalized.. |  1.0  Seconds\nGraph Edge Gene Weights Normalized.. |  1.13  Seconds\nTerminal State Map Derived.. |  1.2  Seconds\nIndividual Subpattern Empirical Probability Derived.. |  1.37  Seconds\nTerminal State Map Derived.. |  1.37  Seconds\nLZGraph Created Successfully.. |  1.37  Seconds\n==============================\n</code></pre> The data file is a pandas DataFrame that includes the sequences under a column named \"cdr3_amino_acid\". Optionally, it can also have \"V\" and \"J\" columns containing  relevant genomic information such as Gene/Family/Allele. Any one of these columns can be used to create a graph,  with functionality constrained by the genetic information on the edges.</p> <p>Example of the input DataFrame:</p> cdr3_amino_acid V J CASSLEPSGGTDTQYF TRBV16-1*01 TRBJ1-2*01 CASSDTSGGTDTQYF TRBV1-1*01 TRBJ1-5*01 CASSLEPQTFTDTFFF TRBV16-1*01 TRBJ2-7*01"},{"location":"tutorials/#constructing-a-naive-lzgraph","title":"Constructing a Naive LZGraph","text":"<p>Below is an example of constructing a Naive LZGraph.</p> <p><pre><code>from src.LZGraphs.Graphs.Naive import NaiveLZGraph, generate_dictionary\n\nlist_of_sequences = ['TGTGCCAGCAGGGCGGGATACGCAGTATTT',\n                     'TGTGCCAGCAGCCAGCATCGTCGCAGTATTTT'\n                     'TGTGCCAGCAGCCAGCAGGGCCGGGATACGCAGTATTTT'\n                     ...]\n\n# generate all possible nodes with kmers up to length 6                 \ndictionary = generate_dictionary(6)\n# construct a NaiveLZGraph from your list_of_sequences based on the generated dictionary\nlzgraph = NaiveLZGraph(list_of_sequences, dictionary, verbose=True)\n</code></pre> Note:</p> <ul> <li>The <code>generate_dictionary</code> function takes an integer <code>(X)</code> and generates all possible patterns that can be constructed from <code>(X)</code> nucleotides. For CDR3 sequences, we suggest using <code>X=6</code> as the maximum observed sub-pattern length in the CDR3 region is 6.</li> <li>The dictionary can be replaced with any number of sub-patterns if not all combinations are desired.</li> <li>The Naive LZGraph is most relevant in the context of nucleotides, as amino acid CDR3 sequences result in sparse graphs.</li> </ul>"},{"location":"tutorials/#exploring-graph-attributes","title":"Exploring Graph Attributes","text":"<p>After constructing an LZGraph, there are several attributes available to quickly infer repertoire statistical properties as well as explore the graph object itself, built above the networkx DiGraph class. Below are examples of how you can evaluate and explore those attributes.</p>"},{"location":"tutorials/#amino-acid-positional-and-nucleotide-double-positional-graphs_1","title":"Amino Acid Positional and Nucleotide Double Positional Graphs","text":""},{"location":"tutorials/#exploring-graph-nodes-and-edges","title":"Exploring Graph Nodes and Edges","text":"<p><pre><code># Retrieving the list of all graph nodes / edges\nnode_list = list(lzgraph.nodes)\nedge_list = list(lzgraph.edges) \n\nprint('First 10 Nodes: ',list(lzgraph.nodes)[:10])\nprint('First 10 Edges: ',list(lzgraph.edges)[:10])\n</code></pre> Output: <pre><code>First 10 Nodes:  ['C_1', 'A_2', 'S_3', 'SQ_5', 'Q_6', 'G_7', 'R_8', 'D_9', 'T_10', 'QY_12']\nFirst 10 Edges:  [('C_1', 'A_2'), ('C_1', 'T_2'), ('C_1', 'V_2'), ('C_1', 'S_2'), ('C_1', 'R_2'), ('C_1', 'G_2'), ('C_1', 'D_2'), ('C_1', 'F_2'), ('C_1', 'I_2'), ('A_2', 'S_3')]\n</code></pre></p>"},{"location":"tutorials/#distribution-of-observed-sequence-lengths","title":"Distribution of Observed Sequence Lengths:","text":"<p>After fitting an LZGraph to a repertoire you can quickly access the distribution of different sequence lengths observed in the repertoire:</p> <p><pre><code>print(lzgraph.lengths)\n</code></pre> Output: <pre><code>{13: 2973, 15: 5075, 14: 4412, 16: 2862,\n 12: 1147, 17: 1401, 19: 268, 22: 11, 20: 108,\n 11: 508, 18: 655, 21: 38, 10: 72,\n 24: 1, 9: 14, 7: 2, 4: 1,8: 1}\n</code></pre> Note: The key of the dictionary is an observed sequence length, the value corresponds to the total number of sequences observed matching the key length.</p>"},{"location":"tutorials/#exploring-graph-initial-and-terminal-states","title":"Exploring Graph Initial and Terminal States:","text":"<p>Initial state is defined as the first sub-pattern observed in a sequence,  Terminal state is the last sub-pattern observed in a sequence, the lists and counts  of all observed initial and final states are saved in every LZGraph and can be   accessed:</p>"},{"location":"tutorials/#getting-all-the-initial-states","title":"Getting all the initial states","text":"<p><pre><code># Getting all the initial states\ninit_states = lzgraph.initial_states\nprint(init_states)\n</code></pre> Output: <pre><code>C_1    19523\nR_1       20\ndtype: int64\n</code></pre></p>"},{"location":"tutorials/#getting-all-the-terminal-states","title":"Getting all the terminal states","text":"<p><pre><code>term_states = lzgraph.print(lzgraph.terminal_states)\nprint(term_states)\n</code></pre> Output: <pre><code>F_13      2672\nF_15      4490\nF_14      3860\nF_16      2502\nF_12      1028\n          ... \nG_9          1\nAFF_12       1\nFF_11        1\nF_8          1\nHF_22        1\nLength: 86, dtype: int64\n</code></pre></p>"},{"location":"tutorials/#graph-v-and-j-marginal-distributions","title":"Graph V and J Marginal Distributions:","text":"<p>If V and J annotation were provided while constructing the graph, the genetic data was embedded into each edge of the graph. The marginal probability of each gene/allele can be observed by the following way: <pre><code># print(lzgraph.marginal_vgenes)\nprint(lzgraph.marginal_jgenes)\n</code></pre> Output: <pre><code>TRBJ1-2*01    0.159804\nTRBJ1-1*01    0.143588\nTRBJ2-7*01    0.141951\nTRBJ2-1*01    0.090081\nTRBJ2-3*01    0.088086\nTRBJ1-5*01    0.076986\nTRBJ2-5*01    0.075963\nTRBJ2-2*01    0.057343\nTRBJ1-4*01    0.050437\nTRBJ1-6*01    0.047675\nTRBJ1-3*01    0.043787\nTRBJ2-6*01    0.015500\nTRBJ2-4*01    0.008798\nName: J, dtype: float64\n</code></pre></p>"},{"location":"tutorials/#calculating-the-lzcentrality","title":"Calculating the LZCentrality","text":"<p>The <code>LZGraph</code> library provides a function, <code>LZCentrality</code>, for calculating the LZCentrality of a given CDR3 sequence in a repertoire represented by an LZGraph. The LZCentrality is a measure of sequence centrality within a repertoire, as presented in our paper.</p> <p>Here's how you can use the <code>LZCentrality</code> function:</p> <pre><code>from src.LZGraphs import LZCentrality, NDPLZGraph\n\n# Assume we have a list of CDR3 sequences and a sequence of interest\nsequences = [\"sequence1\", \"sequence2\", \"sequence3\", ...]\nsequence_of_interest = \"sequence1\"\n\n# Create an LZGraph\ngraph = NDPLZGraph(sequences)\n\n# Calculate the LZCentrality\nlzcentrality = LZCentrality(graph, sequence_of_interest)\nprint(f\"The LZCentrality of {sequence_of_interest} is {lzcentrality}\")\n</code></pre> <p>In this example, <code>NDPLZGraph</code> is the LZGraph class used. You can replace it with any other LZGraph class, such as <code>AAPLZGraph</code>.</p> <p>This function provides an efficient and scalable way to calculate the LZCentrality, allowing you to gain important insights into the centrality of a sequence within a TCRB repertoire.</p>"},{"location":"tutorials/#calculating-the-k1000-diversity-index","title":"Calculating the K1000 Diversity Index","text":"<p>The <code>LZGraph</code> library provides a convenient function, <code>K1000_Diversity</code>, for calculating the K1000 Diversity index of a list of CDR3 sequences. This index, as presented in our paper, offers a new way to measure the diversity of a repertoire.</p> <p>Here's how you can use the <code>K1000_Diversity</code> function:</p> <pre><code>from src.LZGraphs.Metircs.Metrics import K1000_Diversity\nfrom src.LZGraphs import AAPLZGraph\n\n# Assume we have a list of CDR3 sequences\nsequences = [\"sequence1\", \"sequence2\", \"sequence3\", ...]\n\n# Calculate the K1000 Diversity index\nk1000 = K1000_Diversity(sequences, AAPLZGraph.encode_sequence, draws=30)\nprint(f\"The K1000 Diversity index is {k1000}\")\n</code></pre> <p>In this example, <code>AAPLZGraph.encode_sequence</code> is the LZGraph encoding function used. You can replace it with any other LZGraph encoding function, such as <code>NDPLZGraph.encode_sequence</code>.</p> <p>The <code>draws</code> parameter specifies the number of draws for the resampling test. The higher the value, the more realizations will be generated for the K1000 index, and the returned mean value will be a better approximation.</p> <p>The <code>K1000_Diversity</code> function works by resampling the list of sequences and building LZGraphs based on the provided encoding function. The resampling is performed <code>draws</code> number of times, with each resampled set containing 1000 unique sequences. For each resampled set, the K1000 Diversity index is calculated using the 'nodes' value of the last item in the result dictionary obtained from the NodeEdgeSaturationProbe's resampling test. The average K1000 Diversity index from all the resampling tests is then returned.</p> <p>This function provides an efficient and scalable way to calculate the K1000 Diversity index, allowing you to gain important insights into the diversity of a TCRB repertoire.</p>"},{"location":"tutorials/#deriving-sequence-generation-probability-pgen","title":"Deriving Sequence Generation Probability (Pgen)","text":"<p>After an LZGraph is derived for a given repertoire, one can assess the generation probability (Pgen) of a new sequence with respect to that repertoire (LZGraph). <pre><code>new_sequence = \"CASRGERGDNEQFF\"\n# encode the sequence into relevant graph format\nencoded_sequence = AAPLZGraph.encode_sequence(new_sequence)\n#output\n# ['C_1', 'A_2', 'S_3', 'R_4', 'G_5', 'E_6', 'RG_8', 'D_9', 'N_10', 'EQ_12', 'F_13', 'F_14']\n\npgen = lzgraph.walk_probability(encoded_sequence)\nprint(f'{new_sequence} Pgen: {pgen}')\n</code></pre> Output: <pre><code>CASRGERGDNEQFF Pgen: 6.692834748776949e-13\n</code></pre></p>"},{"location":"tutorials/#generating-new-sequences","title":"Generating New Sequences","text":"<p>An LZGraph constructed from a source repertoire can generate new sequences following the statistical properties observed in the source. Note that that if V and J genes were provided the generation function will be testing that the random sequence and their sub-pattern all are associated to initially random V and J genes selected before generating the sequence. <pre><code>generated_walk,selected_v,selected_j = lzgraph.genomic_random_walk()\n# replace genomic_random_walk with random_walk() if annotation was not provided\nprint(generated_walk,selected_v,selected_j)\n</code></pre> Output: <pre><code>['C_1', 'S_2', 'A_3', 'T_4', 'G_5', 'GI_7', 'Q_8', 'Y_9', 'QE_11', 'TQ_13', 'YF_15'],\n'TRBV29-1*01',\n'TRBJ2-5*01'\n</code></pre> You can transform the resulting walk back into a sequence by cleaning each node and concatenating them into a single string. Each LZGraph has a \"clean_node\" method that accompanies the relevant \"encode_sequence\" method. <pre><code>clean_sequence = ''.join([AAPLZGraph.clean_node(node) for node in generated_walk])\n# Note that AAPLZGraph needs to be replaced in case you used the NDPLZGraph\nprint(clean_sequence)\n</code></pre> Output: <pre><code>CASSPGTGGTGELFF\n</code></pre></p>"},{"location":"tutorials/#feature-vector-from-graph-eigen-centrality","title":"Feature Vector From Graph (Eigen Centrality)","text":"<p>One can derive a vector representation of an LZGraph in order to perform any modeling task. The resulting vector in a sense capture the structural dynamics of  a repertoire. Note that the number of features in the resulting vector equal the number of nodes in the graph, and the value in each node correspond to each node, so it is recommended using the Naive LZGraph, this allows to create LZGraphs to different repertoires while maintaining the same dictionary of sub-patterns (nodes).</p> <p><pre><code>from src.LZGraphs.Graphs.Naive import NaiveLZGraph, generate_dictionary\n\n# Create a dictionary that will be shared between all repertoires\ndictionary = generate_dictionary(6)\n# create a graph, this can be done in a loop over many repertoires\nlzgraph = NaiveLZGraph(list_of_sequences, dictionary, verbose=True)\n# derive the feature vector\nfeature_vector = lzgraph.eigenvector_centrality()\nprint(pd.Series(feature_vector))\n</code></pre> Output: <pre><code>A         3.009520e-01\nT         1.183398e-01\nG         1.186366e-01\nC         2.461758e-01\nAA        1.252643e-01\n              ...     \nCCCCGC    5.252576e-10\nCCCCCA    5.252576e-10\nCCCCCT    5.252576e-10\nCCCCCG    5.252576e-10\nCCCCCC    5.252576e-10\nLength: 5460, dtype: float64\n</code></pre></p> <p>Note: The <code>generate_dictionary</code> function given the value 6 return <code>5460</code> sub-patterns, many of which may not exist in your graph, nonetheless this promises that all the repertoires encoded will produce the same feature vector dimension but the value across the different sub-pattern will be different.</p>"},{"location":"tutorials/#plotting-graph-related-features","title":"Plotting Graph Related Features","text":"<p>The library provides multiple plots that can be useful when analyzing sequence and comparing between sequences.</p>"},{"location":"tutorials/#ancestors-descendants-curves-plot","title":"Ancestors Descendants Curves Plot","text":"<p>In this chart you can examine at each sub-pattern of a given sequence the amount descendants nodes reachable at each node contained in your sequence, as well as the amount of ancestors at each node. Sequence with different attribute differ both by the slope and the convergence rate of these curve as well as by the intersection point between the curves.</p> <p><pre><code>from src.LZGraphs.Visualization.Visualize import ancestors_descendants_curves_plot\n\nsequence = 'CASTPGTASGYTF'\nancestors_descendants_curves_plot(lzgraph, sequence)\n</code></pre> Output: </p>"},{"location":"tutorials/#sequence-possible-paths-plot","title":"Sequence Possible Paths Plot","text":"<p>In this chart we look at a reduced and immediate version of Descendants curve. For each sub-pattern derived from a given sequence and based on an LZGraph, We can examine the number of alternatives there are at each node, this indicates the rarity of a sequence and is correlated with the difference from the  mean Levenshtein distance of the repertoire as shown in the LZGraphs paper.</p> <p><pre><code>from src.LZGraphs.Visualization.Visualize import sequence_possible_paths_plot\n\nsequence = 'CASTPGTASGYTF'\nsequence_possible_paths_plot(lzgraph, sequence)\n</code></pre> Output: </p>"},{"location":"tutorials/#node-genomic-variability-plot","title":"Node Genomic Variability Plot","text":"<p>In this chart we look at the number of V and J genes/alleles per node in a given sequence with respect to a given repertoire. Not only can one infer the sub-patterns in a sequence that have the exceptional number of V and J alternatives but also when comparing between the same sequence in different repertoires (different LZGraphs) one can infer the amount difference at each sub-pattern between the two repertoires.</p> <p><pre><code>from src.LZGraphs.Visualization.Visualize import sequence_genomic_node_variability_plot\n\nsequence = 'CASTPGTASGYTF'\nsequence_genomic_node_variability_plot(lzgraph, sequence)\n</code></pre> Output: </p>"},{"location":"tutorials/#edge-genomic-variability-plot","title":"Edge Genomic Variability Plot","text":"<p>In this chart we look at the number of V and J genes/alleles per edge in a given sequence with respect to a given repertoire.</p> <ul> <li>Allele/gene names colored in red signify that the allele/gene appeared in all the edges in the given sequence.</li> <li>Black cells signify that this spesific allele/gene wasnt observed at that edge.</li> <li>The color gradient at each cell represents the probability of choosing that edge under the constraint of having  that specific V/J.</li> </ul> <p><pre><code>from src.LZGraphs.Visualization.Visualize import sequence_genomic_edges_variability_plot\n\nsequence = 'CASTPGTASGYTF'\nsequence_genomic_edges_variability_plot(lzgraph, sequence)\n</code></pre> Output: </p>"},{"location":"tutorials/#bow-vectorizer","title":"BOW Vectorizer","text":"<p>The library also provides a convenient class implementing the BOW logic presented in the paper. Note that each instance of the BOW wrapper class has to fitted on a list of sequences (repertoire) before it can transform new lists of sequences into BOW vectors.</p> <pre><code>from src.LZGraphs import LZBOW\nfrom src.LZGraphs import NDPLZGraph\n\nsequence_list = data.cdr3_rearrangement.to_list()\n\n# create vectorizer and choose the Nucleotide Double Positional (ndp) encdoing function (default is Naive)\nvectorizer = LZBOW(encoding_function=NDPLZGraph.encode_sequence)\n\n# fit on sequence list\nvectorizer.fit(sequence_list)\n\n# BOW dictionary\nvectorizer.dictionary\n\nbow_vector = vectorizer.transform(new_list_of_sequences)\n</code></pre>"},{"location":"utilities_reference/","title":"Utilities Functions","text":""},{"location":"utilities_reference/#src.LZGraphs.Utilities.Utilities.graph_union","title":"<code>graph_union(graphA, graphB)</code>","text":"<p>This function performs a union operation between two graphs, graphA will be updated to be the equivalent of the union of both. The result is logically equal to constructing a graph out of the union sequences, of two separate repertoires.</p> <pre><code>         Args:\n             graphA (LZGraph): An LZGraph\n             graphB (LZGraph)  An LZGraph of the same class as graphA\n         Returns:\n             LZGraph: The resulting LZGraph from the union of graphA and graphB\n</code></pre> Source code in <code>src\\LZGraphs\\Utilities\\Utilities.py</code> <pre><code>def graph_union(graphA,graphB):\n    \"\"\" This function performs a union operation between two graphs, graphA will be updated to be the\n    equivalent of the union of both.\n    The result is logically equal to constructing a graph out of the union sequences, of two separate repertoires.\n\n                 Args:\n                     graphA (LZGraph): An LZGraph\n                     graphB (LZGraph)  An LZGraph of the same class as graphA\n                 Returns:\n                     LZGraph: The resulting LZGraph from the union of graphA and graphB\n           \"\"\"\n\n\n    if type(graphA) != type(graphB):\n        raise Exception('Both Graphs Must Be of Same Type!')\n\n    if type(graphA) == NaiveLZGraph:\n        pass\n    else:\n        #graphA.genetic_walks_black_list.merge(graphB.genetic_walks_black_list if type(graphB.genetic_walks_black_list) is not None else {})\n        graphA.n_subpatterns += graphB.n_subpatterns\n        graphA.initial_states = graphA.initial_states.combine(graphB.initial_states, lambda x, y: x + y, fill_value=0)\n\n        # not necceseray\n        # lengths\n        # observed_vgenes\n        # observed_jgenes\n        # dictionary\n        # n_transitions\n        # edges_list\n\n        graphA.marginal_vgenes = (graphA.marginal_vgenes.combine(graphB.marginal_vgenes, lambda x, y: x + y,\n                                                               fill_value=0)) / 2\n        graphA.vj_probabilities = (graphA.vj_probabilities.combine(graphB.vj_probabilities, lambda x, y: x + y,\n                                                                 fill_value=0)) / 2\n        graphA.length_distribution = (\n            graphA.length_distribution.combine(graphB.length_distribution, lambda x, y: x + y, fill_value=0))\n        graphA.terminal_states = (graphA.terminal_states.combine(graphB.terminal_states, lambda x, y: x + y, fill_value=0))\n        graphA.length_distribution_proba = (graphA.length_distribution_proba.combine(graphB.length_distribution_proba,\n                                                                                   lambda x, y: x + y,\n                                                                                   fill_value=0)) / 2\n        graphA.subpattern_individual_probability = (graphA.subpattern_individual_probability.combine(\n            graphB.subpattern_individual_probability, lambda x, y: x + y, fill_value=0)) / 2\n\n\n        # recalculate\n        #terminal_state_map\n        #terminal_state_data\n\n        union_graph = nx.digraph.DiGraph()\n        union_graph.add_nodes_from(set(graphA.nodes) | set(graphB.nodes))\n\n\n        for node in tqdm(set(graphA.nodes) | set(graphB.nodes)):\n            if (node in graphA.per_node_observed_frequency) and (node in graphB.per_node_observed_frequency):\n                h1 = pd.DataFrame(dict(graphA.graph[node]))\n                h2 = pd.DataFrame(dict(graphB.graph[node]))\n\n                if len(h1) == 0 and len(h2) == 0:\n                    continue\n\n                # renormalize weight\n                h1_node_sum = graphA.per_node_observed_frequency[node]\n                h2_node_sum = graphB.per_node_observed_frequency[node]\n\n                if 'weight' in h1.index:\n                    h1.loc['weight', :] *= h1_node_sum\n                    h1 = h1.apply(restore_gene_counts)\n                if 'weight' in h2.index:\n                     h2.loc['weight', :] *= h2_node_sum\n                     h2 = h2.apply(restore_gene_counts)\n\n\n                factor = (h1_node_sum + h2_node_sum)\n\n                c = h1.combine(h2, lambda x, y: x + y, fill_value=0).replace(0, np.nan)\n                c.loc['weight', :] /= factor\n                # gene renormalization\n                c = c.apply(renormalize_edege_genes)\n                c = c.round(10)\n\n                # save new counts\n                graphA.per_node_observed_frequency[node] = factor\n\n                # update new graph\n                for column in c.columns:\n                    union_graph.add_edge(node, column)\n                    for key in c.index:\n                        union_graph[node][column][key] = c[column][key]\n            elif node in graphA.per_node_observed_frequency and node not in graphB.per_node_observed_frequency:\n                c = pd.DataFrame(dict(graphA.graph[node]))\n                # save new counts\n                for column in c.columns:\n                    union_graph.add_edge(node, column)\n                    for key in c.index:\n                        union_graph[node][column][key] = c[column][key]\n                continue\n            elif node in graphB.per_node_observed_frequency:\n                c = pd.DataFrame(dict(graphB.graph[node]))\n                # save new counts\n                graphA.per_node_observed_frequency[node] = graphB.per_node_observed_frequency[node]\n                # update new graph\n                for column in c.columns:\n                    union_graph.add_edge(node, column)\n                    for key in c.index:\n                        union_graph[node][column][key] = c[column][key]\n\n        graphA.graph = union_graph\n</code></pre>"},{"location":"utilities_reference/#src.LZGraphs.Utilities.Utilities.renormalize_edege_genes","title":"<code>renormalize_edege_genes(column)</code>","text":"<p>This function is used during the graph union operation, it normalizes the gene counts by the total number of observed v / j genes/alleles.                 Args:                     column (pandas Series): An LZGraph                 Returns:                     pandas Series: padnas series of v and j counts instead of probabilites</p> Source code in <code>src\\LZGraphs\\Utilities\\Utilities.py</code> <pre><code>def renormalize_edege_genes(column):\n    \"\"\" This function is used during the graph union operation, it normalizes the gene counts by the total number\n    of observed v / j genes/alleles.\n                    Args:\n                        column (pandas Series): An LZGraph\n                    Returns:\n                        pandas Series: padnas series of v and j counts instead of probabilites\n              \"\"\"\n    vgs, jgs = [], []\n    # total number of observed V genes/alleles\n    vsum = column['Vsum']\n    # total number of observed J genes/alleles\n    jsum = column['Jsum']\n    # extract v and j columns\n    for col in column.index:\n        if 'BV' in col:\n            vgs.append(col)\n        elif 'BJ' in col:\n            jgs.append(col)\n\n    column[vgs] /= vsum\n    column[jgs] /= jsum\n\n    return column\n</code></pre>"},{"location":"utilities_reference/#src.LZGraphs.Utilities.Utilities.restore_gene_counts","title":"<code>restore_gene_counts(column)</code>","text":"<p>This function is used during the graph union operation, it converts the gene probability distribution at each edge back to a count vector.                 Args:                     column (pandas Series): An LZGraph                 Returns:                     pandas Series: padnas series of v and j counts instead of probabilites</p> Source code in <code>src\\LZGraphs\\Utilities\\Utilities.py</code> <pre><code>def restore_gene_counts(column):\n    \"\"\" This function is used during the graph union operation, it converts the gene probability distribution at each\n        edge back to a count vector.\n                        Args:\n                            column (pandas Series): An LZGraph\n                        Returns:\n                            pandas Series: padnas series of v and j counts instead of probabilites\n      \"\"\"\n    vgs, jgs = [], []\n    # total number of observed V genes/alleles\n    vsum = column['Vsum']\n    # total number of observed J genes/alleles\n    jsum = column['Jsum']\n    # extract v and j columns\n    for col in column.index:\n        if 'BV' in col:\n            vgs.append(col)\n        elif 'BJ' in col:\n            jgs.append(col)\n\n    column[vgs] *= vsum\n    column[jgs] *= jsum\n\n    return column\n</code></pre>"},{"location":"visualize_reference/","title":"Visualize Functions","text":""},{"location":"visualize_reference/#src.LZGraphs.Visualization.Visualize.ancestors_descendants_curves_plot","title":"<code>ancestors_descendants_curves_plot(graph, sequence)</code>","text":"<p>Generate a Matplotlib plot that shows the number of ancestor and descendant nodes for each node in a given sequence.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>LZGraph</code> <p>An LZGraph object that was embedded with gene annotations.</p> required <p>Returns:     None: Shows figure via plt.show()</p> Source code in <code>src\\LZGraphs\\Visualization\\Visualize.py</code> <pre><code>def ancestors_descendants_curves_plot(graph,sequence):\n    \"\"\" Generate a Matplotlib plot that shows the number of ancestor and descendant nodes for each node in a given sequence.\n\n                 Args:\n                     graph (LZGraph): An LZGraph object that was embedded with gene annotations.\n                     sequence (str) A sequence of nucleotides/amino-acids depending on the LZGraph passed.\n                 Returns:\n                     None: Shows figure via plt.show()\n           \"\"\"\n    descendants_curve = []\n    ancestors_curve = []\n\n    for node in graph.encode_sequence(sequence):\n        descendants = nx.descendants(graph.graph, node)\n        descendants_curve.append(len(descendants))\n        ancestors = nx.ancestors(graph.graph, node)\n        ancestors_curve.append(len(ancestors))\n    ancestors_curve = np.array(ancestors_curve)\n    descendants_curve = np.array(descendants_curve)\n    # out_values =np.array( [(lzg.graph.out_degree(i)) for i in encode_sequence(sequence)])\n\n    plt.title(sequence)\n    ax = sns.lineplot(x=np.arange(len(descendants_curve)), y=descendants_curve, label='Descendants Curve',\n                      color='tab:orange')\n    ax.set_ylabel('Number of Descendants')\n    ax2 = ax.twinx()\n\n    sns.lineplot(x=np.arange(len(descendants_curve)), y=ancestors_curve, label='Ancestors Curve', ax=ax2)\n    ax2.set_ylabel('Number of Ancestors')\n\n    plt.xticks(np.arange(len(descendants_curve)), labels=lempel_ziv_decomposition(sequence), rotation=45)\n    plt.grid(lw=2, ls=':')\n    plt.xlabel('LZ Sub-pattern')\n    plt.show()\n</code></pre>"},{"location":"visualize_reference/#src.LZGraphs.Visualization.Visualize.draw_graph","title":"<code>draw_graph(graph, file_name='LZGraph.png')</code>","text":"<p>Generate a plot of a given graph and save is in project folder.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>LZGraph</code> <p>An LZGraph object that was embedded with gene annotations.</p> required <p>Returns:     None: Shows figure via plt.show()</p> Source code in <code>src\\LZGraphs\\Visualization\\Visualize.py</code> <pre><code>def draw_graph(graph,file_name='LZGraph.png'):\n    \"\"\" Generate a plot of a given graph and save is in project folder.\n\n                 Args:\n                     graph (LZGraph): An LZGraph object that was embedded with gene annotations.\n                     file_name (str) the name of the saved image.\n                 Returns:\n                     None: Shows figure via plt.show()\n    \"\"\"\n    #initialze Figure\n    plt.figure(num=None, figsize=(30, 30), dpi=300)\n    plt.axis('off')\n    fig = plt.figure(1)\n    pos = nx.spring_layout(graph)\n    nx.draw_networkx_nodes(graph,pos,alpha=0.3,node_size=100)\n    nx.draw_networkx_edges(graph,pos,alpha=0.3)\n    #nx.draw_networkx_labels(graph,pos)\n\n    plt.savefig(file_name,bbox_inches=\"tight\")\n    pylab.close()\n    del fig\n</code></pre>"},{"location":"visualize_reference/#src.LZGraphs.Visualization.Visualize.sequence_genomic_edges_variability_plot","title":"<code>sequence_genomic_edges_variability_plot(graph, cdr3_sample, threshold=None, figsize=None)</code>","text":"<p>Generate a Matplotlib plot that shows the distribution of V and J genes at each edge in a given sequence.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>LZGraph</code> <p>An LZGraph object that was embedded with gene annotations.</p> required <p>Returns:     None: Shows figure via plt.show()</p> Source code in <code>src\\LZGraphs\\Visualization\\Visualize.py</code> <pre><code>def sequence_genomic_edges_variability_plot(graph, cdr3_sample, threshold=None, figsize=None):\n    \"\"\" Generate a Matplotlib plot that shows the distribution of V and J genes at each edge in a given sequence.\n\n              Args:\n                  graph (LZGraph): An LZGraph object that was embedded with gene annotations.\n                  cdr3_sample (str) A sequence of nucleotides/amino-acids depending on the LZGraph passed.\n                  threshold (float)  Default = None, if a value between 0-1 that controls the percentage of complete paths to show.\n                  figsize (int) the size of the matplotlib figure.\n              Returns:\n                  None: Shows figure via plt.show()\n        \"\"\"\n    vgene_table, jgene_table = graph.path_gene_table(cdr3_sample, threshold)\n    plt.figure(figsize=(15, 8) if figsize is None else figsize)\n    plt.subplot(1, 2, 1)\n    ax = sns.heatmap(jgene_table.iloc[:, :-2],\n                     xticklabels=[graph.clean_node(i.split('-&gt;')[0]) + '-&gt;' + graph.clean_node(i.split('-&gt;')[1]) for i in\n                                  jgene_table.columns[:-2]],\n                     cmap='coolwarm', linewidths=3)\n    ax.set_facecolor('xkcd:black')\n\n    label_col_vals = jgene_table.iloc[:, :-2].isna().any(axis=1)\n    for i in ax.get_yticklabels():\n        if not label_col_vals[i.get_text()]:\n            i.set_color(\"red\")\n\n    plt.subplot(1, 2, 2)\n    ax = sns.heatmap(vgene_table.iloc[:, :-2],\n                     xticklabels=[graph.clean_node(i.split('-&gt;')[0]) + '-&gt;' + graph.clean_node(i.split('-&gt;')[1]) for i in\n                                  jgene_table.columns[:-2]],\n                     cmap='coolwarm', linewidths=3, yticklabels=vgene_table.index)\n\n    label_col_vals = vgene_table.iloc[:, :-2].isna().any(axis=1)\n    for i in ax.get_yticklabels():\n        if not label_col_vals[i.get_text()]:\n            i.set_color(\"red\")\n\n    ax.set_facecolor('xkcd:black')\n    plt.gcf().suptitle(cdr3_sample, fontsize=26)\n\n    plt.tight_layout()\n    plt.show()\n</code></pre>"},{"location":"visualize_reference/#src.LZGraphs.Visualization.Visualize.sequence_genomic_node_variability_plot","title":"<code>sequence_genomic_node_variability_plot(graph, cdr3)</code>","text":"<p>Generate a Matplotlib plot that shows the number of unique genes/alleles at each node of a given sequence based on a given graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>LZGraph</code> <p>An LZGraph object that was embedded with gene annotations.</p> required <p>Returns:     None: Shows figure via plt.show()</p> Source code in <code>src\\LZGraphs\\Visualization\\Visualize.py</code> <pre><code>def sequence_genomic_node_variability_plot(graph, cdr3):\n    \"\"\" Generate a Matplotlib plot that shows the number of unique genes/alleles at each node of a given sequence based on a given graph.\n\n                 Args:\n                     graph (LZGraph): An LZGraph object that was embedded with gene annotations.\n                     cdr3 (str) A sequence of nucleotides/amino-acids depending on the LZGraph passed.\n                 Returns:\n                     None: Shows figure via plt.show()\n           \"\"\"\n    j_df = graph.gene_variation(cdr3)\n    sns.barplot(data=j_df, x='sp', y='genes', hue='type')\n    plt.grid(lw=2, ls=':', axis='y')\n    plt.xlabel('LZ Sub Patterns')\n    plt.ylabel('Unique Gene/Allele Possibilities')\n    plt.legend()\n    plt.show()\n</code></pre>"},{"location":"visualize_reference/#src.LZGraphs.Visualization.Visualize.sequence_possible_paths_plot","title":"<code>sequence_possible_paths_plot(graph, sequence)</code>","text":"<p>Generate a Matplotlib plot that shows the number of alternative paths a sequence can take at each node based on an LZGraph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>LZGraph</code> <p>An LZGraph object that was embedded with gene annotations.</p> required <p>Returns:     None: Shows figure via plt.show()</p> Source code in <code>src\\LZGraphs\\Visualization\\Visualize.py</code> <pre><code>def sequence_possible_paths_plot(graph,sequence):\n    \"\"\" Generate a Matplotlib plot that shows the number of alternative paths a sequence can take at each node based on an LZGraph.\n\n                 Args:\n                     graph (LZGraph): An LZGraph object that was embedded with gene annotations.\n                     sequence (str) A sequence of nucleotides/amino-acids depending on the LZGraph passed.\n                 Returns:\n                     None: Shows figure via plt.show()\n           \"\"\"\n    curvec = [(graph.graph.out_degree(i)) for i in graph.encode_sequence(sequence)]\n    sns.lineplot(x=np.arange(len(curvec)), y=(curvec), color='tab:blue')\n    sns.scatterplot(x=np.arange(len(curvec)), y=(curvec), color='tab:blue')\n    plt.xticks(np.arange(len(curvec)),\n               labels=[i for i in lempel_ziv_decomposition(sequence)],\n               rotation=0)\n    plt.grid(lw=2,ls=':')\n    plt.ylabel('# of Paths')\n    plt.xlabel('LZ Sub Pattern')\n    plt.show()\n</code></pre>"}]}