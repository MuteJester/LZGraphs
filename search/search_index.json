{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LZGraphs","text":"<p>LZGraphs is a Python library for analyzing T-cell receptor (TCR) repertoires using Lempel-Ziv 76 compression-based graph representations. It provides a novel approach to sequence analysis that doesn't rely on alignment or genotype references.</p>"},{"location":"#why-lzgraphs","title":"Why LZGraphs?","text":"<p>Traditional TCR repertoire analysis methods often struggle with:</p> <ul> <li>Alignment dependencies - requiring reference sequences</li> <li>Computational complexity - O(n\u00b2) pairwise comparisons</li> <li>Loss of positional information - treating sequences as bags of k-mers</li> </ul> <p>LZGraphs solves these problems by encoding sequences as walks through directed graphs, capturing both the content and structure of repertoires in a computationally efficient way.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#graph-representations","title":"Graph Representations","text":"<p>Three specialized graph types for different analysis needs: AAPLZGraph for amino acids, NDPLZGraph for nucleotides, and NaiveLZGraph for general sequences.</p>"},{"location":"#diversity-metrics","title":"Diversity Metrics","text":"<p>Novel diversity indices including K1000 and LZCentrality that capture repertoire complexity through graph topology.</p>"},{"location":"#gene-analysis","title":"Gene Analysis","text":"<p>Built-in V/J gene annotation support for genomic-aware sequence generation and gene usage analysis.</p>"},{"location":"#visualization","title":"Visualization","text":"<p>Publication-ready plots for sequence analysis, including path variability, genomic heatmaps, and saturation curves.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install LZGraphs\n</code></pre> <p>Requirements: Python 3.9 or higher</p>"},{"location":"#your-first-graph","title":"Your First Graph","text":"<pre><code>import pandas as pd\nfrom LZGraphs import AAPLZGraph\n\n# Load your TCR repertoire data\ndata = pd.DataFrame({\n    'cdr3_amino_acid': ['CASSLEPSGGTDTQYF', 'CASSDTSGGTDTQYF', 'CASSLEPQTFTDTFFF'],\n    'V': ['TRBV16-1*01', 'TRBV1-1*01', 'TRBV16-1*01'],\n    'J': ['TRBJ1-2*01', 'TRBJ1-5*01', 'TRBJ2-7*01']\n})\n\n# Build the graph\ngraph = AAPLZGraph(data, verbose=True)\n\n# Calculate sequence probability\nsequence = \"CASSLEPSGGTDTQYF\"\npgen = graph.walk_probability(AAPLZGraph.encode_sequence(sequence))\nprint(f\"P(gen) = {pgen:.2e}\")\n</code></pre>"},{"location":"#documentation-overview","title":"Documentation Overview","text":"<p> Getting Started New to LZGraphs? Start here for installation and basic usage.</p> <p> Tutorials Step-by-step guides for common analysis tasks.</p> <p> Concepts Understand the theory behind LZGraphs.</p> <p> How-To Guides Task-oriented guides for specific operations.</p> <p> Examples Interactive Jupyter notebooks with real data.</p> <p> API Reference Complete reference for all classes and functions.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use LZGraphs in your research, please cite our paper:</p> <pre><code>@article{lzgraphs2024,\n  title={LZGraphs: A Novel Approach for T-Cell Receptor Repertoire Analysis},\n  author={Konstantinovsky, Thomas and others},\n  journal={...},\n  year={2024}\n}\n</code></pre> <p>See the Citation page for more details.</p>"},{"location":"#connect-with-us","title":"Connect With Us","text":"<ul> <li> GitHub Repository</li> <li> Report Issues</li> <li> Contact</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete reference documentation for all LZGraphs classes and functions.</p>"},{"location":"api/#quick-navigation","title":"Quick Navigation","text":""},{"location":"api/#graph-classes","title":"Graph Classes","text":"<ul> <li>AAPLZGraph - Amino acid graphs</li> <li>NDPLZGraph - Nucleotide graphs</li> <li>NaiveLZGraph - Non-positional graphs</li> </ul>"},{"location":"api/#analysis","title":"Analysis","text":"<ul> <li>Metrics - Diversity and entropy</li> <li>Utilities - Helper functions</li> <li>Exceptions - Error handling</li> </ul>"},{"location":"api/#import-patterns","title":"Import Patterns","text":""},{"location":"api/#core-classes","title":"Core Classes","text":"<pre><code>from LZGraphs import AAPLZGraph, NDPLZGraph, NaiveLZGraph\n</code></pre>"},{"location":"api/#metrics-functions","title":"Metrics Functions","text":"<pre><code>from LZGraphs import (\n    K1000_Diversity,\n    K_Diversity,\n    LZCentrality,\n    node_entropy,\n    edge_entropy,\n    graph_entropy,\n    jensen_shannon_divergence\n)\n</code></pre>"},{"location":"api/#utilities","title":"Utilities","text":"<pre><code>from LZGraphs import LZBOW, NodeEdgeSaturationProbe\nfrom LZGraphs.utilities import lempel_ziv_decomposition, generate_kmer_dictionary\n</code></pre>"},{"location":"api/#visualization","title":"Visualization","text":"<pre><code>from LZGraphs.visualization import (\n    draw_graph,\n    ancestors_descendants_curves_plot,\n    sequence_possible_paths_plot,\n    sequence_genomic_node_variability_plot,\n    sequence_genomic_edges_variability_plot\n)\n</code></pre>"},{"location":"api/#class-hierarchy","title":"Class Hierarchy","text":"<pre><code>LZGraphBase (abstract)\n\u251c\u2500\u2500 AAPLZGraph - Amino acid positional\n\u251c\u2500\u2500 NDPLZGraph - Nucleotide double positional\n\u2514\u2500\u2500 NaiveLZGraph - No positional encoding\n\nLZBOW - Bag of Words encoder\nNodeEdgeSaturationProbe - Saturation analysis\n\nExceptions:\nLZGraphError (base)\n\u251c\u2500\u2500 InputValidationError\n\u2502   \u251c\u2500\u2500 EmptyDataError\n\u2502   \u251c\u2500\u2500 MissingColumnError\n\u2502   \u2514\u2500\u2500 InvalidSequenceError\n\u251c\u2500\u2500 GraphConstructionError\n\u251c\u2500\u2500 GeneDataError\n\u2502   \u251c\u2500\u2500 NoGeneDataError\n\u2502   \u2514\u2500\u2500 GeneAnnotationError\n\u251c\u2500\u2500 WalkError\n\u2502   \u251c\u2500\u2500 NoValidPathError\n\u2502   \u2514\u2500\u2500 MissingNodeError\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"api/#common-methods","title":"Common Methods","text":"<p>All graph classes share these methods:</p> Method Description <code>walk_probability(walk)</code> Calculate sequence probability <code>random_walk()</code> Generate a random sequence <code>save(filepath)</code> Save graph to disk <code>load(filepath)</code> Load graph from disk <code>encode_sequence(seq)</code> Encode sequence to walk <code>clean_node(node)</code> Extract pattern from node"},{"location":"api/#version-information","title":"Version Information","text":"<pre><code>import LZGraphs\nprint(LZGraphs.__version__)\n</code></pre>"},{"location":"api/#module-structure","title":"Module Structure","text":"<pre><code>LZGraphs/\n\u251c\u2500\u2500 __init__.py           # Main exports\n\u251c\u2500\u2500 graphs/\n\u2502   \u251c\u2500\u2500 amino_acid_positional.py\n\u2502   \u251c\u2500\u2500 nucleotide_double_positional.py\n\u2502   \u2514\u2500\u2500 naive.py\n\u251c\u2500\u2500 metrics/\n\u2502   \u251c\u2500\u2500 diversity.py\n\u2502   \u2514\u2500\u2500 entropy.py\n\u251c\u2500\u2500 utilities/\n\u2502   \u251c\u2500\u2500 utilities.py\n\u2502   \u2514\u2500\u2500 node_edge_saturation_probe.py\n\u251c\u2500\u2500 bag_of_words/\n\u2502   \u2514\u2500\u2500 bow_encoder.py\n\u251c\u2500\u2500 visualization/\n\u2502   \u2514\u2500\u2500 visualize.py\n\u2514\u2500\u2500 exceptions/\n    \u2514\u2500\u2500 __init__.py\n</code></pre>"},{"location":"api/aaplzgraph/","title":"AAPLZGraph","text":"<p>Amino Acid Positional LZGraph for analyzing amino acid CDR3 sequences.</p>"},{"location":"api/aaplzgraph/#quick-example","title":"Quick Example","text":"<pre><code>from LZGraphs import AAPLZGraph\nimport pandas as pd\n\n# Build graph\ndata = pd.read_csv(\"repertoire.csv\")\ngraph = AAPLZGraph(data, verbose=True)\n\n# Calculate probability\nsequence = \"CASSLEPSGGTDTQYF\"\nencoded = AAPLZGraph.encode_sequence(sequence)\npgen = graph.walk_probability(encoded)\n</code></pre>"},{"location":"api/aaplzgraph/#class-reference","title":"Class Reference","text":""},{"location":"api/aaplzgraph/#LZGraphs.graphs.amino_acid_positional.AAPLZGraph","title":"AAPLZGraph","text":"<pre><code>AAPLZGraph(\n    data: DataFrame,\n    verbose: bool = True,\n    calculate_trainset_pgen: bool = False,\n    validate_sequences: bool = True,\n    smoothing_alpha: float = 0.0,\n    initial_state_threshold: int = 5,\n)\n</code></pre> <p>               Bases: <code>LZGraphBase</code></p> <p>Implements the \"Amino Acid Positional\" version of the LZGraph for analyzing amino-acid sequences, especially for immunological data.</p> Each node is labeled as <p>{LZ_subpattern}_{start_position_in_sequence}</p> <p>Create an amino-acid-positional LZGraph from a DataFrame.</p> <p>The DataFrame must contain at least a column \"cdr3_amino_acid\". Optionally, columns \"V\" and \"J\" may also be provided to embed gene information. If these columns are present, self.genetic is set to True.</p> PARAMETER DESCRIPTION <code>data</code> <p>Input data for constructing the graph. Must contain a \"cdr3_amino_acid\" column; optionally \"V\" and \"J\" columns.</p> <p> TYPE: <code>DataFrame</code> </p> <code>verbose</code> <p>Whether to log progress information.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>calculate_trainset_pgen</code> <p>If True, compute PGEN for each sequence in <code>data</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>validate_sequences</code> <p>If True, validate that sequences contain only standard amino acids. Set to False to skip validation for performance.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>smoothing_alpha</code> <p>Laplace smoothing parameter for edge weights. 0.0 means no smoothing (default).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>initial_state_threshold</code> <p>Minimum observation count for initial states. States observed fewer times than this are excluded. Default is 5.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If data is not a pandas DataFrame.</p> <code>ValueError</code> <p>If required columns are missing or sequences are invalid.</p>"},{"location":"api/aaplzgraph/#LZGraphs.graphs.amino_acid_positional.AAPLZGraph.encode_sequence","title":"encode_sequence  <code>staticmethod</code>","text":"<pre><code>encode_sequence(amino_acid: str) -&gt; List[str]\n</code></pre> <p>Convert an amino acid string into LZ sub-patterns with positions. Each sub-pattern has the format: '{LZ_subpattern}_{position}'.</p>"},{"location":"api/aaplzgraph/#LZGraphs.graphs.amino_acid_positional.AAPLZGraph.clean_node","title":"clean_node  <code>staticmethod</code>","text":"<pre><code>clean_node(base: str) -&gt; str\n</code></pre> <p>Given a sub-pattern that might look like \"ABC_10\", extract only the amino acids (\"ABC\").</p>"},{"location":"api/aaplzgraph/#constructor","title":"Constructor","text":""},{"location":"api/aaplzgraph/#parameters","title":"Parameters","text":"Parameter Type Description <code>data</code> <code>pd.DataFrame</code> DataFrame with <code>cdr3_amino_acid</code> column <code>verbose</code> <code>bool</code> Print progress messages (default: <code>True</code>)"},{"location":"api/aaplzgraph/#required-columns","title":"Required Columns","text":"<ul> <li><code>cdr3_amino_acid</code> - Amino acid CDR3 sequences</li> </ul>"},{"location":"api/aaplzgraph/#optional-columns","title":"Optional Columns","text":"<ul> <li><code>V</code> - V gene/allele annotations</li> <li><code>J</code> - J gene/allele annotations</li> </ul>"},{"location":"api/aaplzgraph/#key-methods","title":"Key Methods","text":""},{"location":"api/aaplzgraph/#walk_probability","title":"walk_probability","text":"<p>Calculate the generation probability of a sequence.</p> <pre><code>encoded = AAPLZGraph.encode_sequence(\"CASSLEPSGGTDTQYF\")\npgen = graph.walk_probability(encoded)\nprint(f\"P(gen) = {pgen:.2e}\")\n\n# Use log probability for numerical stability\nlog_pgen = graph.walk_probability(encoded, use_log=True)\nprint(f\"log P(gen) = {log_pgen:.2f}\")\n</code></pre>"},{"location":"api/aaplzgraph/#random_walk","title":"random_walk","text":"<p>Generate a random sequence following edge probabilities.</p> <pre><code>walk = graph.random_walk()\nsequence = ''.join([AAPLZGraph.clean_node(n) for n in walk])\nprint(sequence)\n</code></pre>"},{"location":"api/aaplzgraph/#genomic_random_walk","title":"genomic_random_walk","text":"<p>Generate a sequence consistent with V/J gene usage.</p> <pre><code>walk, v_gene, j_gene = graph.genomic_random_walk()\nsequence = ''.join([AAPLZGraph.clean_node(n) for n in walk])\nprint(f\"{sequence} ({v_gene}, {j_gene})\")\n</code></pre>"},{"location":"api/aaplzgraph/#encode_sequence-static","title":"encode_sequence (static)","text":"<p>Convert a sequence to graph walk format.</p> <pre><code>encoded = AAPLZGraph.encode_sequence(\"CASSLE\")\n# Returns: ['C_1', 'A_2', 'S_3', 'SL_5', 'E_6']\n</code></pre>"},{"location":"api/aaplzgraph/#clean_node-static","title":"clean_node (static)","text":"<p>Extract the pattern from a node name.</p> <pre><code>pattern = AAPLZGraph.clean_node(\"SL_5\")\n# Returns: \"SL\"\n</code></pre>"},{"location":"api/aaplzgraph/#attributes","title":"Attributes","text":"Attribute Type Description <code>graph</code> <code>nx.DiGraph</code> NetworkX directed graph <code>nodes</code> <code>NodeView</code> All nodes in the graph <code>edges</code> <code>EdgeView</code> All edges in the graph <code>lengths</code> <code>dict</code> Sequence length distribution <code>initial_states</code> <code>pd.Series</code> Initial state counts <code>terminal_states</code> <code>pd.Series</code> Terminal state counts <code>marginal_vgenes</code> <code>pd.Series</code> V gene probabilities <code>marginal_jgenes</code> <code>pd.Series</code> J gene probabilities <code>subpattern_individual_probability</code> <code>pd.DataFrame</code> Pattern probabilities"},{"location":"api/aaplzgraph/#examples","title":"Examples","text":""},{"location":"api/aaplzgraph/#building-with-gene-annotation","title":"Building with Gene Annotation","text":"<pre><code>data = pd.DataFrame({\n    'cdr3_amino_acid': ['CASSLEPSGGTDTQYF', 'CASSDTSGGTDTQYF'],\n    'V': ['TRBV16-1*01', 'TRBV1-1*01'],\n    'J': ['TRBJ1-2*01', 'TRBJ1-5*01']\n})\n\ngraph = AAPLZGraph(data, verbose=True)\nprint(graph.marginal_vgenes)\n</code></pre>"},{"location":"api/aaplzgraph/#batch-probability-calculation","title":"Batch Probability Calculation","text":"<pre><code>sequences = ['CASSLEPSGGTDTQYF', 'CASSLGQGSTEAFF', 'CASSXYZRARESEQ']\n\nfor seq in sequences:\n    try:\n        encoded = AAPLZGraph.encode_sequence(seq)\n        log_p = graph.walk_probability(encoded, use_log=True)\n        print(f\"{seq}: {log_p:.2f}\")\n    except:\n        print(f\"{seq}: Not in graph\")\n</code></pre>"},{"location":"api/aaplzgraph/#see-also","title":"See Also","text":"<ul> <li>NDPLZGraph - Nucleotide version</li> <li>NaiveLZGraph - Non-positional version</li> <li>Tutorials: Graph Construction</li> </ul>"},{"location":"api/exceptions/","title":"Exceptions","text":"<p>Custom exception classes for clear error handling in LZGraphs.</p>"},{"location":"api/exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>LZGraphError (base)\n\u251c\u2500\u2500 InputValidationError\n\u2502   \u251c\u2500\u2500 EmptyDataError\n\u2502   \u251c\u2500\u2500 MissingColumnError\n\u2502   \u2514\u2500\u2500 InvalidSequenceError\n\u251c\u2500\u2500 GraphConstructionError\n\u2502   \u2514\u2500\u2500 EncodingError\n\u251c\u2500\u2500 GeneDataError\n\u2502   \u251c\u2500\u2500 NoGeneDataError\n\u2502   \u2514\u2500\u2500 GeneAnnotationError\n\u251c\u2500\u2500 WalkError\n\u2502   \u251c\u2500\u2500 NoValidPathError\n\u2502   \u251c\u2500\u2500 MissingNodeError\n\u2502   \u2514\u2500\u2500 MissingEdgeError\n\u251c\u2500\u2500 SerializationError\n\u2502   \u251c\u2500\u2500 UnsupportedFormatError\n\u2502   \u2514\u2500\u2500 CorruptedFileError\n\u251c\u2500\u2500 BOWError\n\u2502   \u251c\u2500\u2500 EncodingFunctionMismatchError\n\u2502   \u2514\u2500\u2500 UnfittedBOWError\n\u251c\u2500\u2500 GraphOperationError\n\u2502   \u2514\u2500\u2500 IncompatibleGraphsError\n\u2514\u2500\u2500 MetricsError\n    \u2514\u2500\u2500 InsufficientDataError\n</code></pre>"},{"location":"api/exceptions/#import","title":"Import","text":"<pre><code>from LZGraphs.exceptions import (\n    LZGraphError,\n    MissingColumnError,\n    NoGeneDataError,\n    MissingNodeError,\n    # ... other exceptions\n)\n</code></pre>"},{"location":"api/exceptions/#common-exceptions","title":"Common Exceptions","text":""},{"location":"api/exceptions/#missingcolumnerror","title":"MissingColumnError","text":"<p>Raised when a required column is missing.</p> <pre><code>from LZGraphs.exceptions import MissingColumnError\n\ntry:\n    graph = AAPLZGraph(data)  # data missing 'cdr3_amino_acid'\nexcept MissingColumnError as e:\n    print(f\"Missing column: {e.column_name}\")\n    print(f\"Available: {e.available_columns}\")\n</code></pre>"},{"location":"api/exceptions/#nogenedataerror","title":"NoGeneDataError","text":"<p>Raised when gene operations are used without gene data.</p> <pre><code>from LZGraphs.exceptions import NoGeneDataError\n\ntry:\n    walk, v, j = graph.genomic_random_walk()\nexcept NoGeneDataError as e:\n    print(f\"Gene data required: {e}\")\n    # Fall back to regular random walk\n    walk = graph.random_walk()\n</code></pre>"},{"location":"api/exceptions/#missingnodeerror","title":"MissingNodeError","text":"<p>Raised when a required node doesn't exist.</p> <pre><code>from LZGraphs.exceptions import MissingNodeError\n\ntry:\n    pgen = graph.walk_probability(encoded_sequence)\nexcept MissingNodeError as e:\n    print(f\"Node not found: {e.node}\")\n    pgen = 0\n</code></pre>"},{"location":"api/exceptions/#emptydataerror","title":"EmptyDataError","text":"<p>Raised when input data is empty.</p> <pre><code>from LZGraphs.exceptions import EmptyDataError\n\ntry:\n    graph = AAPLZGraph(pd.DataFrame())\nexcept EmptyDataError:\n    print(\"Cannot build graph from empty data\")\n</code></pre>"},{"location":"api/exceptions/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"api/exceptions/#catch-all-lzgraphs-errors","title":"Catch All LZGraphs Errors","text":"<pre><code>from LZGraphs.exceptions import LZGraphError\n\ntry:\n    # Any LZGraphs operation\n    graph = AAPLZGraph(data)\n    pgen = graph.walk_probability(encoded)\nexcept LZGraphError as e:\n    print(f\"LZGraphs error: {e}\")\n</code></pre>"},{"location":"api/exceptions/#specific-error-handling","title":"Specific Error Handling","text":"<pre><code>from LZGraphs.exceptions import (\n    MissingColumnError,\n    NoGeneDataError,\n    MissingNodeError\n)\n\ntry:\n    graph = AAPLZGraph(data)\n    walk, v, j = graph.genomic_random_walk()\nexcept MissingColumnError as e:\n    print(f\"Data format error: {e}\")\nexcept NoGeneDataError:\n    print(\"Using non-genomic random walk\")\n    walk = graph.random_walk()\nexcept MissingNodeError as e:\n    print(f\"Unknown pattern: {e.node}\")\n</code></pre>"},{"location":"api/exceptions/#batch-processing-with-error-handling","title":"Batch Processing with Error Handling","text":"<pre><code>results = []\nfor seq in sequences:\n    try:\n        encoded = AAPLZGraph.encode_sequence(seq)\n        pgen = graph.walk_probability(encoded)\n        results.append({'sequence': seq, 'pgen': pgen, 'error': None})\n    except MissingNodeError as e:\n        results.append({'sequence': seq, 'pgen': 0, 'error': str(e)})\n    except Exception as e:\n        results.append({'sequence': seq, 'pgen': None, 'error': str(e)})\n\ndf = pd.DataFrame(results)\nprint(f\"Successful: {df['error'].isna().sum()}\")\nprint(f\"Failed: {df['error'].notna().sum()}\")\n</code></pre>"},{"location":"api/exceptions/#full-reference","title":"Full Reference","text":"<p>Custom exceptions for the LZGraphs library.</p> <p>This module provides a hierarchy of exception classes that give users clear, actionable error messages when something goes wrong. Using specific exception types allows for targeted error handling in downstream code.</p> Exception Hierarchy <p>LZGraphError (base) \u251c\u2500\u2500 InputValidationError \u2502   \u251c\u2500\u2500 EmptyDataError \u2502   \u251c\u2500\u2500 MissingColumnError \u2502   \u2514\u2500\u2500 InvalidSequenceError \u251c\u2500\u2500 GraphConstructionError \u2502   \u2514\u2500\u2500 EncodingError \u251c\u2500\u2500 GeneDataError \u2502   \u251c\u2500\u2500 NoGeneDataError \u2502   \u2514\u2500\u2500 GeneAnnotationError \u251c\u2500\u2500 WalkError \u2502   \u251c\u2500\u2500 NoValidPathError \u2502   \u2514\u2500\u2500 MissingNodeError \u251c\u2500\u2500 SerializationError \u2502   \u2514\u2500\u2500 UnsupportedFormatError \u251c\u2500\u2500 BOWError \u2502   \u2514\u2500\u2500 EncodingFunctionMismatchError \u2514\u2500\u2500 GraphOperationError     \u2514\u2500\u2500 IncompatibleGraphsError</p> Example <p>from LZGraphs.exceptions import NoGeneDataError, InvalidSequenceError try: ...     graph.genomic_random_walk() ... except NoGeneDataError as e: ...     print(f\"Gene data required: {e}\")</p>"},{"location":"api/exceptions/#LZGraphs.exceptions.LZGraphError","title":"LZGraphError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all LZGraphs errors.</p> <p>All custom exceptions in this library inherit from this class, allowing users to catch all LZGraphs-related errors with a single except clause if desired.</p> Example <p>try: ...     # Any LZGraphs operation ...     graph = AAPLZGraph(data) ... except LZGraphError as e: ...     print(f\"LZGraphs error: {e}\")</p>"},{"location":"api/exceptions/#LZGraphs.exceptions.InputValidationError","title":"InputValidationError","text":"<p>               Bases: <code>LZGraphError</code></p> <p>Raised when input data fails validation checks.</p> <p>This is the base class for all input-related errors. Use more specific subclasses when the error type is known.</p>"},{"location":"api/exceptions/#LZGraphs.exceptions.EmptyDataError","title":"EmptyDataError","text":"<p>               Bases: <code>InputValidationError</code></p> <p>Raised when an operation receives empty data where non-empty is required.</p> <p>Common causes: - Passing an empty DataFrame to graph constructor - Passing an empty list of sequences to transform - Empty sequence list for diversity metrics</p> Example <p>graph = AAPLZGraph(pd.DataFrame())  # Raises EmptyDataError</p>"},{"location":"api/exceptions/#LZGraphs.exceptions.MissingColumnError","title":"MissingColumnError","text":"<pre><code>MissingColumnError(\n    column_name: str,\n    available_columns: list = None,\n    message: str = None,\n)\n</code></pre> <p>               Bases: <code>InputValidationError</code></p> <p>Raised when a required column is missing from input DataFrame.</p> <p>The error message includes: - The name of the missing column - The columns that were found in the DataFrame</p> Example <p>df = pd.DataFrame({'wrong_col': ['CASS']}) graph = AAPLZGraph(df)  # Raises MissingColumnError</p>"},{"location":"api/exceptions/#LZGraphs.exceptions.InvalidSequenceError","title":"InvalidSequenceError","text":"<pre><code>InvalidSequenceError(\n    sequence: str = None,\n    invalid_chars: str = None,\n    message: str = None,\n)\n</code></pre> <p>               Bases: <code>InputValidationError</code></p> <p>Raised when a sequence contains invalid characters or format.</p> <p>The error message includes: - The problematic sequence (or portion of it) - The invalid characters found - Expected format information</p> Example <p>graph.walk_probability(\"INVALID123SEQUENCE\")  # Raises InvalidSequenceError</p>"},{"location":"api/exceptions/#LZGraphs.exceptions.NoGeneDataError","title":"NoGeneDataError","text":"<pre><code>NoGeneDataError(operation: str = None, message: str = None)\n</code></pre> <p>               Bases: <code>GeneDataError</code></p> <p>Raised when a gene-related operation is attempted on a non-genetic graph.</p> <p>This occurs when: - Calling genomic_random_walk() on a graph with genetic=False - Accessing gene prediction features without gene data - Attempting gene-based filtering without annotations</p> Solution <p>Build the graph with V and J gene columns in the input DataFrame.</p> Example <p>graph = AAPLZGraph(df_without_genes) graph.genomic_random_walk()  # Raises NoGeneDataError</p>"},{"location":"api/exceptions/#LZGraphs.exceptions.MissingNodeError","title":"MissingNodeError","text":"<pre><code>MissingNodeError(node: str = None, message: str = None)\n</code></pre> <p>               Bases: <code>WalkError</code></p> <p>Raised when a required node does not exist in the graph.</p> <p>This typically occurs when: - Computing walk probability for an unseen sequence - A subpattern in the sequence was never observed during training - Referencing a node that was removed</p> Example <p>graph.walk_probability(\"CASSXYZABC\")  # Raises MissingNodeError if XYZ never seen</p>"},{"location":"api/exceptions/#LZGraphs.exceptions.MissingEdgeError","title":"MissingEdgeError","text":"<pre><code>MissingEdgeError(\n    source: str = None,\n    target: str = None,\n    message: str = None,\n)\n</code></pre> <p>               Bases: <code>WalkError</code></p> <p>Raised when a required edge does not exist in the graph.</p> <p>This occurs when: - A transition between two nodes was never observed - Computing probability for an impossible transition</p> Example"},{"location":"api/exceptions/#LZGraphs.exceptions.MissingEdgeError--if-ca_0-xy_1-was-never-seen-during-training","title":"If 'CA_0' -&gt; 'XY_1' was never seen during training","text":"<p>graph.walk_probability(\"CAXY...\")  # May raise MissingEdgeError</p>"},{"location":"api/exceptions/#see-also","title":"See Also","text":"<ul> <li>Getting Started: Troubleshooting</li> <li>Resources: FAQ</li> </ul>"},{"location":"api/metrics/","title":"Metrics","text":"<p>Functions for measuring repertoire diversity, entropy, and similarity.</p>"},{"location":"api/metrics/#import","title":"Import","text":"<pre><code>from LZGraphs import (\n    K1000_Diversity,\n    K_Diversity,\n    K100_Diversity,\n    K500_Diversity,\n    K5000_Diversity,\n    adaptive_K_Diversity,\n    LZCentrality,\n    node_entropy,\n    edge_entropy,\n    graph_entropy,\n    normalized_graph_entropy,\n    sequence_perplexity,\n    repertoire_perplexity,\n    jensen_shannon_divergence,\n    cross_entropy,\n    kl_divergence,\n    mutual_information_genes,\n    transition_predictability,\n    graph_compression_ratio,\n    repertoire_compressibility_index,\n    transition_kl_divergence,\n    transition_jsd,\n    transition_mutual_information_profile,\n    path_entropy_rate,\n    compare_repertoires,\n)\n</code></pre>"},{"location":"api/metrics/#k-diversity-functions","title":"K-Diversity Functions","text":""},{"location":"api/metrics/#k1000_diversity","title":"K1000_Diversity","text":"<p>Calculate K1000 diversity index.</p> <pre><code>from LZGraphs import K1000_Diversity, AAPLZGraph\n\nsequences = data['cdr3_amino_acid'].tolist()\nk1000 = K1000_Diversity(\n    sequences,\n    encoding_function=AAPLZGraph.encode_sequence,\n    draws=30\n)\nprint(f\"K1000: {k1000:.1f}\")\n</code></pre> <p>Function Signature</p> <p><code>K1000_Diversity(sequences, encoding_function, draws=30) -&gt; float</code></p> <p>Returns the mean K1000 diversity index across multiple resampling draws.</p>"},{"location":"api/metrics/#k_diversity","title":"K_Diversity","text":"<p>General K-diversity with configurable parameters.</p> <pre><code>from LZGraphs import K_Diversity\n\nresult = K_Diversity(\n    sequences,\n    encoding_function=AAPLZGraph.encode_sequence,\n    sample_size=1000,\n    draws=100,\n    return_stats=True\n)\nprint(f\"Mean: {result['mean']:.1f}, CI: [{result['ci_low']:.1f}, {result['ci_high']:.1f}]\")\n</code></pre> <p>Function Signature</p> <p><code>K_Diversity(sequences, encoding_function, sample_size=1000, draws=30, return_stats=False)</code></p> <p>General K-diversity calculation with configurable sample size. When <code>return_stats=True</code>, returns a dictionary with mean, std, ci_low, and ci_high.</p>"},{"location":"api/metrics/#other-k-diversity-variants","title":"Other K-Diversity Variants","text":"Function Sample Size Use Case <code>K100_Diversity</code> 100 Small repertoires <code>K500_Diversity</code> 500 Medium repertoires <code>K1000_Diversity</code> 1000 Standard analysis <code>K5000_Diversity</code> 5000 Large repertoires <code>adaptive_K_Diversity</code> Auto Automatic selection"},{"location":"api/metrics/#lzcentrality","title":"LZCentrality","text":"<p>Measure sequence centrality within a repertoire.</p> <pre><code>from LZGraphs import LZCentrality\n\ncentrality = LZCentrality(graph, \"CASSLEPSGGTDTQYF\")\nprint(f\"Centrality: {centrality:.4f}\")\n</code></pre> <p>Function Signature</p> <p><code>LZCentrality(graph, sequence) -&gt; float</code></p> <p>Calculates the LZCentrality of a sequence within the given graph's structure.</p>"},{"location":"api/metrics/#entropy-functions","title":"Entropy Functions","text":""},{"location":"api/metrics/#node_entropy","title":"node_entropy","text":"<p>Entropy of node (pattern) distribution.</p> <pre><code>from LZGraphs import node_entropy\n\nh = node_entropy(graph)\nprint(f\"Node entropy: {h:.2f} bits\")\n</code></pre>"},{"location":"api/metrics/#edge_entropy","title":"edge_entropy","text":"<p>Entropy of edge (transition) distribution.</p> <pre><code>from LZGraphs import edge_entropy\n\nh = edge_entropy(graph)\nprint(f\"Edge entropy: {h:.2f} bits\")\n</code></pre>"},{"location":"api/metrics/#graph_entropy","title":"graph_entropy","text":"<p>Combined graph entropy measure.</p> <pre><code>from LZGraphs import graph_entropy, normalized_graph_entropy\n\nh = graph_entropy(graph)\nh_norm = normalized_graph_entropy(graph)\nprint(f\"Graph entropy: {h:.2f} bits (normalized: {h_norm:.4f})\")\n</code></pre>"},{"location":"api/metrics/#perplexity-functions","title":"Perplexity Functions","text":""},{"location":"api/metrics/#sequence_perplexity","title":"sequence_perplexity","text":"<p>Perplexity of a single sequence.</p> <pre><code>from LZGraphs import sequence_perplexity\n\nperp = sequence_perplexity(graph, \"CASSLEPSGGTDTQYF\")\nprint(f\"Perplexity: {perp:.2f}\")\n</code></pre>"},{"location":"api/metrics/#repertoire_perplexity","title":"repertoire_perplexity","text":"<p>Average perplexity across sequences.</p> <pre><code>from LZGraphs import repertoire_perplexity\n\navg_perp = repertoire_perplexity(graph, sequences)\nprint(f\"Average perplexity: {avg_perp:.2f}\")\n</code></pre>"},{"location":"api/metrics/#divergence-functions","title":"Divergence Functions","text":""},{"location":"api/metrics/#jensen_shannon_divergence","title":"jensen_shannon_divergence","text":"<p>Symmetric divergence between two repertoires.</p> <pre><code>from LZGraphs import jensen_shannon_divergence\n\njsd = jensen_shannon_divergence(graph1, graph2)\nprint(f\"JS Divergence: {jsd:.4f}\")  # 0 to 1\n</code></pre> <p>Function Signature</p> <p><code>jensen_shannon_divergence(lzgraph1, lzgraph2) -&gt; float</code></p> <p>Calculates the Jensen-Shannon divergence between two LZGraph objects based on their edge weight distributions.</p>"},{"location":"api/metrics/#cross_entropy","title":"cross_entropy","text":"<p>Cross-entropy between repertoires.</p> <pre><code>from LZGraphs import cross_entropy\n\nce = cross_entropy(graph1, graph2)\nprint(f\"Cross entropy: {ce:.2f}\")\n</code></pre>"},{"location":"api/metrics/#kl_divergence","title":"kl_divergence","text":"<p>Kullback-Leibler divergence (asymmetric).</p> <pre><code>from LZGraphs import kl_divergence\n\nkl = kl_divergence(graph1, graph2)\nprint(f\"KL Divergence: {kl:.4f}\")\n</code></pre>"},{"location":"api/metrics/#gene-information","title":"Gene Information","text":""},{"location":"api/metrics/#mutual_information_genes","title":"mutual_information_genes","text":"<p>Mutual information between genes and patterns.</p> <pre><code>from LZGraphs import mutual_information_genes\n\nmi_v = mutual_information_genes(graph, gene_type='V')\nmi_j = mutual_information_genes(graph, gene_type='J')\nprint(f\"MI (V): {mi_v:.4f}, MI (J): {mi_j:.4f}\")\n</code></pre>"},{"location":"api/metrics/#information-theoretic-metrics","title":"Information-Theoretic Metrics","text":""},{"location":"api/metrics/#transition_predictability","title":"transition_predictability","text":"<p>Measures how deterministic the graph transitions are relative to the maximum possible branching.</p> <pre><code>from LZGraphs import transition_predictability\n\ntp = transition_predictability(graph)\nprint(f\"Transition predictability: {tp:.3f}\")  # 0 to 1\n</code></pre> <p>Function Signature</p> <p><code>transition_predictability(lzgraph, base=2) -&gt; float</code></p> <p>Returns a value in [0, 1]. Higher values indicate more deterministic transitions (restricted repertoire). Empirically stable at ~0.60 for AAPLZGraph across sample sizes.</p>"},{"location":"api/metrics/#graph_compression_ratio","title":"graph_compression_ratio","text":"<p>Measures how much the graph compresses repeated transitions into shared edges.</p> <pre><code>from LZGraphs import graph_compression_ratio\n\ngcr = graph_compression_ratio(graph)\nprint(f\"Compression ratio: {gcr:.3f}\")  # 0 to 1\n</code></pre> <p>Function Signature</p> <p><code>graph_compression_ratio(lzgraph) -&gt; float</code></p> <p>Returns <code>n_edges / n_transitions</code>. Lower values indicate more path sharing. AAPLZGraph ~0.18, NaiveLZGraph ~0.05.</p>"},{"location":"api/metrics/#repertoire_compressibility_index","title":"repertoire_compressibility_index","text":"<p>Alias for <code>transition_predictability</code>, framed from a data compression perspective.</p> <pre><code>from LZGraphs import repertoire_compressibility_index\n\nrci = repertoire_compressibility_index(graph)\nprint(f\"Compressibility: {rci:.3f}\")  # 0 to 1\n</code></pre> <p>Function Signature</p> <p><code>repertoire_compressibility_index(lzgraph, base=2) -&gt; float</code></p> <p>RCI = 1 means fully deterministic (compressible), RCI = 0 means maximally uncertain (incompressible).</p>"},{"location":"api/metrics/#path_entropy_rate","title":"path_entropy_rate","text":"<p>Estimates the average information content per subpattern step across actual sequences.</p> <pre><code>from LZGraphs import path_entropy_rate\n\nsequences = data['cdr3_amino_acid'].tolist()\nh = path_entropy_rate(graph, sequences)\nprint(f\"Entropy rate: {h:.3f} bits/step\")\n</code></pre> <p>Function Signature</p> <p><code>path_entropy_rate(lzgraph, sequences, base=2) -&gt; float</code></p> <p>Uses <code>walk_log_probability()</code> internally. AAPLZGraph ~2.5 bits/step, NaiveLZGraph ~3.5 bits/step.</p>"},{"location":"api/metrics/#transition-level-divergence","title":"Transition-Level Divergence","text":""},{"location":"api/metrics/#transition_kl_divergence","title":"transition_kl_divergence","text":"<p>Transition-level KL divergence \u2014 compares the transition structure, not just node distributions.</p> <pre><code>from LZGraphs import transition_kl_divergence\n\nkl = transition_kl_divergence(graph1, graph2)\nprint(f\"Transition KL: {kl:.4f}\")\n</code></pre> <p>Function Signature</p> <p><code>transition_kl_divergence(lzgraph_p, lzgraph_q) -&gt; float</code></p> <p>Asymmetric, can be infinite. Use <code>transition_jsd</code> for a bounded alternative.</p>"},{"location":"api/metrics/#transition_jsd","title":"transition_jsd","text":"<p>Transition-level Jensen-Shannon divergence \u2014 always finite, symmetric.</p> <pre><code>from LZGraphs import transition_jsd\n\njsd_t = transition_jsd(graph1, graph2)\nprint(f\"Transition JSD: {jsd_t:.4f}\")  # 0 to 1\n</code></pre> <p>Function Signature</p> <p><code>transition_jsd(lzgraph1, lzgraph2) -&gt; float</code></p> <p>Symmetric and bounded [0, 1]. Recommended for comparing repertoire transition structures.</p>"},{"location":"api/metrics/#transition_mutual_information_profile","title":"transition_mutual_information_profile","text":"<p>Position-specific mutual information along the CDR3 sequence.</p> <pre><code>from LZGraphs import transition_mutual_information_profile\n\ntmip = transition_mutual_information_profile(graph)\nfor pos in sorted(tmip):\n    print(f\"Position {pos}: MI = {tmip[pos]:.3f} bits\")\n</code></pre> <p>Function Signature</p> <p><code>transition_mutual_information_profile(lzgraph) -&gt; dict</code></p> <p>Returns <code>{position: mutual_information}</code>. Only works with positional graphs (AAPLZGraph, NDPLZGraph). Raises <code>MetricsError</code> for NaiveLZGraph.</p>"},{"location":"api/metrics/#convenience","title":"Convenience","text":""},{"location":"api/metrics/#compare_repertoires","title":"compare_repertoires","text":"<p>All-in-one repertoire comparison returning a pandas Series of metrics.</p> <pre><code>from LZGraphs import compare_repertoires\n\nresult = compare_repertoires(graph1, graph2)\nprint(result)\n</code></pre> <p>Function Signature</p> <p><code>compare_repertoires(graph1, graph2) -&gt; pd.Series</code></p> <p>Returns: <code>js_divergence</code>, <code>transition_jsd</code>, <code>cross_entropy_1_2</code>, <code>cross_entropy_2_1</code>, <code>kl_divergence_1_2</code>, <code>kl_divergence_2_1</code>, <code>node_entropy_1</code>, <code>node_entropy_2</code>, <code>edge_entropy_1</code>, <code>edge_entropy_2</code>, <code>transition_predictability_1</code>, <code>transition_predictability_2</code>, <code>shared_nodes</code>, <code>shared_edges</code>, <code>jaccard_nodes</code>, <code>jaccard_edges</code>.</p>"},{"location":"api/metrics/#see-also","title":"See Also","text":"<ul> <li>Tutorials: Diversity Metrics</li> <li>How-To: Compare Repertoires</li> <li>Concepts: Probability Model</li> <li>Example: Information-Theoretic Analysis</li> </ul>"},{"location":"api/naivelzgraph/","title":"NaiveLZGraph","text":"<p>Non-positional LZGraph for consistent feature extraction and cross-repertoire analysis.</p>"},{"location":"api/naivelzgraph/#quick-example","title":"Quick Example","text":"<pre><code>from LZGraphs import NaiveLZGraph\nfrom LZGraphs.utilities import generate_kmer_dictionary\n\n# Create shared dictionary\ndictionary = generate_kmer_dictionary(6)\n\n# Build graph\nsequences = ['TGTGCCAGCAGT', 'TGTGCCAGCAGC']\ngraph = NaiveLZGraph(sequences, dictionary, verbose=True)\n\n# Extract features\nfeatures = graph.eigenvector_centrality()\n</code></pre>"},{"location":"api/naivelzgraph/#class-reference","title":"Class Reference","text":""},{"location":"api/naivelzgraph/#LZGraphs.graphs.naive.NaiveLZGraph","title":"NaiveLZGraph","text":"<pre><code>NaiveLZGraph(\n    cdr3_list, dictionary, verbose=True, smoothing_alpha=0.0\n)\n</code></pre> <p>               Bases: <code>LZGraphBase</code></p> <p>This class implements the logic and infrastructure of the \"Naive\" version of the LZGraph The nodes of this graph are LZ sub-patterns alone without any other additions, This class best fits when the objective is extracting features from a repertoire.</p> <p>...</p>"},{"location":"api/naivelzgraph/#LZGraphs.graphs.naive.NaiveLZGraph--methods","title":"Methods","text":"<p>walk_probability(walk,verbose=True):     returns the PGEN of the given walk (list of sub-patterns)</p> <p>random_walk(steps):    given a number of steps (sub-patterns) returns a random walk on the graph between a random inital state    to a random terminal state in the given number of steps</p> <p>random_walk_ber_shortest(steps, sfunc_h=0.6, sfunc_k=12):     given a number of steps (sub-patterns) returns a random walk on the graph between a random inital state    to a random terminal state, the closer the walk is to the number of selected steps, the higher the    probability that the next state will be selected using the shortest-path via dijkstra algorithm.    the saturation function which controls the probability of the selecting a node base on the shortest path    from the current state is given by the hill function that has 2 parameters, \"h\" and \"h\",    and can be changed by passing value for the \"sfunc_h\" parameter and the \"sfunc_k\"  parameter.</p> <p>unsupervised_random_walk():   a random initial state and a random terminal state are selected and a random unsupervised walk is   carried out until the randomly selected terminal state is reached.</p> <p>eigenvector_centrality():   return the eigen vector centrality value for each node (this function is used as the feature extractor   for the LZGraph)</p> <p>sequence_variation_curve(cdr3_sample):   given a cdr3 sequence, the function will calculate the value of the variation curve and return   2 arrays, 1 of the sub-patterns and 1 for the number of out neighbours for each sub-pattern</p> <p>graph_summary():   the function will return a pandas DataFrame containing the graphs   Chromatic Number,Number of Isolates,Max In Deg,Max Out Deg,Number of Edges</p>"},{"location":"api/naivelzgraph/#LZGraphs.graphs.naive.NaiveLZGraph--attributres","title":"Attributres","text":"<pre><code>  nodes:\n      returns the nodes of the graph\n  edges:\n      return the edges of the graph\n</code></pre> <p>in order to derive the dictionary you can use the heleper function \"generate_dictionary\" :param cdr3_list: a list of nucleotide sequence :param dictionary: a list of strings, where each string is a sub-pattern that will be converted into a node :param verbose: :param smoothing_alpha: Laplace smoothing parameter for edge weights. 0.0 means no smoothing.</p>"},{"location":"api/naivelzgraph/#LZGraphs.graphs.naive.NaiveLZGraph.clean_node","title":"clean_node  <code>staticmethod</code>","text":"<pre><code>clean_node(node: str) -&gt; str\n</code></pre> <p>Return the clean subpattern from a node.</p> <p>For NaiveLZGraph, nodes are already just the raw LZ subpatterns without any position information, so this returns the node unchanged.</p> PARAMETER DESCRIPTION <code>node</code> <p>A node identifier (LZ subpattern).</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The same subpattern (no transformation needed).</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/naivelzgraph/#constructor","title":"Constructor","text":""},{"location":"api/naivelzgraph/#parameters","title":"Parameters","text":"Parameter Type Description <code>sequences</code> <code>list[str]</code> List of sequences <code>dictionary</code> <code>list[str]</code> List of allowed patterns <code>verbose</code> <code>bool</code> Print progress (default: <code>True</code>)"},{"location":"api/naivelzgraph/#key-differences","title":"Key Differences","text":"<p>Unlike AAPLZGraph and NDPLZGraph:</p> <ul> <li>No positional encoding - Nodes are just patterns</li> <li>Fixed dictionary - Consistent nodes across repertoires</li> <li>No gene support - No V/J annotation</li> </ul>"},{"location":"api/naivelzgraph/#primary-use-cases","title":"Primary Use Cases","text":""},{"location":"api/naivelzgraph/#machine-learning-features","title":"Machine Learning Features","text":"<pre><code>from LZGraphs import NaiveLZGraph\nfrom LZGraphs.utilities import generate_kmer_dictionary\n\n# Shared dictionary for all repertoires\ndictionary = generate_kmer_dictionary(6)\n\n# Build graphs for multiple repertoires\ngraphs = []\nfor sequences in repertoire_list:\n    g = NaiveLZGraph(sequences, dictionary, verbose=False)\n    graphs.append(g)\n\n# Extract feature vectors (same dimensions!)\nfeatures = [g.eigenvector_centrality() for g in graphs]\n</code></pre>"},{"location":"api/naivelzgraph/#cross-repertoire-comparison","title":"Cross-Repertoire Comparison","text":"<pre><code># Same dictionary ensures comparable graphs\ng1 = NaiveLZGraph(seqs1, dictionary)\ng2 = NaiveLZGraph(seqs2, dictionary)\n\n# Features are directly comparable\nf1 = g1.eigenvector_centrality()\nf2 = g2.eigenvector_centrality()\n</code></pre>"},{"location":"api/naivelzgraph/#dictionary-generation","title":"Dictionary Generation","text":"<pre><code>from LZGraphs.utilities import generate_kmer_dictionary\n\n# All patterns up to length k\ndict_6 = generate_kmer_dictionary(6)  # 5460 patterns\ndict_5 = generate_kmer_dictionary(5)  # 1364 patterns\ndict_4 = generate_kmer_dictionary(4)  # 340 patterns\n\nprint(f\"Length 6: {len(dict_6)} patterns\")\n</code></pre>"},{"location":"api/naivelzgraph/#see-also","title":"See Also","text":"<ul> <li>AAPLZGraph - Positional amino acid version</li> <li>NDPLZGraph - Positional nucleotide version</li> <li>Concepts: Graph Types</li> </ul>"},{"location":"api/ndplzgraph/","title":"NDPLZGraph","text":"<p>Nucleotide Double Positional LZGraph for analyzing nucleotide CDR3 sequences.</p>"},{"location":"api/ndplzgraph/#quick-example","title":"Quick Example","text":"<pre><code>from LZGraphs import NDPLZGraph\nimport pandas as pd\n\n# Build graph\ndata = pd.read_csv(\"repertoire.csv\")\ngraph = NDPLZGraph(data, verbose=True)\n\n# Calculate probability\nsequence = \"TGTGCCAGCAGT\"\nencoded = NDPLZGraph.encode_sequence(sequence)\npgen = graph.walk_probability(encoded)\n</code></pre>"},{"location":"api/ndplzgraph/#class-reference","title":"Class Reference","text":""},{"location":"api/ndplzgraph/#LZGraphs.graphs.nucleotide_double_positional.NDPLZGraph","title":"NDPLZGraph","text":"<pre><code>NDPLZGraph(\n    data: DataFrame,\n    verbose: bool = True,\n    calculate_trainset_pgen: bool = False,\n    smoothing_alpha: float = 0.0,\n    initial_state_threshold: int = 5,\n)\n</code></pre> <p>               Bases: <code>LZGraphBase</code></p> <p>This class implements the \"Nucleotide Double Positional\" version of the LZGraph, suitable for analyzing nucleotide sequences. Each node has the format:    {LZ_subpattern}{reading_frame_start}_{start_position_in_sequence}, for example: \"ATG0_3\" might mean the subpattern \"ATG\", reading frame 0, starting at position 3 in the overall sequence.</p> <p>The class inherits from LZGraphBase and thus uses the same random-walk logic, gene annotation logic (if present), and so on.</p> <p>Constructor for NDPLZGraph.</p> PARAMETER DESCRIPTION <code>data</code> <p>Must include at least a column 'cdr3_rearrangement' with the nucleotide sequences. If 'V' and 'J' columns exist, we embed gene information (self.genetic=True).</p> <p> TYPE: <code>DataFrame</code> </p> <code>verbose</code> <p>Whether to log progress info.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>calculate_trainset_pgen</code> <p>If True, compute the walk_probability for each sequence in the dataset, storing results in self.train_pgen.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>smoothing_alpha</code> <p>Laplace smoothing parameter for edge weights. 0.0 means no smoothing (default).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>initial_state_threshold</code> <p>Minimum observation count for initial states. States observed fewer times than this are excluded. Default is 5.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p>"},{"location":"api/ndplzgraph/#LZGraphs.graphs.nucleotide_double_positional.NDPLZGraph.encode_sequence","title":"encode_sequence  <code>staticmethod</code>","text":"<pre><code>encode_sequence(cdr3: str) -&gt; List[str]\n</code></pre> <p>Encode a nucleotide sequence (cdr3) into the NDPLZGraph format:   {lz_subpattern}{reading_frame}_{start_position}</p> If cdr3=\"ATGCG\", the function might yield subpatterns: <ul> <li>\"ATG\" (frame=0, pos=0)</li> <li>\"CG\"  (frame=0, pos=3) resulting in nodes \"ATG0_3\", \"CG0_5\", etc.</li> </ul>"},{"location":"api/ndplzgraph/#LZGraphs.graphs.nucleotide_double_positional.NDPLZGraph.clean_node","title":"clean_node  <code>staticmethod</code>","text":"<pre><code>clean_node(base: str) -&gt; str\n</code></pre> <p>Given a sub-pattern that looks like \"ATG0_3\", extract only the nucleotides (\"ATG\").</p>"},{"location":"api/ndplzgraph/#constructor","title":"Constructor","text":""},{"location":"api/ndplzgraph/#parameters","title":"Parameters","text":"Parameter Type Description <code>data</code> <code>pd.DataFrame</code> DataFrame with <code>cdr3_rearrangement</code> column <code>verbose</code> <code>bool</code> Print progress messages (default: <code>True</code>)"},{"location":"api/ndplzgraph/#required-columns","title":"Required Columns","text":"<ul> <li><code>cdr3_rearrangement</code> - Nucleotide CDR3 sequences</li> </ul>"},{"location":"api/ndplzgraph/#optional-columns","title":"Optional Columns","text":"<ul> <li><code>V</code> - V gene/allele annotations</li> <li><code>J</code> - J gene/allele annotations</li> </ul>"},{"location":"api/ndplzgraph/#node-format","title":"Node Format","text":"<p>NDPLZGraph uses double positional encoding:</p> <pre><code>&lt;pattern&gt;_&lt;start&gt;_&lt;end&gt;\n</code></pre> <p>Example: <pre><code>encoded = NDPLZGraph.encode_sequence(\"TGTGCC\")\n# ['T_1_1', 'G_2_2', 'T_3_3', 'G_4_4', 'C_5_5', 'C_6_6']\n</code></pre></p>"},{"location":"api/ndplzgraph/#key-methods","title":"Key Methods","text":""},{"location":"api/ndplzgraph/#walk_probability","title":"walk_probability","text":"<pre><code>encoded = NDPLZGraph.encode_sequence(\"TGTGCCAGCAGT\")\npgen = graph.walk_probability(encoded, use_log=True)\nprint(f\"log P(gen) = {pgen:.2f}\")\n</code></pre>"},{"location":"api/ndplzgraph/#encode_sequence-static","title":"encode_sequence (static)","text":"<pre><code>encoded = NDPLZGraph.encode_sequence(\"TGTGCC\")\n# Returns: ['T_1_1', 'G_2_2', 'T_3_3', 'G_4_4', 'C_5_5', 'C_6_6']\n</code></pre>"},{"location":"api/ndplzgraph/#clean_node-static","title":"clean_node (static)","text":"<pre><code>pattern = NDPLZGraph.clean_node(\"TG_3_4\")\n# Returns: \"TG\"\n</code></pre>"},{"location":"api/ndplzgraph/#comparison-with-aaplzgraph","title":"Comparison with AAPLZGraph","text":"Feature NDPLZGraph AAPLZGraph Sequence type Nucleotides Amino acids Position encoding Double (start, end) Single (end) Alphabet size 4 20 Graph size Larger Smaller Resolution Higher Lower"},{"location":"api/ndplzgraph/#see-also","title":"See Also","text":"<ul> <li>AAPLZGraph - Amino acid version</li> <li>NaiveLZGraph - Non-positional version</li> <li>Concepts: Graph Types</li> </ul>"},{"location":"api/utilities/","title":"Utilities","text":"<p>Helper functions and classes for LZGraphs analysis.</p>"},{"location":"api/utilities/#core-utilities","title":"Core Utilities","text":""},{"location":"api/utilities/#lempel_ziv_decomposition","title":"lempel_ziv_decomposition","text":"<p>Decompose a sequence using LZ76 algorithm.</p> <pre><code>from LZGraphs.utilities import lempel_ziv_decomposition\n\npatterns = lempel_ziv_decomposition(\"CASSLEPSGGTDTQYF\")\nprint(patterns)\n# ['C', 'A', 'S', 'SL', 'E', 'P', 'SG', 'G', 'T', 'D', 'TQ', 'Y', 'F']\n</code></pre>"},{"location":"api/utilities/#generate_kmer_dictionary","title":"generate_kmer_dictionary","text":"<p>Generate all possible patterns up to length k.</p> <pre><code>from LZGraphs.utilities import generate_kmer_dictionary\n\n# For nucleotides\ndictionary = generate_kmer_dictionary(6)\nprint(f\"Patterns: {len(dictionary)}\")  # 5460\n\n# For amino acids (custom alphabet)\naa_alphabet = \"ACDEFGHIKLMNPQRSTVWY\"\naa_dict = generate_kmer_dictionary(4, alphabet=aa_alphabet)\n</code></pre>"},{"location":"api/utilities/#lzbow-bag-of-words","title":"LZBOW (Bag of Words)","text":"<p>Vectorize sequences using LZ76 patterns.</p> <pre><code>from LZGraphs import LZBOW, NDPLZGraph\n\n# Create vectorizer\nvectorizer = LZBOW(encoding_function=NDPLZGraph.encode_sequence)\n\n# Fit on repertoire\nvectorizer.fit(sequences)\n\n# Transform new sequences\nbow_vector = vectorizer.transform(new_sequences)\n</code></pre>"},{"location":"api/utilities/#methods","title":"Methods","text":"Method Description <code>fit(sequences)</code> Build dictionary from sequences <code>transform(sequences)</code> Convert to BOW vectors <code>fit_transform(sequences)</code> Fit and transform"},{"location":"api/utilities/#combining-bow-objects","title":"Combining BOW Objects","text":"<pre><code># Combine dictionaries from multiple repertoires\nbow1 = LZBOW(encoding_function=NDPLZGraph.encode_sequence)\nbow1.fit(sequences1)\n\nbow2 = LZBOW(encoding_function=NDPLZGraph.encode_sequence)\nbow2.fit(sequences2)\n\ncombined = bow1 + bow2\n</code></pre> <p>Class: LZBOW</p> <p>Bag-of-Words encoder using LZ76 decomposition patterns as vocabulary.</p> <p>Constructor: <code>LZBOW(encoding_function=lempel_ziv_decomposition)</code></p> <p>Key Methods:</p> <ul> <li><code>fit(sequences)</code> - Build vocabulary from sequences</li> <li><code>transform(sequences, normalize=False)</code> - Convert to BOW vectors</li> <li><code>fit_transform(sequences)</code> - Fit and transform in one step</li> <li><code>load_from(other_bow)</code> - Load vocabulary from another LZBOW</li> </ul>"},{"location":"api/utilities/#nodeedgesaturationprobe","title":"NodeEdgeSaturationProbe","text":"<p>Analyze how diversity grows with sample size.</p> <pre><code>from LZGraphs import NodeEdgeSaturationProbe, AAPLZGraph\n\nprobe = NodeEdgeSaturationProbe()\n\n# Generate saturation curve\ncurve = probe.saturation_curve(\n    sequences,\n    encoding_function=AAPLZGraph.encode_sequence,\n    steps=50\n)\n\nprint(curve.head())\n</code></pre>"},{"location":"api/utilities/#methods_1","title":"Methods","text":"Method Description <code>saturation_curve()</code> Generate node/edge counts vs sample size <code>half_saturation_point()</code> Find 50% saturation point <code>area_under_curve()</code> Calculate AUSC metric <code>diversity_profile()</code> Full diversity profile"},{"location":"api/utilities/#example","title":"Example","text":"<pre><code>from LZGraphs import NodeEdgeSaturationProbe\nimport matplotlib.pyplot as plt\n\nprobe = NodeEdgeSaturationProbe()\ncurve = probe.saturation_curve(sequences, AAPLZGraph.encode_sequence)\n\n# Plot\nplt.figure(figsize=(10, 6))\nplt.plot(curve['sequences'], curve['nodes'], label='Nodes')\nplt.plot(curve['sequences'], curve['edges'], label='Edges')\nplt.xlabel('Number of Sequences')\nplt.ylabel('Count')\nplt.legend()\nplt.savefig('saturation.png')\n</code></pre> <p>Class: NodeEdgeSaturationProbe</p> <p>Analyzes how graph complexity grows with sample size.</p> <p>Methods:</p> <ul> <li><code>saturation_curve(sequences, encoding_function, steps)</code> - Generate saturation data</li> <li><code>half_saturation_point(curve)</code> - Find 50% saturation</li> <li><code>area_under_curve(curve)</code> - Calculate AUSC metric</li> </ul>"},{"location":"api/utilities/#visualization-functions","title":"Visualization Functions","text":""},{"location":"api/utilities/#draw_graph","title":"draw_graph","text":"<p>Visualize graph structure.</p> <pre><code>from LZGraphs.visualization import draw_graph\n\ndraw_graph(graph, file_name='graph.png')\n</code></pre>"},{"location":"api/utilities/#ancestors_descendants_curves_plot","title":"ancestors_descendants_curves_plot","text":"<p>Plot ancestors and descendants along a sequence.</p> <pre><code>from LZGraphs.visualization import ancestors_descendants_curves_plot\n\nancestors_descendants_curves_plot(graph, \"CASSLEPSGGTDTQYF\")\n</code></pre>"},{"location":"api/utilities/#sequence_possible_paths_plot","title":"sequence_possible_paths_plot","text":"<p>Plot branching factor at each position.</p> <pre><code>from LZGraphs.visualization import sequence_possible_paths_plot\n\nsequence_possible_paths_plot(graph, \"CASSLEPSGGTDTQYF\")\n</code></pre>"},{"location":"api/utilities/#sequence_genomic_node_variability_plot","title":"sequence_genomic_node_variability_plot","text":"<p>Plot V/J gene diversity per node.</p> <pre><code>from LZGraphs.visualization import sequence_genomic_node_variability_plot\n\nsequence_genomic_node_variability_plot(graph, \"CASSLEPSGGTDTQYF\")\n</code></pre>"},{"location":"api/utilities/#sequence_genomic_edges_variability_plot","title":"sequence_genomic_edges_variability_plot","text":"<p>Plot V/J gene associations per edge.</p> <pre><code>from LZGraphs.visualization import sequence_genomic_edges_variability_plot\n\nsequence_genomic_edges_variability_plot(graph, \"CASSLEPSGGTDTQYF\")\n</code></pre>"},{"location":"api/utilities/#graph-operations","title":"Graph Operations","text":""},{"location":"api/utilities/#graph_summary","title":"graph_summary","text":"<p>Get summary statistics for a graph.</p> <pre><code>from LZGraphs import graph_summary\n\nsummary = graph_summary(graph)\nprint(summary)\n</code></pre>"},{"location":"api/utilities/#graph_union","title":"graph_union","text":"<p>Combine two graphs.</p> <pre><code>from LZGraphs import graph_union\n\ncombined = graph_union(graph1, graph2)\n</code></pre>"},{"location":"api/utilities/#see-also","title":"See Also","text":"<ul> <li>Tutorials: Visualization</li> <li>Concepts: LZ76 Algorithm</li> </ul>"},{"location":"concepts/","title":"Concepts","text":"<p>Understanding the theory behind LZGraphs will help you use it more effectively and interpret results correctly.</p>"},{"location":"concepts/#core-concepts","title":"Core Concepts","text":""},{"location":"concepts/#lz76-algorithm","title":"LZ76 Algorithm","text":"<p>How Lempel-Ziv compression creates sequence encodings</p>"},{"location":"concepts/#graph-types","title":"Graph Types","text":"<p>Comparison of AAPLZGraph, NDPLZGraph, and NaiveLZGraph</p>"},{"location":"concepts/#probability-model","title":"Probability Model","text":"<p>How LZGraphs calculates sequence generation probabilities</p>"},{"location":"concepts/#the-big-picture","title":"The Big Picture","text":"<p>LZGraphs represents a TCR repertoire as a directed graph where:</p> <ol> <li>Sequences become walks - Each CDR3 sequence is a path through the graph</li> <li>Patterns become nodes - Subpatterns from LZ76 decomposition are nodes</li> <li>Transitions become edges - Observed pattern transitions are edges</li> <li>Frequencies become weights - How often transitions occur determines edge weights</li> </ol> <p>This representation enables:</p> <ul> <li>Efficient probability calculation - O(n) instead of O(n\u00b2)</li> <li>Pattern discovery - Find common motifs and rare variations</li> <li>Sequence generation - Sample new sequences with realistic statistics</li> <li>Diversity quantification - Measure complexity through graph topology</li> </ul>"},{"location":"concepts/#why-graphs","title":"Why Graphs?","text":"<p>Traditional approaches to repertoire analysis face challenges:</p> Challenge Traditional Approach LZGraphs Approach Comparing sequences Pairwise alignment (O(n\u00b2)) Walk probability (O(n)) Finding patterns K-mer counting Graph structure Generating sequences Statistical models Random walks Cross-repertoire comparison Sequence overlap Graph divergence"},{"location":"concepts/#key-insights","title":"Key Insights","text":""},{"location":"concepts/#1-position-matters","title":"1. Position Matters","text":"<p>The positional encoding in AAPLZGraph and NDPLZGraph captures that:</p> <ul> <li>The same amino acid at position 3 vs position 10 has different meaning</li> <li>CDR3 structure follows positional constraints</li> <li>V/J gene contributions vary by position</li> </ul>"},{"location":"concepts/#2-context-matters","title":"2. Context Matters","text":"<p>The graph captures:</p> <ul> <li>Which patterns can follow which</li> <li>Gene-specific transition preferences</li> <li>Repertoire-specific motifs</li> </ul>"},{"location":"concepts/#3-frequency-matters","title":"3. Frequency Matters","text":"<p>Edge weights encode:</p> <ul> <li>Common vs rare transitions</li> <li>Probability of sequence generation</li> <li>Deviation from expected patterns</li> </ul>"},{"location":"concepts/#next-steps","title":"Next Steps","text":"<p>Dive deeper into specific concepts:</p> <ul> <li>LZ76 Algorithm - Understand the encoding</li> <li>Graph Types - Choose the right representation</li> <li>Probability Model - Calculate sequence likelihood</li> </ul>"},{"location":"concepts/graph-types/","title":"Graph Types","text":"<p>LZGraphs provides three graph types, each optimized for different analysis scenarios. This guide helps you choose the right one.</p>"},{"location":"concepts/graph-types/#overview-comparison","title":"Overview Comparison","text":"Feature AAPLZGraph NDPLZGraph NaiveLZGraph Input Amino acids Nucleotides Any strings Column <code>cdr3_amino_acid</code> <code>cdr3_rearrangement</code> List of strings Position encoding Single (end) Double (start, end) None V/J gene support Yes Yes No Alphabet size 20 AA 4 NT Configurable Graph density Medium Low Configurable Memory usage Medium High Configurable Best for Most TCR analysis Nucleotide-level ML features"},{"location":"concepts/graph-types/#aaplzgraph","title":"AAPLZGraph","text":"<p>Amino Acid Positional LZGraph</p>"},{"location":"concepts/graph-types/#when-to-use","title":"When to Use","text":"<ul> <li>Analyzing amino acid CDR3 sequences</li> <li>Need V/J gene annotations</li> <li>Standard repertoire analysis</li> <li>Moderate-sized repertoires</li> </ul>"},{"location":"concepts/graph-types/#node-format","title":"Node Format","text":"<pre><code>&lt;pattern&gt;_&lt;end_position&gt;\n</code></pre> <p>Example: <code>SL_5</code> means pattern \"SL\" ending at position 5.</p>"},{"location":"concepts/graph-types/#example","title":"Example","text":"<pre><code>from LZGraphs import AAPLZGraph\nimport pandas as pd\n\ndata = pd.DataFrame({\n    'cdr3_amino_acid': ['CASSLEPSGGTDTQYF', 'CASSDTSGGTDTQYF'],\n    'V': ['TRBV16-1*01', 'TRBV1-1*01'],\n    'J': ['TRBJ1-2*01', 'TRBJ1-5*01']\n})\n\ngraph = AAPLZGraph(data, verbose=True)\n</code></pre>"},{"location":"concepts/graph-types/#key-features","title":"Key Features","text":"<ul> <li>Position-aware: Same pattern at different positions = different nodes</li> <li>Gene-aware: Edges carry V/J gene annotations</li> <li>Compact: 20-letter alphabet keeps graph manageable</li> </ul>"},{"location":"concepts/graph-types/#ndplzgraph","title":"NDPLZGraph","text":"<p>Nucleotide Double Positional LZGraph</p>"},{"location":"concepts/graph-types/#when-to-use_1","title":"When to Use","text":"<ul> <li>Analyzing nucleotide sequences</li> <li>Need fine-grained positional information</li> <li>Studying codon usage or frame</li> <li>Have memory for larger graphs</li> </ul>"},{"location":"concepts/graph-types/#node-format_1","title":"Node Format","text":"<pre><code>&lt;pattern&gt;_&lt;start_position&gt;_&lt;end_position&gt;\n</code></pre> <p>Example: <code>TG_3_4</code> means pattern \"TG\" from position 3 to 4.</p>"},{"location":"concepts/graph-types/#example_1","title":"Example","text":"<pre><code>from LZGraphs import NDPLZGraph\nimport pandas as pd\n\ndata = pd.DataFrame({\n    'cdr3_rearrangement': [\n        'TGTGCCAGCAGTTTAGAGCCCAGCGGGGGG...',\n        'TGTGCCAGCAGTGACACTTCAGGGGGGACT...'\n    ],\n    'V': ['TRBV16-1*01', 'TRBV1-1*01'],\n    'J': ['TRBJ1-2*01', 'TRBJ1-5*01']\n})\n\ngraph = NDPLZGraph(data, verbose=True)\n</code></pre>"},{"location":"concepts/graph-types/#key-features_1","title":"Key Features","text":"<ul> <li>Double position: Captures exact pattern boundaries</li> <li>Higher resolution: Better for sequence-level analysis</li> <li>Larger graphs: 4-letter alphabet but more positions</li> </ul>"},{"location":"concepts/graph-types/#naivelzgraph","title":"NaiveLZGraph","text":"<p>Naive LZGraph (No positional encoding)</p>"},{"location":"concepts/graph-types/#when-to-use_2","title":"When to Use","text":"<ul> <li>Cross-repertoire comparisons</li> <li>Feature extraction for machine learning</li> <li>Fixed-dimension representations</li> <li>Memory-constrained environments</li> </ul>"},{"location":"concepts/graph-types/#node-format_2","title":"Node Format","text":"<pre><code>&lt;pattern&gt;\n</code></pre> <p>Just the raw pattern, no position information.</p>"},{"location":"concepts/graph-types/#example_2","title":"Example","text":"<pre><code>from LZGraphs import NaiveLZGraph\nfrom LZGraphs.utilities import generate_kmer_dictionary\n\n# Create shared dictionary\ndictionary = generate_kmer_dictionary(6)  # All patterns up to length 6\n\n# Build graphs with consistent node sets\nsequences1 = data1['cdr3_rearrangement'].tolist()\nsequences2 = data2['cdr3_rearrangement'].tolist()\n\ngraph1 = NaiveLZGraph(sequences1, dictionary)\ngraph2 = NaiveLZGraph(sequences2, dictionary)\n\n# Feature vectors have same dimensions\nfeatures1 = graph1.eigenvector_centrality()\nfeatures2 = graph2.eigenvector_centrality()\n</code></pre>"},{"location":"concepts/graph-types/#key-features_2","title":"Key Features","text":"<ul> <li>Fixed dictionary: Same nodes across all repertoires</li> <li>Consistent dimensions: Ideal for ML pipelines</li> <li>No position info: Simpler but less detailed</li> </ul>"},{"location":"concepts/graph-types/#choosing-the-right-type","title":"Choosing the Right Type","text":"<pre><code>flowchart TD\n    A[Start] --&gt; B{Sequence type?}\n    B --&gt;|Amino acids| C{Need ML features?}\n    B --&gt;|Nucleotides| D{Need ML features?}\n\n    C --&gt;|Yes| E[NaiveLZGraph]\n    C --&gt;|No| F[AAPLZGraph]\n\n    D --&gt;|Yes| E\n    D --&gt;|No| G{Need high resolution?}\n\n    G --&gt;|Yes| H[NDPLZGraph]\n    G --&gt;|No| I[NaiveLZGraph or NDPLZGraph]</code></pre>"},{"location":"concepts/graph-types/#quick-decision-guide","title":"Quick Decision Guide","text":"<ol> <li>\"I want standard TCR analysis\" \u2192 AAPLZGraph</li> <li>\"I want nucleotide-level detail\" \u2192 NDPLZGraph</li> <li>\"I want to compare multiple repertoires with ML\" \u2192 NaiveLZGraph</li> <li>\"I want consistent feature vectors\" \u2192 NaiveLZGraph with shared dictionary</li> </ol>"},{"location":"concepts/graph-types/#memory-and-performance","title":"Memory and Performance","text":""},{"location":"concepts/graph-types/#graph-size-estimates","title":"Graph Size Estimates","text":"<p>For a repertoire of N sequences with average length L:</p> Graph Type Approximate Nodes Approximate Edges AAPLZGraph O(20 \u00d7 L) O(N \u00d7 L) NDPLZGraph O(4 \u00d7 L\u00b2) O(N \u00d7 L) NaiveLZGraph O(dictionary size) O(unique patterns)"},{"location":"concepts/graph-types/#practical-recommendations","title":"Practical Recommendations","text":"<pre><code># Check your graph size\nprint(f\"Nodes: {graph.graph.number_of_nodes()}\")\nprint(f\"Edges: {graph.graph.number_of_edges()}\")\n\n# Estimate memory (rough)\nimport sys\nsize_mb = sys.getsizeof(graph) / (1024 * 1024)\nprint(f\"Approximate size: {size_mb:.1f} MB\")\n</code></pre>"},{"location":"concepts/graph-types/#converting-between-types","title":"Converting Between Types","text":"<p>You cannot directly convert between graph types, but you can:</p>"},{"location":"concepts/graph-types/#re-encode-sequences","title":"Re-encode Sequences","text":"<pre><code># Get sequences from one format\naa_sequences = data['cdr3_amino_acid'].tolist()\n\n# Build different graph types\naa_graph = AAPLZGraph(data)\n\n# For NaiveLZGraph, use the sequences directly\nnaive_graph = NaiveLZGraph(\n    aa_sequences,\n    generate_kmer_dictionary(6)\n)\n</code></pre>"},{"location":"concepts/graph-types/#compare-analyses","title":"Compare Analyses","text":"<pre><code># Same repertoire, different representations\npgen_aa = aa_graph.walk_probability(\n    AAPLZGraph.encode_sequence(sequence)\n)\npgen_naive = naive_graph.walk_probability(\n    lempel_ziv_decomposition(sequence)\n)\n\nprint(f\"AAPLZGraph Pgen:   {pgen_aa:.2e}\")\nprint(f\"NaiveLZGraph Pgen: {pgen_naive:.2e}\")\n</code></pre>"},{"location":"concepts/graph-types/#next-steps","title":"Next Steps","text":"<ul> <li>Probability Model - How graphs calculate probabilities</li> <li>LZ76 Algorithm - Understand the encoding</li> <li>API Reference - Detailed class documentation</li> </ul>"},{"location":"concepts/lz76-algorithm/","title":"LZ76 Algorithm","text":"<p>The Lempel-Ziv 1976 (LZ76) algorithm is the foundation of LZGraphs' sequence encoding. Understanding how it works helps you interpret graph structure and encoding results.</p>"},{"location":"concepts/lz76-algorithm/#what-is-lz76","title":"What is LZ76?","text":"<p>LZ76 is a lossless compression algorithm that decomposes a sequence into a series of unique subpatterns. Each new pattern extends a previously seen pattern by one character.</p>"},{"location":"concepts/lz76-algorithm/#how-it-works","title":"How It Works","text":""},{"location":"concepts/lz76-algorithm/#step-by-step-decomposition","title":"Step-by-Step Decomposition","text":"<p>Let's decompose the sequence <code>CASSLE</code>:</p> <pre><code>Input: C A S S L E\n       \u2502 \u2502 \u2502 \u2502 \u2502 \u2502\nStep 1: C          \u2192 Dictionary: {C}\nStep 2:   A        \u2192 Dictionary: {C, A}\nStep 3:     S      \u2192 Dictionary: {C, A, S}\nStep 4:       S L  \u2192 \"SL\" (S + new char L) \u2192 Dictionary: {C, A, S, SL}\nStep 5:           E \u2192 Dictionary: {C, A, S, SL, E}\n\nResult: [C, A, S, SL, E]\n</code></pre>"},{"location":"concepts/lz76-algorithm/#key-properties","title":"Key Properties","text":"<ol> <li>Unique patterns: Each pattern in the decomposition is unique</li> <li>Incremental building: New patterns extend previous ones</li> <li>Lossless: Original sequence can be reconstructed</li> <li>Deterministic: Same input always produces same output</li> </ol>"},{"location":"concepts/lz76-algorithm/#python-implementation","title":"Python Implementation","text":"<p>LZGraphs uses this algorithm internally:</p> <pre><code>from LZGraphs.utilities import lempel_ziv_decomposition\n\n# Basic decomposition\nsequence = \"CASSLEPSGGTDTQYF\"\npatterns = lempel_ziv_decomposition(sequence)\nprint(patterns)\n# ['C', 'A', 'S', 'SL', 'E', 'P', 'SG', 'G', 'T', 'D', 'TQ', 'Y', 'F']\n</code></pre>"},{"location":"concepts/lz76-algorithm/#verify-reconstruction","title":"Verify Reconstruction","text":"<pre><code># Patterns concatenate to original\nreconstructed = ''.join(patterns)\nprint(f\"Original:      {sequence}\")\nprint(f\"Reconstructed: {reconstructed}\")\nprint(f\"Match: {sequence == reconstructed}\")\n</code></pre>"},{"location":"concepts/lz76-algorithm/#why-lz76-for-sequences","title":"Why LZ76 for Sequences?","text":""},{"location":"concepts/lz76-algorithm/#1-captures-structure","title":"1. Captures Structure","text":"<p>Unlike k-mer approaches, LZ76 adapts to the sequence:</p> <pre><code># Repetitive sequence\nrep_seq = \"AAAAAA\"\nprint(lempel_ziv_decomposition(rep_seq))\n# ['A', 'AA', 'AAA']  - Captures repetition\n\n# Diverse sequence\ndiv_seq = \"ABCDEF\"\nprint(lempel_ziv_decomposition(div_seq))\n# ['A', 'B', 'C', 'D', 'E', 'F']  - All unique\n</code></pre>"},{"location":"concepts/lz76-algorithm/#2-variable-length-patterns","title":"2. Variable-Length Patterns","text":"<p>LZ76 naturally finds patterns of different lengths:</p> <pre><code>sequence = \"CASSLEPSGGTDTQYF\"\npatterns = lempel_ziv_decomposition(sequence)\n\n# Pattern lengths vary based on repetition\nlengths = [len(p) for p in patterns]\nprint(f\"Patterns: {patterns}\")\nprint(f\"Lengths:  {lengths}\")\n</code></pre>"},{"location":"concepts/lz76-algorithm/#3-compression-reflects-complexity","title":"3. Compression Reflects Complexity","text":"<pre><code># More repetitive = fewer patterns\nsimple = \"AAAAAAAAAAAA\"\ncomplex = \"ABCDEFGHIJKL\"\n\nsimple_patterns = lempel_ziv_decomposition(simple)\ncomplex_patterns = lempel_ziv_decomposition(complex)\n\nprint(f\"Simple ({len(simple)} chars):  {len(simple_patterns)} patterns\")\nprint(f\"Complex ({len(complex)} chars): {len(complex_patterns)} patterns\")\n</code></pre>"},{"location":"concepts/lz76-algorithm/#positional-encoding","title":"Positional Encoding","text":"<p>LZGraphs extends LZ76 with position information:</p>"},{"location":"concepts/lz76-algorithm/#aaplzgraph-encoding","title":"AAPLZGraph Encoding","text":"<pre><code>from LZGraphs import AAPLZGraph\n\nsequence = \"CASSLE\"\nencoded = AAPLZGraph.encode_sequence(sequence)\nprint(encoded)\n# ['C_1', 'A_2', 'S_3', 'SL_5', 'E_6']\n</code></pre> <p>The <code>_N</code> suffix indicates the ending position of each pattern:</p> Pattern Start End Encoded C 1 1 C_1 A 2 2 A_2 S 3 3 S_3 SL 4 5 SL_5 E 6 6 E_6"},{"location":"concepts/lz76-algorithm/#ndplzgraph-encoding","title":"NDPLZGraph Encoding","text":"<p>NDPLZGraph uses double positions (start and end):</p> <pre><code>from LZGraphs import NDPLZGraph\n\nsequence = \"TGTGCC\"\nencoded = NDPLZGraph.encode_sequence(sequence)\nprint(encoded)\n# ['T_1_1', 'G_2_2', 'T_3_3', 'G_4_4', 'C_5_5', 'C_6_6']\n</code></pre>"},{"location":"concepts/lz76-algorithm/#why-position-matters","title":"Why Position Matters","text":"<p>In CDR3 sequences, position carries biological meaning:</p> <ul> <li>Early positions: Often V-gene derived</li> <li>Middle positions: Junction diversity</li> <li>Late positions: Often J-gene derived</li> </ul> <p>Positional encoding allows the graph to distinguish:</p> <pre><code># Same pattern, different positions\nseq1 = \"CASSG\"   # G at position 5\nseq2 = \"GCASS\"   # G at position 1\n\nenc1 = AAPLZGraph.encode_sequence(seq1)\nenc2 = AAPLZGraph.encode_sequence(seq2)\n\nprint(f\"seq1: {enc1}\")  # [..., 'G_5']\nprint(f\"seq2: {enc2}\")  # ['G_1', ...]\n</code></pre>"},{"location":"concepts/lz76-algorithm/#mathematical-properties","title":"Mathematical Properties","text":""},{"location":"concepts/lz76-algorithm/#compression-ratio","title":"Compression Ratio","text":"<p>The number of LZ76 patterns relative to sequence length indicates complexity:</p> <pre><code>def complexity_ratio(sequence):\n    patterns = lempel_ziv_decomposition(sequence)\n    return len(patterns) / len(sequence)\n\n# Compare sequences\nsequences = [\n    \"AAAAAAAAAA\",      # Very simple\n    \"CASSLEPSGGTDTQYF\", # Typical CDR3\n    \"ABCDEFGHIJ\"        # Maximum complexity\n]\n\nfor seq in sequences:\n    ratio = complexity_ratio(seq)\n    print(f\"{seq[:15]:15s} ratio: {ratio:.2f}\")\n</code></pre>"},{"location":"concepts/lz76-algorithm/#pattern-growth","title":"Pattern Growth","text":"<p>For a sequence of length n:</p> <ul> <li>Maximum patterns: n (every character is new)</li> <li>Minimum patterns: O(log n) (highly repetitive)</li> <li>Typical CDR3: Between these extremes</li> </ul>"},{"location":"concepts/lz76-algorithm/#connection-to-diversity","title":"Connection to Diversity","text":"<p>LZ76 complexity connects to repertoire diversity:</p> <ul> <li>K-diversity: Counts unique patterns across samples</li> <li>Graph nodes: Each pattern becomes a potential node</li> <li>Graph edges: Pattern transitions become edges</li> </ul> <p>This creates a natural bridge from sequences to graph metrics.</p>"},{"location":"concepts/lz76-algorithm/#next-steps","title":"Next Steps","text":"<ul> <li>Graph Types - How encoding affects graph structure</li> <li>Probability Model - Using patterns for probability</li> <li>Tutorials: Diversity Metrics - Apply to real data</li> </ul>"},{"location":"concepts/probability-model/","title":"Probability Model","text":"<p>LZGraphs calculates sequence generation probability (Pgen) using edge-weighted random walks. This page explains the mathematical foundation.</p>"},{"location":"concepts/probability-model/#the-core-idea","title":"The Core Idea","text":"<p>A sequence's probability is the product of:</p> <ol> <li>Initial probability: Likelihood of starting with the first pattern</li> <li>Transition probabilities: Likelihood of each pattern-to-pattern transition</li> </ol> \\[ P(\\text{sequence}) = P(\\text{start}) \\times \\prod_{i=1}^{n-1} P(\\text{node}_{i+1} | \\text{node}_i) \\]"},{"location":"concepts/probability-model/#how-it-works","title":"How It Works","text":""},{"location":"concepts/probability-model/#step-1-encode-the-sequence","title":"Step 1: Encode the Sequence","text":"<pre><code>from LZGraphs import AAPLZGraph\n\nsequence = \"CASSLE\"\nencoded = AAPLZGraph.encode_sequence(sequence)\nprint(encoded)\n# ['C_1', 'A_2', 'S_3', 'SL_5', 'E_6']\n</code></pre>"},{"location":"concepts/probability-model/#step-2-look-up-initial-probability","title":"Step 2: Look Up Initial Probability","text":"<p>The probability of starting with <code>C_1</code>:</p> <pre><code># Initial state probability\np_start = graph.subpattern_individual_probability.loc['C_1', 'proba']\nprint(f\"P(start with C_1) = {p_start:.4f}\")\n</code></pre>"},{"location":"concepts/probability-model/#step-3-multiply-edge-weights","title":"Step 3: Multiply Edge Weights","text":"<p>For each transition, get the edge weight:</p> <pre><code># Transition probabilities (edge weights)\np_C1_A2 = graph.graph['C_1']['A_2']['weight']\np_A2_S3 = graph.graph['A_2']['S_3']['weight']\np_S3_SL5 = graph.graph['S_3']['SL_5']['weight']\np_SL5_E6 = graph.graph['SL_5']['E_6']['weight']\n\n# Total probability\npgen = p_start * p_C1_A2 * p_A2_S3 * p_S3_SL5 * p_SL5_E6\nprint(f\"P(CASSLE) = {pgen:.2e}\")\n</code></pre>"},{"location":"concepts/probability-model/#using-walk_probability","title":"Using walk_probability","text":"<p>This is exactly what <code>walk_probability</code> computes:</p> <pre><code>pgen = graph.walk_probability(encoded)\nprint(f\"P(CASSLE) = {pgen:.2e}\")\n</code></pre>"},{"location":"concepts/probability-model/#edge-weight-normalization","title":"Edge Weight Normalization","text":"<p>Edge weights are normalized transition probabilities:</p> \\[ w(A \\to B) = \\frac{\\text{count}(A \\to B)}{\\sum_{X} \\text{count}(A \\to X)} \\] <p>This ensures outgoing edges from any node sum to 1:</p> <pre><code># Check normalization\nnode = 'C_1'\nsuccessors = list(graph.graph.successors(node))\ntotal_weight = sum(graph.graph[node][s]['weight'] for s in successors)\nprint(f\"Sum of weights from {node}: {total_weight:.4f}\")  # Should be ~1.0\n</code></pre>"},{"location":"concepts/probability-model/#log-probability","title":"Log Probability","text":"<p>For numerical stability with very small probabilities, use log-space:</p> <pre><code># Direct probability (may underflow for long sequences)\npgen = graph.walk_probability(encoded)\nprint(f\"P = {pgen}\")  # Might be 0.0 due to underflow\n\n# Log probability (numerically stable)\nlog_pgen = graph.walk_probability(encoded, use_log=True)\nprint(f\"log P = {log_pgen:.2f}\")\n</code></pre>"},{"location":"concepts/probability-model/#mathematical-relationship","title":"Mathematical Relationship","text":"\\[ \\log P = \\log P(\\text{start}) + \\sum_{i=1}^{n-1} \\log P(\\text{edge}_i) \\]"},{"location":"concepts/probability-model/#when-to-use-log-probability","title":"When to Use Log Probability","text":"<ul> <li>Comparing many sequences</li> <li>Working with long sequences</li> <li>Performing arithmetic on probabilities</li> <li>Avoiding numerical underflow (P &lt; 10^{-300})</li> </ul>"},{"location":"concepts/probability-model/#gene-constrained-probability","title":"Gene-Constrained Probability","text":"<p>When V/J genes are annotated, edges also carry gene information:</p> <pre><code># Edge has gene distribution\nedge_data = graph.graph['C_1']['A_2']\nprint(edge_data.keys())\n# dict_keys(['weight', 'gene_weight', 'V', 'J'])\n</code></pre>"},{"location":"concepts/probability-model/#gene-weighted-walks","title":"Gene-Weighted Walks","text":"<p>The <code>genomic_random_walk</code> uses gene weights to constrain generation:</p> <pre><code># Generate sequence consistent with gene usage\nwalk, v_gene, j_gene = graph.genomic_random_walk()\n</code></pre>"},{"location":"concepts/probability-model/#probability-of-zero","title":"Probability of Zero","text":"<p>A sequence has probability 0 if:</p> <ol> <li>Missing node: A pattern was never observed</li> <li>Missing edge: A transition was never observed</li> </ol> <pre><code># Check why probability is zero\nsequence = \"CASSXYZABC\"  # Contains rare pattern XYZ\nencoded = AAPLZGraph.encode_sequence(sequence)\n\nfor i, node in enumerate(encoded):\n    if not graph.graph.has_node(node):\n        print(f\"Missing node: {node}\")\n\nfor i in range(len(encoded) - 1):\n    if not graph.graph.has_edge(encoded[i], encoded[i+1]):\n        print(f\"Missing edge: {encoded[i]} -&gt; {encoded[i+1]}\")\n</code></pre>"},{"location":"concepts/probability-model/#probability-interpretation","title":"Probability Interpretation","text":""},{"location":"concepts/probability-model/#absolute-probability","title":"Absolute Probability","text":"<p>The raw Pgen value indicates how likely this exact sequence is:</p> <ul> <li>High Pgen (e.g., 10^-8): Common sequence patterns</li> <li>Low Pgen (e.g., 10^-20): Rare sequence patterns</li> <li>Zero Pgen: Contains unobserved patterns</li> </ul>"},{"location":"concepts/probability-model/#relative-probability","title":"Relative Probability","text":"<p>More useful for comparing sequences:</p> <pre><code>sequences = ['CASSLEPSGGTDTQYF', 'CASSLGQGSTEAFF', 'CASSXYZRARESEQ']\n\nprobs = []\nfor seq in sequences:\n    try:\n        enc = AAPLZGraph.encode_sequence(seq)\n        log_p = graph.walk_probability(enc, use_log=True)\n        probs.append((seq, log_p))\n    except:\n        probs.append((seq, float('-inf')))\n\n# Sort by probability\nprobs.sort(key=lambda x: x[1], reverse=True)\nfor seq, log_p in probs:\n    print(f\"{seq}: log P = {log_p:.2f}\")\n</code></pre>"},{"location":"concepts/probability-model/#connection-to-other-metrics","title":"Connection to Other Metrics","text":""},{"location":"concepts/probability-model/#perplexity","title":"Perplexity","text":"<p>Perplexity is derived from probability:</p> \\[ \\text{Perplexity} = P^{-1/n} \\] <p>Where n is the sequence length. Lower perplexity means the sequence \"fits\" the model better.</p>"},{"location":"concepts/probability-model/#lzcentrality","title":"LZCentrality","text":"<p>LZCentrality combines probability with graph structure:</p> <pre><code>from LZGraphs import LZCentrality\n\ncentrality = LZCentrality(graph, sequence)\n</code></pre>"},{"location":"concepts/probability-model/#entropy","title":"Entropy","text":"<p>Graph entropy relates to the distribution of probabilities across all possible paths.</p>"},{"location":"concepts/probability-model/#practical-example","title":"Practical Example","text":"<p>Compare sequences by their generation probability:</p> <pre><code>import pandas as pd\nfrom LZGraphs import AAPLZGraph\n\n# Build graph\ndata = pd.read_csv(\"repertoire.csv\")\ngraph = AAPLZGraph(data, verbose=False)\n\n# Analyze sequences\ntest_sequences = [\n    \"CASSLEPSGGTDTQYF\",\n    \"CASSLGQGSTEAFF\",\n    \"CASSELPSGGTDTQYF\",  # Slight variant\n]\n\nresults = []\nfor seq in test_sequences:\n    enc = AAPLZGraph.encode_sequence(seq)\n    log_pgen = graph.walk_probability(enc, use_log=True)\n    results.append({\n        'sequence': seq,\n        'length': len(seq),\n        'log_pgen': log_pgen,\n        'pgen': 10**log_pgen if log_pgen &gt; -300 else 0\n    })\n\ndf = pd.DataFrame(results)\nprint(df.sort_values('log_pgen', ascending=False))\n</code></pre>"},{"location":"concepts/probability-model/#next-steps","title":"Next Steps","text":"<ul> <li>LZ76 Algorithm - How sequences become walks</li> <li>Graph Types - Different encoding schemes</li> <li>Tutorials: Sequence Analysis - Apply to real data</li> </ul>"},{"location":"examples/","title":"Examples Gallery","text":"<p>Interactive Jupyter notebooks demonstrating LZGraphs in action.</p>"},{"location":"examples/#available-notebooks","title":"Available Notebooks","text":""},{"location":"examples/#aaplzgraph-example","title":"AAPLZGraph Example","text":"<p>Complete amino acid graph tutorial</p> <p>Build graphs, calculate probabilities, generate sequences, and visualize results.</p> <p> View Notebook</p>"},{"location":"examples/#ndplzgraph-example","title":"NDPLZGraph Example","text":"<p>Nucleotide sequence analysis</p> <p>Work with nucleotide CDR3 sequences using double positional encoding.</p> <p> View Notebook</p>"},{"location":"examples/#metrics-example","title":"Metrics Example","text":"<p>Diversity and entropy analysis</p> <p>Calculate K1000, LZCentrality, entropy metrics, and compare repertoires.</p> <p> View Notebook</p>"},{"location":"examples/#naivelzgraph-example","title":"NaiveLZGraph Example","text":"<p>Feature extraction for ML</p> <p>Use NaiveLZGraph for consistent feature vectors and cross-repertoire analysis.</p> <p> View Notebook</p>"},{"location":"examples/#information-theoretic-analysis","title":"Information-Theoretic Analysis","text":"<p>Advanced repertoire characterization</p> <p>Transition predictability, compression ratio, path entropy rate, transition JSD, mutual information profiles, and repertoire fingerprinting.</p> <p> View Notebook</p>"},{"location":"examples/#running-notebooks-locally","title":"Running Notebooks Locally","text":""},{"location":"examples/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/MuteJester/LZGraphs.git\ncd LZGraphs\n</code></pre>"},{"location":"examples/#2-install-dependencies","title":"2. Install Dependencies","text":"<pre><code>pip install -e .\npip install jupyter\n</code></pre>"},{"location":"examples/#3-launch-jupyter","title":"3. Launch Jupyter","text":"<pre><code>cd Examples\njupyter notebook\n</code></pre>"},{"location":"examples/#sample-data","title":"Sample Data","text":"<p>The examples use these datasets included in the repository:</p> File Description Sequences <code>ExampleData1.csv</code> TCR repertoire sample 1 ~20,000 <code>ExampleData2.csv</code> TCR repertoire sample 2 ~15,000 <code>ExampleData3.csv</code> TCR repertoire sample 3 ~10,000"},{"location":"examples/#data-format","title":"Data Format","text":"<pre><code>import pandas as pd\n\ndata = pd.read_csv(\"Examples/ExampleData1.csv\")\nprint(data.columns.tolist())\n# ['cdr3_amino_acid', 'cdr3_rearrangement', 'V', 'J']\n\nprint(data.head())\n</code></pre>"},{"location":"examples/#quick-examples","title":"Quick Examples","text":""},{"location":"examples/#build-your-first-graph","title":"Build Your First Graph","text":"<pre><code>import pandas as pd\nfrom LZGraphs import AAPLZGraph\n\n# Load example data\ndata = pd.read_csv(\"Examples/ExampleData1.csv\")\n\n# Build graph\ngraph = AAPLZGraph(data, verbose=True)\n\n# Check stats\nprint(f\"Nodes: {graph.graph.number_of_nodes()}\")\nprint(f\"Edges: {graph.graph.number_of_edges()}\")\n</code></pre>"},{"location":"examples/#calculate-diversity","title":"Calculate Diversity","text":"<pre><code>from LZGraphs import K1000_Diversity, AAPLZGraph\n\nsequences = data['cdr3_amino_acid'].tolist()\nk1000 = K1000_Diversity(sequences, AAPLZGraph.encode_sequence, draws=30)\nprint(f\"K1000: {k1000:.1f}\")\n</code></pre>"},{"location":"examples/#generate-sequences","title":"Generate Sequences","text":"<pre><code># Generate with gene constraints\nwalk, v_gene, j_gene = graph.genomic_random_walk()\nsequence = ''.join([AAPLZGraph.clean_node(n) for n in walk])\nprint(f\"Generated: {sequence}\")\nprint(f\"V: {v_gene}, J: {j_gene}\")\n</code></pre>"},{"location":"examples/#whats-covered","title":"What's Covered","text":"Notebook Topics AAPLZGraph Graph construction, probabilities, random walks, visualization NDPLZGraph Nucleotide encoding, double positions, gene analysis Metrics K-diversity, entropy, perplexity, JS divergence NaiveLZGraph Fixed dictionaries, eigenvector centrality, ML features Information-Theoretic Analysis Transition predictability, compression ratio, path entropy, TMIP, transition JSD"},{"location":"examples/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Installation and basics</li> <li>Tutorials - Step-by-step guides</li> <li>API Reference - Complete documentation</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to LZGraphs! This section will help you get up and running quickly with the library.</p>"},{"location":"getting-started/#what-is-lzgraphs","title":"What is LZGraphs?","text":"<p>LZGraphs is a Python library that uses the Lempel-Ziv 76 (LZ76) compression algorithm to create graph representations of T-cell receptor (TCR) repertoires. These graphs capture the statistical properties of CDR3 sequences, enabling:</p> <ul> <li>Probability estimation - Calculate the generation probability of any sequence</li> <li>Sequence generation - Generate new sequences following repertoire statistics</li> <li>Diversity analysis - Measure repertoire complexity using novel metrics</li> <li>Comparison - Compare repertoires using graph-based divergence measures</li> </ul>"},{"location":"getting-started/#quick-links","title":"Quick Links","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install LZGraphs and its dependencies</p>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":"<p>Build your first graph in 5 minutes</p>"},{"location":"getting-started/#first-steps","title":"First Steps","text":"<p>Understand the basics and choose the right graph type</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before using LZGraphs, you should have:</p> <ul> <li>Python 3.9 or higher installed</li> <li>Basic familiarity with pandas DataFrames</li> <li>Understanding of TCR/CDR3 sequences (helpful but not required)</li> </ul>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>After completing the Getting Started guide, explore:</p> <ul> <li>Tutorials - Detailed walkthroughs of common tasks</li> <li>Concepts - Understand the theory behind LZGraphs</li> <li>API Reference - Complete documentation of all classes and functions</li> </ul>"},{"location":"getting-started/first-steps/","title":"First Steps","text":"<p>This guide helps you understand the fundamentals of LZGraphs and choose the right approach for your analysis.</p>"},{"location":"getting-started/first-steps/#understanding-your-data","title":"Understanding Your Data","text":"<p>LZGraphs works with CDR3 sequences from T-cell receptor repertoires. Your data should be in a pandas DataFrame with at minimum a sequence column.</p>"},{"location":"getting-started/first-steps/#required-columns","title":"Required Columns","text":"Graph Type Sequence Column Description AAPLZGraph <code>cdr3_amino_acid</code> Amino acid sequences NDPLZGraph <code>cdr3_rearrangement</code> Nucleotide sequences NaiveLZGraph Any List of strings"},{"location":"getting-started/first-steps/#optional-columns","title":"Optional Columns","text":"Column Purpose <code>V</code> V gene/allele annotation (e.g., <code>TRBV16-1*01</code>) <code>J</code> J gene/allele annotation (e.g., <code>TRBJ1-2*01</code>)"},{"location":"getting-started/first-steps/#choosing-the-right-graph-type","title":"Choosing the Right Graph Type","text":"<p>LZGraphs provides three graph types, each optimized for different use cases:</p> <pre><code>flowchart TD\n    A[What type of sequences?] --&gt; B{Amino Acids?}\n    B --&gt;|Yes| C{Need gene info?}\n    B --&gt;|No| D{Nucleotides?}\n    C --&gt;|Yes| E[AAPLZGraph]\n    C --&gt;|No| F[AAPLZGraph or NaiveLZGraph]\n    D --&gt;|Yes| G{Need gene info?}\n    D --&gt;|No| H[NaiveLZGraph]\n    G --&gt;|Yes| I[NDPLZGraph]\n    G --&gt;|No| J[NDPLZGraph or NaiveLZGraph]</code></pre>"},{"location":"getting-started/first-steps/#aaplzgraph-amino-acid-positional","title":"AAPLZGraph (Amino Acid Positional)","text":"<p>Best for: Amino acid CDR3 sequences with positional information</p> <pre><code>from LZGraphs import AAPLZGraph\n\ngraph = AAPLZGraph(data)  # data has 'cdr3_amino_acid' column\n</code></pre> <p>Features: - Position-aware encoding (e.g., <code>C_1</code>, <code>A_2</code>, <code>S_3</code>) - V/J gene annotation support - Compact graphs for amino acid alphabets - Ideal for most TCR analysis tasks</p>"},{"location":"getting-started/first-steps/#ndplzgraph-nucleotide-double-positional","title":"NDPLZGraph (Nucleotide Double Positional)","text":"<p>Best for: Nucleotide CDR3 sequences with fine-grained positional information</p> <pre><code>from LZGraphs import NDPLZGraph\n\ngraph = NDPLZGraph(data)  # data has 'cdr3_rearrangement' column\n</code></pre> <p>Features: - Double position encoding for higher resolution - V/J gene annotation support - Better for sequence-level analysis - Larger graphs than AAPLZGraph</p>"},{"location":"getting-started/first-steps/#naivelzgraph","title":"NaiveLZGraph","text":"<p>Best for: Custom dictionaries, cross-repertoire comparisons, or machine learning features</p> <pre><code>from LZGraphs import NaiveLZGraph\nfrom LZGraphs.utilities import generate_kmer_dictionary\n\n# Create a fixed dictionary for consistent feature vectors\ndictionary = generate_kmer_dictionary(6)\n\n# Build graph with fixed dictionary\ngraph = NaiveLZGraph(sequences, dictionary)\n</code></pre> <p>Features: - Fixed dictionary across all repertoires - Consistent feature dimensions for ML - No positional encoding (simpler graphs) - Useful for eigenvector centrality features</p>"},{"location":"getting-started/first-steps/#quick-comparison","title":"Quick Comparison","text":"Feature AAPLZGraph NDPLZGraph NaiveLZGraph Input Amino acids Nucleotides Any strings Position encoding Single Double None V/J gene support Yes Yes No Graph size Medium Large Configurable Best for Most TCR analysis Nucleotide-level ML features"},{"location":"getting-started/first-steps/#input-data-format","title":"Input Data Format","text":""},{"location":"getting-started/first-steps/#example-aaplzgraph-data","title":"Example: AAPLZGraph Data","text":"<pre><code>import pandas as pd\n\ndata = pd.DataFrame({\n    'cdr3_amino_acid': [\n        'CASSLEPSGGTDTQYF',\n        'CASSDTSGGTDTQYF',\n        'CASSLEPQTFTDTFFF',\n        'CASSLGQGSTEAFF'\n    ],\n    'V': [\n        'TRBV16-1*01',\n        'TRBV1-1*01',\n        'TRBV16-1*01',\n        'TRBV5-1*01'\n    ],\n    'J': [\n        'TRBJ1-2*01',\n        'TRBJ1-5*01',\n        'TRBJ2-7*01',\n        'TRBJ1-1*01'\n    ]\n})\n</code></pre>"},{"location":"getting-started/first-steps/#example-ndplzgraph-data","title":"Example: NDPLZGraph Data","text":"<pre><code>data = pd.DataFrame({\n    'cdr3_rearrangement': [\n        'TGTGCCAGCAGTTTAGAGCCCAGCGGGGGG...',\n        'TGTGCCAGCAGTGACACTTCAGGGGGGACT...',\n    ],\n    'V': ['TRBV16-1*01', 'TRBV1-1*01'],\n    'J': ['TRBJ1-2*01', 'TRBJ1-5*01']\n})\n</code></pre>"},{"location":"getting-started/first-steps/#understanding-graph-nodes","title":"Understanding Graph Nodes","text":"<p>Each graph type encodes sequences differently:</p>"},{"location":"getting-started/first-steps/#aaplzgraph-encoding","title":"AAPLZGraph Encoding","text":"<pre><code>from LZGraphs import AAPLZGraph\n\nsequence = \"CASSLGQ\"\nencoded = AAPLZGraph.encode_sequence(sequence)\nprint(encoded)\n# ['C_1', 'A_2', 'S_3', 'SL_5', 'G_6', 'Q_7']\n</code></pre> <p>The <code>_N</code> suffix indicates the position in the sequence.</p>"},{"location":"getting-started/first-steps/#ndplzgraph-encoding","title":"NDPLZGraph Encoding","text":"<pre><code>from LZGraphs import NDPLZGraph\n\nsequence = \"TGTGCC\"\nencoded = NDPLZGraph.encode_sequence(sequence)\nprint(encoded)\n# ['T_1_1', 'G_2_2', 'T_3_3', 'G_4_4', 'C_5_5', 'C_6_6']\n</code></pre> <p>Double position encoding provides finer resolution.</p>"},{"location":"getting-started/first-steps/#naivelzgraph-encoding","title":"NaiveLZGraph Encoding","text":"<pre><code>from LZGraphs.utilities import lempel_ziv_decomposition\n\nsequence = \"TGTGCC\"\nencoded = lempel_ziv_decomposition(sequence)\nprint(encoded)\n# ['T', 'G', 'TG', 'C', 'C']\n</code></pre> <p>No positional information, pure LZ76 decomposition.</p>"},{"location":"getting-started/first-steps/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics:</p> <ol> <li>Graph Construction Tutorial - Build graphs with different options</li> <li>Concepts: LZ76 Algorithm - Understand how encoding works</li> <li>Concepts: Graph Types - Deep dive into graph differences</li> </ol>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide covers different ways to install LZGraphs and verify your installation.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python: 3.9 or higher</li> <li>Operating System: Windows, macOS, or Linux</li> <li>Dependencies: Automatically installed (see below)</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<p>The recommended way to install LZGraphs is via pip:</p> <pre><code>pip install LZGraphs\n</code></pre> <p>This will install LZGraphs along with all required dependencies.</p>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":"<p>For the latest development version:</p> <pre><code>git clone https://github.com/MuteJester/LZGraphs.git\ncd LZGraphs\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute or run tests:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre> <p>This includes additional tools for testing and code quality.</p>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>LZGraphs automatically installs these dependencies:</p> Package Version Purpose <code>networkx</code> \u22653.0 Graph data structures <code>numpy</code> \u22651.24 Numerical operations <code>pandas</code> \u22651.5 Data manipulation <code>matplotlib</code> \u22653.7 Visualization <code>seaborn</code> \u22650.12 Statistical plots <code>scipy</code> \u22651.10 Scientific computing <code>tqdm</code> \u22654.65 Progress bars"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, verify everything works:</p> <pre><code>import LZGraphs\nprint(f\"LZGraphs version: {LZGraphs.__version__}\")\n</code></pre> <p>You should see the version number printed without errors.</p>"},{"location":"getting-started/installation/#quick-test","title":"Quick Test","text":"<p>Run a minimal example to ensure all components work:</p> <pre><code>import pandas as pd\nfrom LZGraphs import AAPLZGraph\n\n# Create minimal test data\ndata = pd.DataFrame({\n    'cdr3_amino_acid': ['CASSLEPSGGTDTQYF', 'CASSDTSGGTDTQYF']\n})\n\n# Build a graph\ngraph = AAPLZGraph(data, verbose=False)\nprint(f\"Graph has {graph.graph.number_of_nodes()} nodes\")\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#import-errors","title":"Import Errors","text":"<p>If you see <code>ModuleNotFoundError</code>:</p> <ol> <li>Ensure you're using the correct Python environment</li> <li>Try reinstalling: <code>pip install --force-reinstall LZGraphs</code></li> </ol>"},{"location":"getting-started/installation/#version-conflicts","title":"Version Conflicts","text":"<p>If you have dependency conflicts:</p> <pre><code>pip install LZGraphs --upgrade\n</code></pre> <p>Or create a fresh virtual environment:</p> <pre><code>python -m venv lzgraphs_env\nsource lzgraphs_env/bin/activate  # On Windows: lzgraphs_env\\Scripts\\activate\npip install LZGraphs\n</code></pre>"},{"location":"getting-started/installation/#still-having-issues","title":"Still Having Issues?","text":"<ul> <li>Check the FAQ for common problems</li> <li>Open an issue on GitHub</li> </ul>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>With LZGraphs installed, proceed to the Quick Start guide to build your first graph.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Build your first LZGraph in 5 minutes. This guide shows the essential workflow for TCR repertoire analysis.</p>"},{"location":"getting-started/quickstart/#step-1-import-and-load-data","title":"Step 1: Import and Load Data","text":"<pre><code>import pandas as pd\nfrom LZGraphs import AAPLZGraph\n\n# Load your repertoire data\n# Your CSV should have a 'cdr3_amino_acid' column (or 'cdr3_rearrangement' for nucleotides)\ndata = pd.read_csv(\"your_repertoire.csv\")\n\n# Preview the data\nprint(data.head())\n</code></pre> <p>Example data format:</p> cdr3_amino_acid V J CASSLEPSGGTDTQYF TRBV16-1*01 TRBJ1-2*01 CASSDTSGGTDTQYF TRBV1-1*01 TRBJ1-5*01 CASSLEPQTFTDTFFF TRBV16-1*01 TRBJ2-7*01 <p>V and J columns are optional</p> <p>Gene annotation columns (<code>V</code> and <code>J</code>) enable gene-aware analysis but aren't required for basic usage.</p>"},{"location":"getting-started/quickstart/#step-2-build-a-graph","title":"Step 2: Build a Graph","text":"<pre><code># Build the graph (with gene annotation)\ngraph = AAPLZGraph(data, verbose=True)\n</code></pre> <p>Output: <pre><code>Gene Information Loaded.. |  0.01  Seconds\nGraph Constructed.. |  0.94  Seconds\nGraph Metadata Derived.. |  0.94  Seconds\n...\nLZGraph Created Successfully.. |  1.37  Seconds\n</code></pre></p>"},{"location":"getting-started/quickstart/#step-3-explore-the-graph","title":"Step 3: Explore the Graph","text":"<pre><code># Basic graph statistics\nprint(f\"Nodes: {graph.graph.number_of_nodes()}\")\nprint(f\"Edges: {graph.graph.number_of_edges()}\")\nprint(f\"Sequences: {sum(graph.lengths.values())}\")\n\n# View length distribution\nprint(\"\\nSequence length distribution:\")\nprint(graph.lengths)\n</code></pre>"},{"location":"getting-started/quickstart/#step-4-calculate-sequence-probability","title":"Step 4: Calculate Sequence Probability","text":"<p>Every sequence has a generation probability based on the repertoire:</p> <pre><code># Encode a sequence\nsequence = \"CASSLEPSGGTDTQYF\"\nencoded = AAPLZGraph.encode_sequence(sequence)\nprint(f\"Encoded: {encoded}\")\n\n# Calculate probability\npgen = graph.walk_probability(encoded)\nprint(f\"P(gen) = {pgen:.2e}\")\n\n# Use log probability for very small values\nlog_pgen = graph.walk_probability(encoded, use_log=True)\nprint(f\"log P(gen) = {log_pgen:.2f}\")\n</code></pre>"},{"location":"getting-started/quickstart/#step-5-generate-new-sequences","title":"Step 5: Generate New Sequences","text":"<p>Generate sequences that follow the statistical patterns of your repertoire:</p> <pre><code># Generate a sequence with gene constraints\nwalk, v_gene, j_gene = graph.genomic_random_walk()\nprint(f\"Generated walk: {walk}\")\nprint(f\"V gene: {v_gene}, J gene: {j_gene}\")\n\n# Convert back to sequence\nsequence = ''.join([AAPLZGraph.clean_node(node) for node in walk])\nprint(f\"Generated sequence: {sequence}\")\n</code></pre>"},{"location":"getting-started/quickstart/#step-6-calculate-diversity","title":"Step 6: Calculate Diversity","text":"<pre><code>from LZGraphs import K1000_Diversity\n\n# Calculate K1000 diversity index\nsequences = data['cdr3_amino_acid'].tolist()\nk1000 = K1000_Diversity(sequences, AAPLZGraph.encode_sequence, draws=30)\nprint(f\"K1000 Diversity: {k1000:.1f}\")\n</code></pre>"},{"location":"getting-started/quickstart/#complete-example","title":"Complete Example","text":"<p>Here's everything together:</p> <pre><code>import pandas as pd\nfrom LZGraphs import AAPLZGraph, K1000_Diversity\n\n# Load data\ndata = pd.read_csv(\"repertoire.csv\")\n\n# Build graph\ngraph = AAPLZGraph(data, verbose=True)\n\n# Analyze a sequence\nseq = \"CASSLEPSGGTDTQYF\"\npgen = graph.walk_probability(AAPLZGraph.encode_sequence(seq))\nprint(f\"\\n{seq}: P(gen) = {pgen:.2e}\")\n\n# Generate new sequence\nwalk, v, j = graph.genomic_random_walk()\nnew_seq = ''.join([AAPLZGraph.clean_node(n) for n in walk])\nprint(f\"Generated: {new_seq} ({v}, {j})\")\n\n# Calculate diversity\nk1000 = K1000_Diversity(data['cdr3_amino_acid'].tolist(),\n                        AAPLZGraph.encode_sequence, draws=30)\nprint(f\"K1000: {k1000:.1f}\")\n</code></pre>"},{"location":"getting-started/quickstart/#whats-next","title":"What's Next?","text":"<p>Now that you've built your first graph, explore:</p> <ul> <li>First Steps - Learn which graph type to use</li> <li>Graph Construction Tutorial - Detailed construction options</li> <li>Concepts: Graph Types - Understand the different graph types</li> </ul>"},{"location":"how-to/","title":"How-To Guides","text":"<p>Task-oriented guides for specific LZGraphs operations.</p>"},{"location":"how-to/#available-guides","title":"Available Guides","text":""},{"location":"how-to/#save-load-graphs","title":"Save &amp; Load Graphs","text":"<p>Persist graphs to disk and reload them later</p>"},{"location":"how-to/#generate-sequences","title":"Generate Sequences","text":"<p>Create new sequences following repertoire statistics</p>"},{"location":"how-to/#compare-repertoires","title":"Compare Repertoires","text":"<p>Measure similarity between different repertoires</p>"},{"location":"how-to/#quick-reference","title":"Quick Reference","text":"Task Guide Key Functions Save a graph Serialization <code>graph.save()</code> Load a graph Serialization <code>AAPLZGraph.load()</code> Generate sequences Sequence Generation <code>random_walk()</code>, <code>genomic_random_walk()</code> Compare repertoires Comparison <code>jensen_shannon_divergence()</code>"},{"location":"how-to/#need-more","title":"Need More?","text":"<ul> <li>Step-by-step learning? \u2192 Tutorials</li> <li>Understanding concepts? \u2192 Concepts</li> <li>API details? \u2192 API Reference</li> </ul>"},{"location":"how-to/repertoire-comparison/","title":"Compare Repertoires","text":"<p>Learn how to measure similarity and differences between TCR repertoires.</p>"},{"location":"how-to/repertoire-comparison/#quick-reference","title":"Quick Reference","text":"<pre><code>from LZGraphs import jensen_shannon_divergence\n\n# Compare two graphs\njsd = jensen_shannon_divergence(graph1, graph2)\nprint(f\"JS Divergence: {jsd:.4f}\")  # 0 = identical, 1 = completely different\n</code></pre>"},{"location":"how-to/repertoire-comparison/#building-graphs-for-comparison","title":"Building Graphs for Comparison","text":"<pre><code>from LZGraphs import AAPLZGraph\nimport pandas as pd\n\n# Load two repertoires\ndata1 = pd.read_csv(\"repertoire1.csv\")\ndata2 = pd.read_csv(\"repertoire2.csv\")\n\n# Build graphs\ngraph1 = AAPLZGraph(data1, verbose=False)\ngraph2 = AAPLZGraph(data2, verbose=False)\n</code></pre>"},{"location":"how-to/repertoire-comparison/#jensen-shannon-divergence","title":"Jensen-Shannon Divergence","text":"<p>The most common method for comparing repertoires:</p> <pre><code>from LZGraphs import jensen_shannon_divergence\n\njsd = jensen_shannon_divergence(graph1, graph2)\nprint(f\"JS Divergence: {jsd:.4f}\")\n</code></pre>"},{"location":"how-to/repertoire-comparison/#interpretation","title":"Interpretation","text":"JSD Value Interpretation 0.0 Identical distributions 0.0-0.1 Very similar 0.1-0.3 Moderately similar 0.3-0.5 Different 0.5-1.0 Very different"},{"location":"how-to/repertoire-comparison/#properties","title":"Properties","text":"<ul> <li>Symmetric: JSD(A,B) = JSD(B,A)</li> <li>Bounded: Always between 0 and 1</li> <li>Metric: Satisfies triangle inequality (when square-rooted)</li> </ul>"},{"location":"how-to/repertoire-comparison/#comparing-multiple-repertoires","title":"Comparing Multiple Repertoires","text":""},{"location":"how-to/repertoire-comparison/#pairwise-comparison","title":"Pairwise Comparison","text":"<pre><code>from itertools import combinations\nimport pandas as pd\n\nrepertoires = {\n    'healthy1': graph1,\n    'healthy2': graph2,\n    'disease1': graph3,\n    'disease2': graph4\n}\n\n# Calculate all pairwise distances\nresults = []\nfor (name1, g1), (name2, g2) in combinations(repertoires.items(), 2):\n    jsd = jensen_shannon_divergence(g1, g2)\n    results.append({\n        'repertoire1': name1,\n        'repertoire2': name2,\n        'jsd': jsd\n    })\n\ndf = pd.DataFrame(results)\nprint(df.sort_values('jsd'))\n</code></pre>"},{"location":"how-to/repertoire-comparison/#distance-matrix","title":"Distance Matrix","text":"<pre><code>import numpy as np\n\nnames = list(repertoires.keys())\nn = len(names)\ndist_matrix = np.zeros((n, n))\n\nfor i, name1 in enumerate(names):\n    for j, name2 in enumerate(names):\n        if i &lt; j:\n            jsd = jensen_shannon_divergence(\n                repertoires[name1],\n                repertoires[name2]\n            )\n            dist_matrix[i, j] = jsd\n            dist_matrix[j, i] = jsd\n\n# Create DataFrame\ndist_df = pd.DataFrame(dist_matrix, index=names, columns=names)\nprint(dist_df)\n</code></pre>"},{"location":"how-to/repertoire-comparison/#heatmap-visualization","title":"Heatmap Visualization","text":"<pre><code>import matplotlib.pyplot as plt\nimport seaborn as sns\n\nplt.figure(figsize=(10, 8))\nsns.heatmap(dist_df, annot=True, cmap='RdYlBu_r', vmin=0, vmax=1)\nplt.title('Repertoire Similarity (JSD)')\nplt.tight_layout()\nplt.savefig('repertoire_heatmap.png', dpi=300)\n</code></pre>"},{"location":"how-to/repertoire-comparison/#comparing-diversity-metrics","title":"Comparing Diversity Metrics","text":""},{"location":"how-to/repertoire-comparison/#k1000-comparison","title":"K1000 Comparison","text":"<pre><code>from LZGraphs import K1000_Diversity, AAPLZGraph\n\ndef compare_diversity(data1, data2, name1=\"Rep1\", name2=\"Rep2\"):\n    seqs1 = data1['cdr3_amino_acid'].tolist()\n    seqs2 = data2['cdr3_amino_acid'].tolist()\n\n    k1000_1 = K1000_Diversity(seqs1, AAPLZGraph.encode_sequence, draws=30)\n    k1000_2 = K1000_Diversity(seqs2, AAPLZGraph.encode_sequence, draws=30)\n\n    print(f\"{name1} K1000: {k1000_1:.1f}\")\n    print(f\"{name2} K1000: {k1000_2:.1f}\")\n    print(f\"Difference: {abs(k1000_1 - k1000_2):.1f}\")\n\ncompare_diversity(data1, data2, \"Healthy\", \"Disease\")\n</code></pre>"},{"location":"how-to/repertoire-comparison/#entropy-comparison","title":"Entropy Comparison","text":"<pre><code>from LZGraphs import node_entropy, edge_entropy, graph_entropy\n\ndef compare_entropy(graph1, graph2, name1=\"Rep1\", name2=\"Rep2\"):\n    metrics = {}\n\n    for name, g in [(name1, graph1), (name2, graph2)]:\n        metrics[name] = {\n            'node_entropy': node_entropy(g),\n            'edge_entropy': edge_entropy(g),\n            'graph_entropy': graph_entropy(g)\n        }\n\n    df = pd.DataFrame(metrics).T\n    print(df)\n    return df\n\ncompare_entropy(graph1, graph2, \"Healthy\", \"Disease\")\n</code></pre>"},{"location":"how-to/repertoire-comparison/#cross-repertoire-analysis","title":"Cross-Repertoire Analysis","text":""},{"location":"how-to/repertoire-comparison/#sequence-probability-across-repertoires","title":"Sequence Probability Across Repertoires","text":"<p>Check how likely sequences from one repertoire are in another:</p> <pre><code>def cross_probability(sequences, source_graph, target_graph):\n    \"\"\"Calculate sequence probabilities in target graph.\"\"\"\n    results = []\n\n    for seq in sequences:\n        try:\n            encoded = AAPLZGraph.encode_sequence(seq)\n            source_prob = source_graph.walk_probability(encoded, use_log=True)\n            target_prob = target_graph.walk_probability(encoded, use_log=True)\n\n            results.append({\n                'sequence': seq,\n                'source_log_p': source_prob,\n                'target_log_p': target_prob,\n                'diff': source_prob - target_prob\n            })\n        except:\n            pass\n\n    return pd.DataFrame(results)\n\n# Sample sequences from repertoire 1\nsample_seqs = data1['cdr3_amino_acid'].sample(100).tolist()\n\n# Calculate probabilities in both graphs\ncross_df = cross_probability(sample_seqs, graph1, graph2)\nprint(cross_df.describe())\n</code></pre>"},{"location":"how-to/repertoire-comparison/#repertoire-specific-sequences","title":"Repertoire-Specific Sequences","text":"<p>Find sequences that are specific to one repertoire:</p> <pre><code>def find_specific_sequences(sequences, graph1, graph2, threshold=-5):\n    \"\"\"Find sequences specific to graph1 (not in graph2).\"\"\"\n    specific = []\n\n    for seq in sequences:\n        try:\n            enc = AAPLZGraph.encode_sequence(seq)\n            p1 = graph1.walk_probability(enc, use_log=True)\n            p2 = graph2.walk_probability(enc, use_log=True)\n\n            # Specific if much more likely in graph1\n            if p1 - p2 &gt; threshold:\n                specific.append({\n                    'sequence': seq,\n                    'log_p_graph1': p1,\n                    'log_p_graph2': p2,\n                    'specificity': p1 - p2\n                })\n        except:\n            pass\n\n    return pd.DataFrame(specific).sort_values('specificity', ascending=False)\n\n# Find repertoire 1 specific sequences\nspecific_seqs = find_specific_sequences(\n    data1['cdr3_amino_acid'].tolist(),\n    graph1, graph2\n)\nprint(specific_seqs.head(10))\n</code></pre>"},{"location":"how-to/repertoire-comparison/#gene-usage-comparison","title":"Gene Usage Comparison","text":"<pre><code>def compare_gene_usage(graph1, graph2, name1=\"Rep1\", name2=\"Rep2\"):\n    \"\"\"Compare V/J gene usage between repertoires.\"\"\"\n\n    # V genes\n    v1 = graph1.marginal_vgenes\n    v2 = graph2.marginal_vgenes\n\n    # Align indices\n    all_v = set(v1.index) | set(v2.index)\n    v_comparison = pd.DataFrame({\n        name1: v1.reindex(all_v).fillna(0),\n        name2: v2.reindex(all_v).fillna(0)\n    })\n    v_comparison['diff'] = v_comparison[name1] - v_comparison[name2]\n\n    # J genes\n    j1 = graph1.marginal_jgenes\n    j2 = graph2.marginal_jgenes\n\n    all_j = set(j1.index) | set(j2.index)\n    j_comparison = pd.DataFrame({\n        name1: j1.reindex(all_j).fillna(0),\n        name2: j2.reindex(all_j).fillna(0)\n    })\n    j_comparison['diff'] = j_comparison[name1] - j_comparison[name2]\n\n    return v_comparison, j_comparison\n\nv_comp, j_comp = compare_gene_usage(graph1, graph2, \"Healthy\", \"Disease\")\nprint(\"Top V gene differences:\")\nprint(v_comp.sort_values('diff', key=abs, ascending=False).head())\n</code></pre>"},{"location":"how-to/repertoire-comparison/#transition-level-comparison","title":"Transition-Level Comparison","text":"<p>Standard JSD compares which subpatterns are used. Transition JSD compares how they connect, detecting structural differences even when subpattern frequencies are similar.</p> <pre><code>from LZGraphs import transition_jsd, transition_kl_divergence\n\n# Symmetric, bounded [0, 1] \u2014 recommended for most use cases\njsd_t = transition_jsd(graph1, graph2)\nprint(f\"Transition JSD: {jsd_t:.4f}\")\n\n# Asymmetric \u2014 use when you have a reference model\nkl_t = transition_kl_divergence(graph1, graph2)  # Can be infinite\nprint(f\"Transition KL(1||2): {kl_t}\")\n</code></pre> <p>When to use transition-level metrics</p> <p>Use <code>transition_jsd</code> instead of <code>jensen_shannon_divergence</code> when you suspect two repertoires use the same subpatterns but connect them differently, e.g. after clonal expansion creates dominant transition paths without changing overall subpattern frequencies.</p>"},{"location":"how-to/repertoire-comparison/#quick-comparison-with-compare_repertoires","title":"Quick Comparison with compare_repertoires","text":"<p>The <code>compare_repertoires</code> function computes all relevant metrics in one call:</p> <pre><code>from LZGraphs import compare_repertoires\n\nresult = compare_repertoires(graph1, graph2)\nprint(result)\n# Returns a pandas Series with 16 metrics including:\n# js_divergence, transition_jsd, cross_entropy, kl_divergence,\n# node/edge entropy, transition_predictability, Jaccard similarity\n</code></pre>"},{"location":"how-to/repertoire-comparison/#complete-comparison-pipeline","title":"Complete Comparison Pipeline","text":"<pre><code>from LZGraphs import (\n    AAPLZGraph, K1000_Diversity,\n    node_entropy, jensen_shannon_divergence,\n    transition_jsd, transition_predictability,\n    compare_repertoires,\n)\n\ndef full_repertoire_comparison(data1, data2, name1=\"Rep1\", name2=\"Rep2\"):\n    \"\"\"Complete comparison of two repertoires.\"\"\"\n\n    # Build graphs\n    print(\"Building graphs...\")\n    graph1 = AAPLZGraph(data1, verbose=False)\n    graph2 = AAPLZGraph(data2, verbose=False)\n\n    # Quick comparison (all metrics at once)\n    result = compare_repertoires(graph1, graph2)\n\n    # Basic stats\n    print(f\"\\n{'='*50}\")\n    print(\"BASIC STATISTICS\")\n    print(f\"{'='*50}\")\n    print(f\"{name1}: {data1.shape[0]} sequences, {graph1.graph.number_of_nodes()} nodes\")\n    print(f\"{name2}: {data2.shape[0]} sequences, {graph2.graph.number_of_nodes()} nodes\")\n\n    # Divergence\n    print(f\"\\n{'='*50}\")\n    print(\"DIVERGENCE\")\n    print(f\"{'='*50}\")\n    print(f\"Node-level JSD:       {result['js_divergence']:.4f}\")\n    print(f\"Transition-level JSD: {result['transition_jsd']:.4f}\")\n\n    # Predictability\n    print(f\"\\n{'='*50}\")\n    print(\"TRANSITION PREDICTABILITY\")\n    print(f\"{'='*50}\")\n    print(f\"{name1}: {result['transition_predictability_1']:.3f}\")\n    print(f\"{name2}: {result['transition_predictability_2']:.3f}\")\n\n    # Diversity\n    print(f\"\\n{'='*50}\")\n    print(\"DIVERSITY\")\n    print(f\"{'='*50}\")\n    seqs1 = data1['cdr3_amino_acid'].tolist()\n    seqs2 = data2['cdr3_amino_acid'].tolist()\n    k1 = K1000_Diversity(seqs1, AAPLZGraph.encode_sequence, draws=30)\n    k2 = K1000_Diversity(seqs2, AAPLZGraph.encode_sequence, draws=30)\n    print(f\"{name1} K1000: {k1:.1f}\")\n    print(f\"{name2} K1000: {k2:.1f}\")\n\n    return graph1, graph2, result\n\n# Run comparison\ng1, g2, metrics = full_repertoire_comparison(data1, data2, \"Healthy\", \"Disease\")\n</code></pre>"},{"location":"how-to/repertoire-comparison/#next-steps","title":"Next Steps","text":"<ul> <li>Tutorials: Diversity Metrics - More metrics</li> <li>Tutorials: Visualization - Visualize comparisons</li> <li>API: Metrics - All comparison functions</li> </ul>"},{"location":"how-to/sequence-generation/","title":"Generate Sequences","text":"<p>Learn how to generate new sequences that follow your repertoire's statistical patterns.</p>"},{"location":"how-to/sequence-generation/#quick-reference","title":"Quick Reference","text":"<pre><code># Basic generation\nwalk = graph.random_walk()\n\n# With gene constraints\nwalk, v_gene, j_gene = graph.genomic_random_walk()\n\n# Convert to sequence\nsequence = ''.join([AAPLZGraph.clean_node(n) for n in walk])\n</code></pre>"},{"location":"how-to/sequence-generation/#basic-sequence-generation","title":"Basic Sequence Generation","text":""},{"location":"how-to/sequence-generation/#random-walk","title":"Random Walk","text":"<p>Generate a sequence following edge probabilities:</p> <pre><code>from LZGraphs import AAPLZGraph\nimport pandas as pd\n\n# Build graph\ndata = pd.read_csv(\"repertoire.csv\")\ngraph = AAPLZGraph(data, verbose=False)\n\n# Generate a random walk\nwalk = graph.random_walk()\nprint(f\"Walk: {walk}\")\n\n# Convert to sequence\nsequence = ''.join([AAPLZGraph.clean_node(node) for node in walk])\nprint(f\"Sequence: {sequence}\")\n</code></pre>"},{"location":"how-to/sequence-generation/#generate-multiple-sequences","title":"Generate Multiple Sequences","text":"<pre><code>generated = []\nfor _ in range(100):\n    walk = graph.random_walk()\n    seq = ''.join([AAPLZGraph.clean_node(n) for n in walk])\n    generated.append(seq)\n\nprint(f\"Generated {len(generated)} sequences\")\nprint(f\"Example: {generated[0]}\")\n</code></pre>"},{"location":"how-to/sequence-generation/#gene-constrained-generation","title":"Gene-Constrained Generation","text":""},{"location":"how-to/sequence-generation/#using-genomic_random_walk","title":"Using genomic_random_walk","text":"<p>Generate sequences consistent with V/J gene usage:</p> <pre><code># Generate with gene constraints\nwalk, v_gene, j_gene = graph.genomic_random_walk()\n\nsequence = ''.join([AAPLZGraph.clean_node(n) for n in walk])\nprint(f\"Sequence: {sequence}\")\nprint(f\"V gene: {v_gene}\")\nprint(f\"J gene: {j_gene}\")\n</code></pre> <p>Requirements</p> <p><code>genomic_random_walk()</code> requires that the graph was built with V and J gene columns.</p>"},{"location":"how-to/sequence-generation/#generate-with-specific-gene-frequencies","title":"Generate with Specific Gene Frequencies","text":"<p>The generated sequences follow the marginal gene distribution:</p> <pre><code>from collections import Counter\n\n# Generate many sequences\nresults = []\nfor _ in range(1000):\n    walk, v, j = graph.genomic_random_walk()\n    results.append({'v_gene': v, 'j_gene': j})\n\n# Check gene distribution\ndf = pd.DataFrame(results)\nprint(\"V gene distribution:\")\nprint(df['v_gene'].value_counts(normalize=True).head())\n\n# Compare to original\nprint(\"\\nOriginal V gene distribution:\")\nprint(graph.marginal_vgenes.head())\n</code></pre>"},{"location":"how-to/sequence-generation/#advanced-generation","title":"Advanced Generation","text":""},{"location":"how-to/sequence-generation/#generate-specific-lengths","title":"Generate Specific Lengths","text":"<p>Filter generated sequences by length:</p> <pre><code>def generate_with_length(graph, target_length, max_attempts=1000):\n    for _ in range(max_attempts):\n        walk = graph.random_walk()\n        seq = ''.join([AAPLZGraph.clean_node(n) for n in walk])\n        if len(seq) == target_length:\n            return seq, walk\n    return None, None\n\n# Generate 15-mer\nseq, walk = generate_with_length(graph, 15)\nif seq:\n    print(f\"Generated 15-mer: {seq}\")\n</code></pre>"},{"location":"how-to/sequence-generation/#generate-from-specific-start","title":"Generate from Specific Start","text":"<p>Start from a specific initial state:</p> <pre><code># Check available initial states\nprint(\"Initial states:\")\nprint(graph.initial_states)\n\n# Note: random_walk starts from initial states by default\n# The initial state is chosen based on observed frequencies\n</code></pre>"},{"location":"how-to/sequence-generation/#batch-generation-with-statistics","title":"Batch Generation with Statistics","text":"<pre><code>import pandas as pd\nfrom tqdm import tqdm\n\ndef generate_repertoire(graph, n_sequences, use_genes=True):\n    \"\"\"Generate a synthetic repertoire.\"\"\"\n    results = []\n\n    for _ in tqdm(range(n_sequences), desc=\"Generating\"):\n        if use_genes:\n            walk, v, j = graph.genomic_random_walk()\n        else:\n            walk = graph.random_walk()\n            v, j = None, None\n\n        seq = ''.join([AAPLZGraph.clean_node(n) for n in walk])\n        results.append({\n            'sequence': seq,\n            'length': len(seq),\n            'v_gene': v,\n            'j_gene': j\n        })\n\n    return pd.DataFrame(results)\n\n# Generate 1000 sequences\nsynthetic = generate_repertoire(graph, 1000)\nprint(synthetic.describe())\n</code></pre>"},{"location":"how-to/sequence-generation/#evaluating-generated-sequences","title":"Evaluating Generated Sequences","text":""},{"location":"how-to/sequence-generation/#check-probability","title":"Check Probability","text":"<pre><code># Generate a sequence\nwalk, v, j = graph.genomic_random_walk()\nsequence = ''.join([AAPLZGraph.clean_node(n) for n in walk])\n\n# Calculate its probability\nencoded = AAPLZGraph.encode_sequence(sequence)\npgen = graph.walk_probability(encoded, use_log=True)\n\nprint(f\"Generated: {sequence}\")\nprint(f\"log P(gen): {pgen:.2f}\")\n</code></pre>"},{"location":"how-to/sequence-generation/#compare-to-original-distribution","title":"Compare to Original Distribution","text":"<pre><code># Original sequence lengths\noriginal_lengths = pd.Series(graph.lengths)\n\n# Generated sequence lengths\nsynthetic = generate_repertoire(graph, 1000)\ngenerated_lengths = synthetic['length'].value_counts()\n\n# Plot comparison\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\noriginal_lengths.plot(kind='bar', alpha=0.5, label='Original', ax=ax)\ngenerated_lengths.plot(kind='bar', alpha=0.5, label='Generated', ax=ax)\nax.legend()\nax.set_xlabel('Sequence Length')\nax.set_ylabel('Count')\nplt.tight_layout()\nplt.savefig('length_comparison.png')\n</code></pre>"},{"location":"how-to/sequence-generation/#use-cases","title":"Use Cases","text":""},{"location":"how-to/sequence-generation/#data-augmentation","title":"Data Augmentation","text":"<pre><code># Augment a small repertoire\nsmall_data = pd.read_csv(\"small_repertoire.csv\")  # 100 sequences\ngraph = AAPLZGraph(small_data)\n\n# Generate more sequences\naugmented = generate_repertoire(graph, 1000)\n\n# Combine\ncombined = pd.concat([\n    small_data[['cdr3_amino_acid', 'V', 'J']].rename(\n        columns={'cdr3_amino_acid': 'sequence'}\n    ),\n    augmented[['sequence', 'v_gene', 'j_gene']].rename(\n        columns={'v_gene': 'V', 'j_gene': 'J'}\n    )\n])\n</code></pre>"},{"location":"how-to/sequence-generation/#null-model-generation","title":"Null Model Generation","text":"<pre><code>def generate_null_repertoire(graph, n_sequences):\n    \"\"\"Generate sequences for statistical testing.\"\"\"\n    return generate_repertoire(graph, n_sequences)\n\n# Generate null distribution\nnull_seqs = generate_null_repertoire(graph, 10000)\n\n# Test a specific sequence against null\ntest_seq = \"CASSLEPSGGTDTQYF\"\ntest_pgen = graph.walk_probability(\n    AAPLZGraph.encode_sequence(test_seq),\n    use_log=True\n)\n\n# Calculate p-value\nnull_pgens = []\nfor seq in null_seqs['sequence']:\n    try:\n        pgen = graph.walk_probability(\n            AAPLZGraph.encode_sequence(seq),\n            use_log=True\n        )\n        null_pgens.append(pgen)\n    except:\n        pass\n\np_value = sum(1 for p in null_pgens if p &lt;= test_pgen) / len(null_pgens)\nprint(f\"P-value: {p_value:.4f}\")\n</code></pre>"},{"location":"how-to/sequence-generation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/sequence-generation/#no-gene-data-error","title":"\"No gene data\" Error","text":"<pre><code>try:\n    walk, v, j = graph.genomic_random_walk()\nexcept Exception as e:\n    print(\"Gene data not available. Using random_walk instead.\")\n    walk = graph.random_walk()\n</code></pre>"},{"location":"how-to/sequence-generation/#empty-walks","title":"Empty Walks","text":"<pre><code>walk = graph.random_walk()\nif not walk:\n    print(\"Empty walk generated - check graph structure\")\nelse:\n    print(f\"Walk length: {len(walk)}\")\n</code></pre>"},{"location":"how-to/sequence-generation/#next-steps","title":"Next Steps","text":"<ul> <li>Compare Repertoires - Compare generated vs. original</li> <li>Tutorials: Sequence Analysis - More analysis techniques</li> </ul>"},{"location":"how-to/serialization/","title":"Save and Load Graphs","text":"<p>Learn how to persist LZGraphs to disk and reload them later.</p>"},{"location":"how-to/serialization/#quick-reference","title":"Quick Reference","text":"<pre><code># Save\ngraph.save(\"my_graph.pkl\")\n\n# Load\nloaded = AAPLZGraph.load(\"my_graph.pkl\")\n</code></pre>"},{"location":"how-to/serialization/#saving-graphs","title":"Saving Graphs","text":""},{"location":"how-to/serialization/#basic-save","title":"Basic Save","text":"<pre><code>from LZGraphs import AAPLZGraph\nimport pandas as pd\n\n# Build a graph\ndata = pd.read_csv(\"repertoire.csv\")\ngraph = AAPLZGraph(data, verbose=True)\n\n# Save to disk\ngraph.save(\"my_graph.pkl\")\n</code></pre>"},{"location":"how-to/serialization/#save-with-custom-path","title":"Save with Custom Path","text":"<pre><code>from pathlib import Path\n\n# Save to specific directory\noutput_dir = Path(\"models/graphs\")\noutput_dir.mkdir(parents=True, exist_ok=True)\n\ngraph.save(output_dir / \"repertoire_2024.pkl\")\n</code></pre>"},{"location":"how-to/serialization/#loading-graphs","title":"Loading Graphs","text":""},{"location":"how-to/serialization/#basic-load","title":"Basic Load","text":"<pre><code>from LZGraphs import AAPLZGraph\n\n# Load a saved graph\ngraph = AAPLZGraph.load(\"my_graph.pkl\")\n\n# Verify it works\nprint(f\"Nodes: {graph.graph.number_of_nodes()}\")\nprint(f\"Edges: {graph.graph.number_of_edges()}\")\n</code></pre>"},{"location":"how-to/serialization/#loading-different-graph-types","title":"Loading Different Graph Types","text":"<pre><code>from LZGraphs import AAPLZGraph, NDPLZGraph, NaiveLZGraph\n\n# Load the correct type\naap_graph = AAPLZGraph.load(\"aap_graph.pkl\")\nndp_graph = NDPLZGraph.load(\"ndp_graph.pkl\")\nnaive_graph = NaiveLZGraph.load(\"naive_graph.pkl\")\n</code></pre> <p>Type Matching</p> <p>You must use the same class to load that was used to save. Loading an <code>AAPLZGraph</code> file with <code>NDPLZGraph.load()</code> will raise an error.</p>"},{"location":"how-to/serialization/#use-cases","title":"Use Cases","text":""},{"location":"how-to/serialization/#avoid-recomputation","title":"Avoid Recomputation","text":"<pre><code>from pathlib import Path\n\ncache_file = Path(\"cached_graph.pkl\")\n\nif cache_file.exists():\n    # Load from cache\n    graph = AAPLZGraph.load(cache_file)\n    print(\"Loaded from cache\")\nelse:\n    # Build and cache\n    data = pd.read_csv(\"large_repertoire.csv\")\n    graph = AAPLZGraph(data, verbose=True)\n    graph.save(cache_file)\n    print(\"Built and cached\")\n</code></pre>"},{"location":"how-to/serialization/#batch-processing","title":"Batch Processing","text":"<pre><code>from pathlib import Path\nimport pandas as pd\nfrom LZGraphs import AAPLZGraph\n\n# Process multiple repertoires\ninput_dir = Path(\"data/repertoires\")\noutput_dir = Path(\"data/graphs\")\noutput_dir.mkdir(exist_ok=True)\n\nfor csv_file in input_dir.glob(\"*.csv\"):\n    graph_file = output_dir / f\"{csv_file.stem}.pkl\"\n\n    if not graph_file.exists():\n        data = pd.read_csv(csv_file)\n        graph = AAPLZGraph(data, verbose=False)\n        graph.save(graph_file)\n        print(f\"Saved: {graph_file.name}\")\n</code></pre>"},{"location":"how-to/serialization/#analysis-pipeline","title":"Analysis Pipeline","text":"<pre><code># Step 1: Build and save (expensive)\n# script: build_graphs.py\nfor repertoire_file in repertoire_files:\n    data = pd.read_csv(repertoire_file)\n    graph = AAPLZGraph(data)\n    graph.save(f\"graphs/{repertoire_file.stem}.pkl\")\n\n# Step 2: Analyze (fast, can be rerun)\n# script: analyze_graphs.py\nfor graph_file in Path(\"graphs\").glob(\"*.pkl\"):\n    graph = AAPLZGraph.load(graph_file)\n    # Run analysis...\n</code></pre>"},{"location":"how-to/serialization/#file-format","title":"File Format","text":"<p>LZGraphs uses Python's <code>pickle</code> format:</p> <ul> <li>Binary format: Compact and fast</li> <li>Python-specific: Not portable to other languages</li> <li>Version-sensitive: Best used with same Python/LZGraphs version</li> </ul>"},{"location":"how-to/serialization/#checking-file-contents","title":"Checking File Contents","text":"<pre><code>import pickle\n\nwith open(\"my_graph.pkl\", \"rb\") as f:\n    obj = pickle.load(f)\n\nprint(f\"Type: {type(obj)}\")\nprint(f\"Has graph: {hasattr(obj, 'graph')}\")\n</code></pre>"},{"location":"how-to/serialization/#best-practices","title":"Best Practices","text":""},{"location":"how-to/serialization/#1-use-descriptive-names","title":"1. Use Descriptive Names","text":"<pre><code># Good\ngraph.save(\"tcr_repertoire_patient001_2024-01.pkl\")\n\n# Avoid\ngraph.save(\"g1.pkl\")\n</code></pre>"},{"location":"how-to/serialization/#2-version-your-graphs","title":"2. Version Your Graphs","text":"<pre><code>from datetime import datetime\nimport LZGraphs\n\n# Include version info\nfilename = f\"graph_v{LZGraphs.__version__}_{datetime.now():%Y%m%d}.pkl\"\ngraph.save(filename)\n</code></pre>"},{"location":"how-to/serialization/#3-store-metadata-separately","title":"3. Store Metadata Separately","text":"<pre><code>import json\n\n# Save graph\ngraph.save(\"my_graph.pkl\")\n\n# Save metadata\nmetadata = {\n    \"source_file\": \"repertoire.csv\",\n    \"n_sequences\": len(data),\n    \"created\": str(datetime.now()),\n    \"lzgraphs_version\": LZGraphs.__version__\n}\n\nwith open(\"my_graph_metadata.json\", \"w\") as f:\n    json.dump(metadata, f, indent=2)\n</code></pre>"},{"location":"how-to/serialization/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/serialization/#file-not-found-error","title":"\"File not found\" Error","text":"<pre><code>from pathlib import Path\n\nfilepath = Path(\"my_graph.pkl\")\nif not filepath.exists():\n    print(f\"File does not exist: {filepath.absolute()}\")\n</code></pre>"},{"location":"how-to/serialization/#invalid-pickle-error","title":"\"Invalid pickle\" Error","text":"<p>The file may be corrupted or from an incompatible version:</p> <pre><code>try:\n    graph = AAPLZGraph.load(\"my_graph.pkl\")\nexcept Exception as e:\n    print(f\"Error loading graph: {e}\")\n    # Rebuild from source data\n    data = pd.read_csv(\"original_data.csv\")\n    graph = AAPLZGraph(data)\n</code></pre>"},{"location":"how-to/serialization/#type-mismatch-error","title":"Type Mismatch Error","text":"<pre><code>from LZGraphs import AAPLZGraph, NDPLZGraph\n\ntry:\n    # Wrong type\n    graph = NDPLZGraph.load(\"aap_graph.pkl\")\nexcept TypeError as e:\n    print(f\"Type mismatch: {e}\")\n    # Use correct type\n    graph = AAPLZGraph.load(\"aap_graph.pkl\")\n</code></pre>"},{"location":"how-to/serialization/#next-steps","title":"Next Steps","text":"<ul> <li>Sequence Generation - Generate sequences from saved graphs</li> <li>Compare Repertoires - Compare multiple saved graphs</li> </ul>"},{"location":"resources/changelog/","title":"Changelog","text":"<p>All notable changes to LZGraphs are documented here.</p> <p>This project follows Semantic Versioning.</p>"},{"location":"resources/changelog/#210-2026","title":"[2.1.0] - 2026","text":""},{"location":"resources/changelog/#added","title":"Added","text":"<ul> <li>Information-theoretic metrics for advanced repertoire characterization:<ul> <li><code>transition_predictability</code> \u2014 measures transition determinism, stable across sample sizes (~0.60 for AAPLZGraph)</li> <li><code>graph_compression_ratio</code> \u2014 quantifies path sharing efficiency (edge reuse)</li> <li><code>repertoire_compressibility_index</code> \u2014 compression-framed alias for transition predictability</li> <li><code>path_entropy_rate</code> \u2014 average bits per subpattern step via Monte Carlo</li> <li><code>transition_kl_divergence</code> \u2014 transition-level KL divergence between two graphs</li> <li><code>transition_jsd</code> \u2014 symmetric, bounded transition-level Jensen-Shannon divergence</li> <li><code>transition_mutual_information_profile</code> \u2014 position-specific MI along the CDR3 sequence</li> </ul> </li> <li><code>compare_repertoires</code> now includes <code>transition_jsd</code>, <code>transition_predictability_1</code>, and <code>transition_predictability_2</code></li> <li>New example notebook: Information-Theoretic Analysis with full walkthrough and visualizations</li> </ul>"},{"location":"resources/changelog/#200-2026","title":"[2.0.0] - 2026","text":""},{"location":"resources/changelog/#changed","title":"Changed","text":"<ul> <li>Breaking: All internal modules renamed to snake_case (graphs/, metrics/, utilities/, mixins/, etc.)</li> <li>Complete <code>EdgeData</code> refactor \u2014 raw counts as source of truth</li> <li><code>graph_union</code> rewritten to merge via <code>EdgeData.merge()</code> + <code>recalculate()</code></li> <li>Walk probability model consolidated into LZGraphBase</li> <li>Laplace smoothing via <code>smoothing_alpha</code> parameter</li> </ul>"},{"location":"resources/changelog/#added_1","title":"Added","text":"<ul> <li><code>remove_sequence()</code> method on LZGraphBase</li> <li><code>recalculate()</code> method to recompute all derived state from raw counts</li> <li><code>to_networkx()</code> for external tool compatibility</li> <li><code>walk_log_probability</code> on all graph types</li> <li>Professional documentation with MkDocs Material theme</li> <li>Comprehensive tutorials, how-to guides, and API reference</li> </ul>"},{"location":"resources/changelog/#111-2024","title":"[1.1.1] - 2024","text":""},{"location":"resources/changelog/#fixed","title":"Fixed","text":"<ul> <li>Fixed <code>gene_variation()</code> to correctly identify V/J genes (gene names like \"TRBV30-1*01\")</li> <li>Fixed visualization functions to use correct graph attribute access</li> <li>Added <code>clean_node()</code> method to <code>NaiveLZGraph</code> for consistency</li> </ul>"},{"location":"resources/changelog/#added_2","title":"Added","text":"<ul> <li><code>use_log</code> parameter to <code>walk_probability()</code> for all graph types</li> <li><code>save()</code> and <code>load()</code> methods to <code>NaiveLZGraph</code></li> <li>Enhanced Jupyter notebook examples</li> </ul>"},{"location":"resources/changelog/#110-2024","title":"[1.1.0] - 2024","text":""},{"location":"resources/changelog/#added_3","title":"Added","text":"<ul> <li>Custom exceptions module with comprehensive error hierarchy</li> <li>Automated CI/CD pipeline with semantic-release</li> <li>Type hints throughout the codebase</li> <li><code>py.typed</code> marker for type checker support</li> </ul>"},{"location":"resources/changelog/#changed_1","title":"Changed","text":"<ul> <li>Updated minimum Python version to 3.9</li> <li>Improved docstrings for all public APIs</li> <li>Enhanced test coverage</li> </ul>"},{"location":"resources/changelog/#100-2024","title":"[1.0.0] - 2024","text":""},{"location":"resources/changelog/#added_4","title":"Added","text":"<ul> <li>Initial stable release</li> <li><code>AAPLZGraph</code> for amino acid sequences</li> <li><code>NDPLZGraph</code> for nucleotide sequences</li> <li><code>NaiveLZGraph</code> for non-positional analysis</li> <li>K-diversity metrics (K100, K500, K1000, K5000)</li> <li>Entropy and perplexity functions</li> <li>Jensen-Shannon divergence</li> <li>Visualization functions</li> <li>LZBOW vectorizer</li> <li>NodeEdgeSaturationProbe</li> </ul>"},{"location":"resources/changelog/#version-history","title":"Version History","text":"<p>For the complete version history, see the GitHub Releases page.</p>"},{"location":"resources/changelog/#migration-guides","title":"Migration Guides","text":""},{"location":"resources/changelog/#upgrading-to-21x","title":"Upgrading to 2.1.x","text":"<p>No breaking changes from 2.0. New information-theoretic metrics are additive.</p>"},{"location":"resources/changelog/#upgrading-from-1x-to-20","title":"Upgrading from 1.x to 2.0","text":"<ul> <li>All internal module paths changed to snake_case (e.g., <code>LZGraphs.graphs.amino_acid_positional</code>)</li> <li>Edge data now uses <code>EdgeData</code> objects: access via <code>graph[a][b]['data'].weight</code></li> <li>Public class/function names unchanged \u2014 imports like <code>from LZGraphs import AAPLZGraph</code> still work</li> </ul>"},{"location":"resources/changelog/#upgrading-from-pre-10","title":"Upgrading from Pre-1.0","text":"<p>If upgrading from early development versions:</p> <ol> <li>Update import statements to use new module structure</li> <li>Use <code>AAPLZGraph</code> instead of deprecated class names</li> <li>Update column names to <code>cdr3_amino_acid</code> / <code>cdr3_rearrangement</code></li> </ol>"},{"location":"resources/citation/","title":"Citation","text":"<p>If you use LZGraphs in your research, please cite our work.</p>"},{"location":"resources/citation/#citing-lzgraphs","title":"Citing LZGraphs","text":""},{"location":"resources/citation/#bibtex","title":"BibTeX","text":"<pre><code>@article{lzgraphs2024,\n  title={LZGraphs: A Novel Approach for T-Cell Receptor Repertoire Analysis\n         Using Lempel-Ziv Compression-Based Graph Representations},\n  author={Konstantinovsky, Thomas and others},\n  journal={...},\n  year={2024},\n  doi={...}\n}\n</code></pre>"},{"location":"resources/citation/#apa-format","title":"APA Format","text":"<p>Konstantinovsky, T., et al. (2024). LZGraphs: A Novel Approach for T-Cell Receptor Repertoire Analysis Using Lempel-Ziv Compression-Based Graph Representations. Journal Name.</p>"},{"location":"resources/citation/#chicago-format","title":"Chicago Format","text":"<p>Konstantinovsky, Thomas, et al. \"LZGraphs: A Novel Approach for T-Cell Receptor Repertoire Analysis Using Lempel-Ziv Compression-Based Graph Representations.\" Journal Name (2024).</p>"},{"location":"resources/citation/#citing-specific-features","title":"Citing Specific Features","text":""},{"location":"resources/citation/#k1000-diversity-index","title":"K1000 Diversity Index","text":"<p>If you specifically use the K1000 diversity metric:</p> <pre><code>@article{lzgraphs2024,\n  title={LZGraphs: A Novel Approach for T-Cell Receptor Repertoire Analysis},\n  author={Konstantinovsky, Thomas and others},\n  note={K1000 diversity metric for repertoire characterization},\n  year={2024}\n}\n</code></pre>"},{"location":"resources/citation/#lzcentrality","title":"LZCentrality","text":"<p>For the LZCentrality sequence centrality measure:</p> <pre><code>@article{lzgraphs2024,\n  title={LZGraphs: A Novel Approach for T-Cell Receptor Repertoire Analysis},\n  author={Konstantinovsky, Thomas and others},\n  note={LZCentrality for sequence centrality analysis},\n  year={2024}\n}\n</code></pre>"},{"location":"resources/citation/#software-citation","title":"Software Citation","text":"<p>For citing the software itself:</p> <pre><code>@software{lzgraphs_software,\n  author = {Konstantinovsky, Thomas},\n  title = {LZGraphs: LZ76-Based Graphs for TCR Repertoire Analysis},\n  url = {https://github.com/MuteJester/LZGraphs},\n  version = {1.1.1},\n  year = {2024}\n}\n</code></pre>"},{"location":"resources/citation/#related-publications","title":"Related Publications","text":""},{"location":"resources/citation/#foundational-work","title":"Foundational Work","text":"<ul> <li>Lempel, A., &amp; Ziv, J. (1976). On the complexity of finite sequences. IEEE Transactions on Information Theory.</li> </ul>"},{"location":"resources/citation/#tcr-repertoire-analysis","title":"TCR Repertoire Analysis","text":"<ul> <li>[Related immunology papers using similar approaches]</li> </ul>"},{"location":"resources/citation/#acknowledgments","title":"Acknowledgments","text":"<p>LZGraphs was developed at [Institution/Lab Name].</p>"},{"location":"resources/citation/#contributors","title":"Contributors","text":"<ul> <li>Thomas Konstantinovsky - Lead developer</li> </ul>"},{"location":"resources/citation/#funding","title":"Funding","text":"<p>[Funding acknowledgments if applicable]</p>"},{"location":"resources/citation/#license","title":"License","text":"<p>LZGraphs is released under the MIT License. See the LICENSE file for details.</p>"},{"location":"resources/citation/#contact","title":"Contact","text":"<p>For questions about citing LZGraphs:</p> <ul> <li>Email: thomaskon90@gmail.com</li> <li>GitHub: MuteJester/LZGraphs</li> </ul>"},{"location":"resources/faq/","title":"Frequently Asked Questions","text":"<p>Common questions about using LZGraphs.</p>"},{"location":"resources/faq/#general","title":"General","text":""},{"location":"resources/faq/#which-graph-type-should-i-use","title":"Which graph type should I use?","text":"<p>Short answer:</p> <ul> <li>Amino acid sequences \u2192 <code>AAPLZGraph</code></li> <li>Nucleotide sequences \u2192 <code>NDPLZGraph</code></li> <li>ML feature extraction \u2192 <code>NaiveLZGraph</code></li> </ul> <p>Detailed guide: See Concepts: Graph Types</p>"},{"location":"resources/faq/#how-much-data-do-i-need","title":"How much data do I need?","text":"<p>LZGraphs works with any dataset size, but:</p> <ul> <li>Minimum: ~100 sequences for basic analysis</li> <li>Recommended: 1,000+ sequences for reliable diversity metrics</li> <li>K1000 requirement: At least 1,000 unique sequences</li> </ul> <p>For small datasets, consider <code>K100_Diversity</code> instead of <code>K1000_Diversity</code>.</p>"},{"location":"resources/faq/#can-i-use-lzgraphs-for-non-tcr-sequences","title":"Can I use LZGraphs for non-TCR sequences?","text":"<p>Yes! LZGraphs works with any string sequences. The library is optimized for TCR/CDR3 analysis, but the core algorithms are sequence-agnostic.</p> <pre><code># Works with any strings\nfrom LZGraphs import NaiveLZGraph\nfrom LZGraphs.utilities import generate_kmer_dictionary\n\ndictionary = generate_kmer_dictionary(6)\ngraph = NaiveLZGraph(my_custom_sequences, dictionary)\n</code></pre>"},{"location":"resources/faq/#probability-and-analysis","title":"Probability and Analysis","text":""},{"location":"resources/faq/#why-is-my-sequence-probability-zero","title":"Why is my sequence probability zero?","text":"<p>A probability of zero means the sequence contains patterns or transitions not observed in the training data:</p> <pre><code># Check for missing nodes\nencoded = AAPLZGraph.encode_sequence(sequence)\nfor node in encoded:\n    if not graph.graph.has_node(node):\n        print(f\"Missing node: {node}\")\n\n# Check for missing edges\nfor i in range(len(encoded) - 1):\n    if not graph.graph.has_edge(encoded[i], encoded[i+1]):\n        print(f\"Missing edge: {encoded[i]} -&gt; {encoded[i+1]}\")\n</code></pre>"},{"location":"resources/faq/#how-do-i-interpret-k1000","title":"How do I interpret K1000?","text":"<p>K1000 measures the number of unique LZ76 patterns in a sample of 1,000 sequences:</p> <ul> <li>Higher values = more diverse repertoire</li> <li>Lower values = more repetitive patterns</li> <li>Typical range = 500-3000 depending on repertoire</li> </ul>"},{"location":"resources/faq/#whats-the-difference-between-perplexity-and-probability","title":"What's the difference between perplexity and probability?","text":"<ul> <li>Probability (Pgen): How likely is this exact sequence?</li> <li>Perplexity: How \"surprised\" is the model by this sequence?</li> </ul> <p>Lower perplexity = sequence fits the model better.</p>"},{"location":"resources/faq/#technical-issues","title":"Technical Issues","text":""},{"location":"resources/faq/#modulenotfounderror-no-module-named-lzgraphs","title":"\"ModuleNotFoundError: No module named 'LZGraphs'\"","text":"<p>Ensure LZGraphs is installed:</p> <pre><code>pip install LZGraphs\n</code></pre> <p>Or check you're in the correct Python environment.</p>"},{"location":"resources/faq/#missingcolumnerror-required-column-cdr3_amino_acid-not-found","title":"\"MissingColumnError: Required column 'cdr3_amino_acid' not found\"","text":"<p>Your DataFrame needs the correct column names:</p> <ul> <li><code>cdr3_amino_acid</code> for <code>AAPLZGraph</code></li> <li><code>cdr3_rearrangement</code> for <code>NDPLZGraph</code></li> </ul> <pre><code># Check your columns\nprint(data.columns.tolist())\n\n# Rename if needed\ndata = data.rename(columns={'CDR3': 'cdr3_amino_acid'})\n</code></pre>"},{"location":"resources/faq/#nogenedataerror-this-operation-requires-gene-annotation-data","title":"\"NoGeneDataError: This operation requires gene annotation data\"","text":"<p>Some functions require V/J gene columns:</p> <pre><code># Build with gene data\ndata = pd.DataFrame({\n    'cdr3_amino_acid': sequences,\n    'V': v_genes,  # Required for genomic functions\n    'J': j_genes\n})\ngraph = AAPLZGraph(data)\n</code></pre>"},{"location":"resources/faq/#memory-issues-with-large-repertoires","title":"Memory issues with large repertoires","text":"<p>For very large datasets:</p> <ol> <li> <p>Subsample first: <pre><code>data_sample = data.sample(n=50000)\ngraph = AAPLZGraph(data_sample)\n</code></pre></p> </li> <li> <p>Use NaiveLZGraph: Smaller graphs with fixed dictionary</p> </li> <li> <p>Save and reload: <pre><code>graph.save(\"large_graph.pkl\")\n# Load when needed\ngraph = AAPLZGraph.load(\"large_graph.pkl\")\n</code></pre></p> </li> </ol>"},{"location":"resources/faq/#performance","title":"Performance","text":""},{"location":"resources/faq/#how-can-i-speed-up-graph-construction","title":"How can I speed up graph construction?","text":"<ul> <li>Use <code>verbose=False</code> to skip progress output</li> <li>Subsample large datasets for exploration</li> <li>Build once and save for repeated use</li> </ul>"},{"location":"resources/faq/#how-long-should-k1000-take","title":"How long should K1000 take?","text":"<p>With 30 draws on 10,000 sequences: ~10-30 seconds</p> <p>Increase <code>draws</code> for more accurate results (slower).</p>"},{"location":"resources/faq/#best-practices","title":"Best Practices","text":""},{"location":"resources/faq/#should-i-normalize-sequence-lengths","title":"Should I normalize sequence lengths?","text":"<p>No, LZGraphs handles variable-length sequences naturally. The length distribution is captured in <code>graph.lengths</code>.</p>"},{"location":"resources/faq/#how-do-i-compare-repertoires-of-different-sizes","title":"How do I compare repertoires of different sizes?","text":"<p>Use normalized metrics:</p> <ul> <li><code>normalized_graph_entropy()</code> - Entropy normalized by graph size</li> <li><code>jensen_shannon_divergence()</code> - Inherently normalized (0 to 1)</li> <li>K-diversity with same sample size</li> </ul>"},{"location":"resources/faq/#how-do-i-handle-special-characters","title":"How do I handle special characters?","text":"<p>Remove or replace them before building the graph:</p> <pre><code># Remove non-standard amino acids\ndata = data[data['cdr3_amino_acid'].str.match(r'^[ACDEFGHIKLMNPQRSTVWY]+$')]\n</code></pre>"},{"location":"resources/faq/#still-have-questions","title":"Still Have Questions?","text":"<ul> <li>Open an issue on GitHub</li> <li>Email: thomaskon90@gmail.com</li> <li>Check the API Reference for detailed documentation</li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Welcome to the LZGraphs tutorials. These step-by-step guides will help you master TCR repertoire analysis using LZGraphs.</p>"},{"location":"tutorials/#learning-path","title":"Learning Path","text":"<p>We recommend following these tutorials in order:</p>"},{"location":"tutorials/#1-graph-construction","title":"1. Graph Construction","text":"<p>Beginner \u00b7 15 minutes</p> <p>Learn to build AAPLZGraph, NDPLZGraph, and NaiveLZGraph from your data.</p>"},{"location":"tutorials/#2-sequence-analysis","title":"2. Sequence Analysis","text":"<p>Beginner \u00b7 20 minutes</p> <p>Calculate sequence probabilities, explore graph structure, and generate new sequences.</p>"},{"location":"tutorials/#3-diversity-metrics","title":"3. Diversity Metrics","text":"<p>Intermediate \u00b7 15 minutes</p> <p>Measure repertoire diversity using K1000, LZCentrality, and entropy metrics.</p>"},{"location":"tutorials/#4-visualization","title":"4. Visualization","text":"<p>Intermediate \u00b7 20 minutes</p> <p>Create publication-ready plots for sequence and repertoire analysis.</p>"},{"location":"tutorials/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li> Installed LZGraphs (Installation Guide)</li> <li> Basic Python and pandas knowledge</li> <li> Sample data to work with (or use our example datasets)</li> </ul>"},{"location":"tutorials/#sample-data","title":"Sample Data","text":"<p>All tutorials use example data included with LZGraphs:</p> <pre><code>import pandas as pd\n\n# Load example TCR repertoire\ndata = pd.read_csv(\"Examples/ExampleData1.csv\")\nprint(data.head())\n</code></pre>"},{"location":"tutorials/#quick-reference","title":"Quick Reference","text":"Tutorial Topics Covered Graph Construction AAPLZGraph, NDPLZGraph, NaiveLZGraph, gene annotation Sequence Analysis walk_probability, random_walk, encode_sequence, clean_node Diversity Metrics K1000_Diversity, LZCentrality, node_entropy, edge_entropy Visualization Ancestors/descendants plots, path variability, genomic heatmaps"},{"location":"tutorials/#next-steps","title":"Next Steps","text":"<p>After completing the tutorials:</p> <ul> <li>Explore Concepts for deeper understanding</li> <li>Check How-To Guides for specific tasks</li> <li>Browse Examples for complete notebooks</li> </ul>"},{"location":"tutorials/diversity-metrics/","title":"Diversity Metrics","text":"<p>This tutorial covers measuring repertoire diversity using LZGraphs' novel metrics.</p>"},{"location":"tutorials/diversity-metrics/#overview","title":"Overview","text":"<p>LZGraphs provides several approaches to quantify repertoire diversity:</p> Metric What it Measures Use Case K1000 Unique patterns in 1000 sequences Overall diversity LZCentrality Sequence position in repertoire Sequence rarity Entropy Information content Graph complexity Perplexity Prediction uncertainty Model quality Transition Predictability Determinism of transitions Repertoire constraint Graph Compression Ratio Path sharing efficiency Structural compression Path Entropy Rate Information per step Per-sequence complexity Transition JSD Transition structure divergence Repertoire comparison TMIP Position-specific mutual information Recombination profiling"},{"location":"tutorials/diversity-metrics/#k-diversity-metrics","title":"K-Diversity Metrics","text":"<p>K-diversity measures how many unique LZ76 patterns appear when sampling K sequences.</p>"},{"location":"tutorials/diversity-metrics/#k1000-diversity","title":"K1000 Diversity","text":"<p>The most common diversity measure:</p> <pre><code>from LZGraphs import K1000_Diversity, AAPLZGraph\nimport pandas as pd\n\n# Load data\ndata = pd.read_csv(\"Examples/ExampleData1.csv\")\nsequences = data['cdr3_amino_acid'].tolist()\n\n# Calculate K1000\nk1000 = K1000_Diversity(\n    sequences,\n    encoding_function=AAPLZGraph.encode_sequence,\n    draws=30  # Number of resampling rounds\n)\nprint(f\"K1000 Diversity: {k1000:.1f}\")\n</code></pre> <p>Interpretation</p> <p>Higher K1000 values indicate more diverse repertoires. A repertoire with many unique patterns will have a higher K1000 than one dominated by repeated motifs.</p>"},{"location":"tutorials/diversity-metrics/#other-k-diversity-variants","title":"Other K-Diversity Variants","text":"<pre><code>from LZGraphs import K100_Diversity, K500_Diversity, K5000_Diversity\n\n# For smaller repertoires\nk100 = K100_Diversity(sequences, AAPLZGraph.encode_sequence)\n\n# For larger repertoires\nk5000 = K5000_Diversity(sequences, AAPLZGraph.encode_sequence)\n\nprint(f\"K100:  {k100:.1f}\")\nprint(f\"K5000: {k5000:.1f}\")\n</code></pre>"},{"location":"tutorials/diversity-metrics/#adaptive-k-diversity","title":"Adaptive K-Diversity","text":"<p>Automatically select K based on repertoire size:</p> <pre><code>from LZGraphs import adaptive_K_Diversity\n\nk_adaptive = adaptive_K_Diversity(sequences, AAPLZGraph.encode_sequence)\nprint(f\"Adaptive K-Diversity: {k_adaptive:.1f}\")\n</code></pre>"},{"location":"tutorials/diversity-metrics/#k-diversity-with-statistics","title":"K-Diversity with Statistics","text":"<p>Get confidence intervals:</p> <pre><code>from LZGraphs import K_Diversity\n\nresult = K_Diversity(\n    sequences,\n    encoding_function=AAPLZGraph.encode_sequence,\n    sample_size=1000,\n    draws=100,\n    return_stats=True\n)\n\nprint(f\"Mean: {result['mean']:.1f}\")\nprint(f\"Std:  {result['std']:.2f}\")\nprint(f\"CI:   [{result['ci_low']:.1f}, {result['ci_high']:.1f}]\")\n</code></pre>"},{"location":"tutorials/diversity-metrics/#lzcentrality","title":"LZCentrality","text":"<p>LZCentrality measures how central a sequence is within the repertoire structure.</p> <pre><code>from LZGraphs import LZCentrality, AAPLZGraph\nimport pandas as pd\n\n# Build graph\ndata = pd.read_csv(\"Examples/ExampleData1.csv\")\ngraph = AAPLZGraph(data, verbose=False)\n\n# Calculate centrality for a sequence\nsequence = \"CASSLEPSGGTDTQYF\"\ncentrality = LZCentrality(graph, sequence)\nprint(f\"LZCentrality of {sequence}: {centrality:.4f}\")\n</code></pre>"},{"location":"tutorials/diversity-metrics/#comparing-sequence-centrality","title":"Comparing Sequence Centrality","text":"<pre><code>sequences = [\n    \"CASSLEPSGGTDTQYF\",\n    \"CASSLGQGSTEAFF\",\n    \"CASSXYZRARESEQ\"\n]\n\nfor seq in sequences:\n    try:\n        cent = LZCentrality(graph, seq)\n        print(f\"{seq}: {cent:.4f}\")\n    except:\n        print(f\"{seq}: Not in graph\")\n</code></pre> <p>LZCentrality interpretation</p> <ul> <li>Higher values = more central (common patterns)</li> <li>Lower values = more peripheral (rare patterns)</li> <li>Zero = sequence not representable in graph</li> </ul>"},{"location":"tutorials/diversity-metrics/#entropy-metrics","title":"Entropy Metrics","text":"<p>Entropy quantifies the information content of your graph.</p>"},{"location":"tutorials/diversity-metrics/#node-entropy","title":"Node Entropy","text":"<p>Measures uncertainty in node (subpattern) distribution:</p> <pre><code>from LZGraphs import node_entropy\n\nh_nodes = node_entropy(graph)\nprint(f\"Node entropy: {h_nodes:.2f} bits\")\n</code></pre>"},{"location":"tutorials/diversity-metrics/#edge-entropy","title":"Edge Entropy","text":"<p>Measures uncertainty in transitions:</p> <pre><code>from LZGraphs import edge_entropy\n\nh_edges = edge_entropy(graph)\nprint(f\"Edge entropy: {h_edges:.2f} bits\")\n</code></pre>"},{"location":"tutorials/diversity-metrics/#graph-entropy","title":"Graph Entropy","text":"<p>Combined measure of graph complexity:</p> <pre><code>from LZGraphs import graph_entropy, normalized_graph_entropy\n\nh_graph = graph_entropy(graph)\nh_norm = normalized_graph_entropy(graph)\n\nprint(f\"Graph entropy: {h_graph:.2f} bits\")\nprint(f\"Normalized:    {h_norm:.4f}\")\n</code></pre>"},{"location":"tutorials/diversity-metrics/#perplexity","title":"Perplexity","text":"<p>Perplexity measures how \"surprised\" the model is by sequences.</p>"},{"location":"tutorials/diversity-metrics/#sequence-perplexity","title":"Sequence Perplexity","text":"<pre><code>from LZGraphs import sequence_perplexity\n\nsequence = \"CASSLEPSGGTDTQYF\"\nperp = sequence_perplexity(graph, sequence)\nprint(f\"Perplexity of {sequence}: {perp:.2f}\")\n</code></pre> <p>Perplexity interpretation</p> <ul> <li>Lower perplexity = sequence fits model well</li> <li>Higher perplexity = sequence is unexpected</li> </ul>"},{"location":"tutorials/diversity-metrics/#repertoire-perplexity","title":"Repertoire Perplexity","text":"<p>Average perplexity across all sequences:</p> <pre><code>from LZGraphs import repertoire_perplexity\n\nsequences = data['cdr3_amino_acid'].tolist()\navg_perp = repertoire_perplexity(graph, sequences)\nprint(f\"Average repertoire perplexity: {avg_perp:.2f}\")\n</code></pre>"},{"location":"tutorials/diversity-metrics/#comparing-repertoires","title":"Comparing Repertoires","text":""},{"location":"tutorials/diversity-metrics/#jensen-shannon-divergence","title":"Jensen-Shannon Divergence","text":"<p>Measure similarity between two repertoires:</p> <pre><code>from LZGraphs import jensen_shannon_divergence\n\n# Build two graphs from different repertoires\ndata1 = pd.read_csv(\"Examples/ExampleData1.csv\")\ndata2 = pd.read_csv(\"Examples/ExampleData2.csv\")\n\ngraph1 = AAPLZGraph(data1, verbose=False)\ngraph2 = AAPLZGraph(data2, verbose=False)\n\n# Calculate JS divergence\njsd = jensen_shannon_divergence(graph1, graph2)\nprint(f\"JS Divergence: {jsd:.4f}\")\n</code></pre> <p>JS Divergence interpretation</p> <ul> <li>0 = identical distributions</li> <li>1 = completely different</li> <li>Symmetric: JSD(A,B) = JSD(B,A)</li> </ul>"},{"location":"tutorials/diversity-metrics/#mutual-information-for-genes","title":"Mutual Information for Genes","text":"<p>Measure association between genes and subpatterns:</p> <pre><code>from LZGraphs import mutual_information_genes\n\nmi_v = mutual_information_genes(graph, gene_type='V')\nmi_j = mutual_information_genes(graph, gene_type='J')\n\nprint(f\"MI (V genes): {mi_v:.4f}\")\nprint(f\"MI (J genes): {mi_j:.4f}\")\n</code></pre>"},{"location":"tutorials/diversity-metrics/#saturation-analysis","title":"Saturation Analysis","text":"<p>Analyze how diversity grows with sample size.</p> <pre><code>from LZGraphs import NodeEdgeSaturationProbe\n\n# Create saturation curve\nprobe = NodeEdgeSaturationProbe()\ncurve = probe.saturation_curve(\n    sequences,\n    encoding_function=AAPLZGraph.encode_sequence,\n    steps=50\n)\n\nprint(curve.head())\n</code></pre>"},{"location":"tutorials/diversity-metrics/#key-saturation-metrics","title":"Key Saturation Metrics","text":"<pre><code># Half-saturation point (sequences needed for 50% of nodes)\nhalf_sat = probe.half_saturation_point(curve)\nprint(f\"Half-saturation: {half_sat} sequences\")\n\n# Area under saturation curve\nausc = probe.area_under_curve(curve)\nprint(f\"AUSC: {ausc:.2f}\")\n</code></pre>"},{"location":"tutorials/diversity-metrics/#complete-example","title":"Complete Example","text":"<p>Compare diversity between two repertoires:</p> <pre><code>from LZGraphs import (\n    AAPLZGraph, K1000_Diversity,\n    node_entropy, jensen_shannon_divergence\n)\nimport pandas as pd\n\n# Load two repertoires\nrep1 = pd.read_csv(\"Examples/ExampleData1.csv\")\nrep2 = pd.read_csv(\"Examples/ExampleData2.csv\")\n\n# Build graphs\ng1 = AAPLZGraph(rep1, verbose=False)\ng2 = AAPLZGraph(rep2, verbose=False)\n\n# Compare metrics\nseq1 = rep1['cdr3_amino_acid'].tolist()\nseq2 = rep2['cdr3_amino_acid'].tolist()\n\nprint(\"Repertoire 1 vs Repertoire 2\")\nprint(\"-\" * 40)\nprint(f\"K1000:    {K1000_Diversity(seq1, AAPLZGraph.encode_sequence):.0f} vs \"\n      f\"{K1000_Diversity(seq2, AAPLZGraph.encode_sequence):.0f}\")\nprint(f\"Entropy:  {node_entropy(g1):.2f} vs {node_entropy(g2):.2f}\")\nprint(f\"JS Div:   {jensen_shannon_divergence(g1, g2):.4f}\")\n</code></pre>"},{"location":"tutorials/diversity-metrics/#information-theoretic-metrics","title":"Information-Theoretic Metrics","text":"<p>LZGraphs v2.1 introduces a suite of information-theoretic metrics that capture the structural complexity of immune repertoires at the transition level.</p>"},{"location":"tutorials/diversity-metrics/#transition-predictability","title":"Transition Predictability","text":"<p>Measures how deterministic the graph transitions are. Stable across sample sizes, making it an intrinsic property of the repertoire.</p> <pre><code>from LZGraphs import transition_predictability\n\ntp = transition_predictability(graph)\nprint(f\"Transition predictability: {tp:.3f}\")\n# AAPLZGraph: ~0.60 (healthy repertoire)\n# Higher = more restricted, Lower = more diverse\n</code></pre> <p>Clinical interpretation</p> <ul> <li>High TP (~0.8+): Restricted repertoire, possible clonal expansion</li> <li>Normal TP (~0.55-0.65): Healthy polyclonal repertoire</li> <li>Low TP (~0.3-0.4): Highly diverse or aberrant transition patterns</li> </ul>"},{"location":"tutorials/diversity-metrics/#graph-compression-ratio","title":"Graph Compression Ratio","text":"<p>Measures how efficiently sequences share structural paths through the graph.</p> <pre><code>from LZGraphs import graph_compression_ratio\n\ngcr = graph_compression_ratio(graph)\nprint(f\"Compression ratio: {gcr:.3f}\")\n# Lower = more path sharing\n</code></pre>"},{"location":"tutorials/diversity-metrics/#path-entropy-rate","title":"Path Entropy Rate","text":"<p>Average information content per subpattern step across actual sequences.</p> <pre><code>from LZGraphs import path_entropy_rate\n\nsequences = data['cdr3_amino_acid'].tolist()\nh = path_entropy_rate(graph, sequences)\nprint(f\"Entropy rate: {h:.3f} bits/step\")\n</code></pre>"},{"location":"tutorials/diversity-metrics/#transition-mutual-information-profile-tmip","title":"Transition Mutual Information Profile (TMIP)","text":"<p>Reveals where along the CDR3 sequence transitions are most/least predictable. Only works with positional graphs (AAPLZGraph, NDPLZGraph).</p> <pre><code>from LZGraphs import transition_mutual_information_profile\n\ntmip = transition_mutual_information_profile(graph)\nfor pos in sorted(tmip):\n    print(f\"Position {pos}: MI = {tmip[pos]:.3f} bits\")\n</code></pre> <p>Biological insight</p> <ul> <li>High MI positions: Germline-encoded boundaries (V-gene exit, J-gene entry)</li> <li>Low MI positions: Junctional diversity region (N-insertions)</li> </ul>"},{"location":"tutorials/diversity-metrics/#comparing-repertoires-at-the-transition-level","title":"Comparing Repertoires at the Transition Level","text":"<pre><code>from LZGraphs import transition_jsd, compare_repertoires\n\n# Symmetric, bounded [0, 1]\njsd_t = transition_jsd(graph1, graph2)\nprint(f\"Transition JSD: {jsd_t:.4f}\")\n\n# All-in-one comparison\nresult = compare_repertoires(graph1, graph2)\nprint(result)\n</code></pre> <p>For a complete walkthrough of all information-theoretic metrics with visualizations, see the Information-Theoretic Analysis notebook.</p>"},{"location":"tutorials/diversity-metrics/#next-steps","title":"Next Steps","text":"<ul> <li>Visualization Tutorial - Plot diversity metrics</li> <li>Concepts: Diversity Indices - Theory behind metrics</li> <li>How-To: Compare Repertoires - Detailed comparison workflows</li> </ul>"},{"location":"tutorials/graph-construction/","title":"Graph Construction","text":"<p>This tutorial covers building the three types of LZGraphs from TCR repertoire data.</p>"},{"location":"tutorials/graph-construction/#overview","title":"Overview","text":"<p>LZGraphs transforms sequences into directed graph representations where:</p> <ul> <li>Nodes represent subpatterns from LZ76 decomposition</li> <li>Edges represent observed transitions between subpatterns</li> <li>Edge weights encode transition probabilities</li> </ul>"},{"location":"tutorials/graph-construction/#amino-acid-positional-graph-aaplzgraph","title":"Amino Acid Positional Graph (AAPLZGraph)","text":"<p>The <code>AAPLZGraph</code> is optimized for amino acid CDR3 sequences with positional encoding.</p>"},{"location":"tutorials/graph-construction/#basic-construction","title":"Basic Construction","text":"<pre><code>from LZGraphs import AAPLZGraph\nimport pandas as pd\n\n# Load your data\ndata = pd.read_csv(\"Examples/ExampleData1.csv\")\n\n# Build the graph\ngraph = AAPLZGraph(data, verbose=True)\n</code></pre> <p>Expected output: <pre><code>Gene Information Loaded.. |  0.01  Seconds\nGraph Constructed.. |  0.94  Seconds\nGraph Metadata Derived.. |  0.94  Seconds\nIndividual Subpattern Empirical Probability Derived.. |  0.98  Seconds\nGraph Edge Weight Normalized.. |  1.0  Seconds\nGraph Edge Gene Weights Normalized.. |  1.13  Seconds\nTerminal State Map Derived.. |  1.2  Seconds\nLZGraph Created Successfully.. |  1.37  Seconds\n</code></pre></p>"},{"location":"tutorials/graph-construction/#required-data-format","title":"Required Data Format","text":"<p>Your DataFrame must have a <code>cdr3_amino_acid</code> column:</p> cdr3_amino_acid V J CASSLEPSGGTDTQYF TRBV16-1*01 TRBJ1-2*01 CASSDTSGGTDTQYF TRBV1-1*01 TRBJ1-5*01 <p>V and J columns</p> <p>V and J gene annotation columns are optional but enable gene-aware features like <code>genomic_random_walk()</code>.</p>"},{"location":"tutorials/graph-construction/#exploring-graph-structure","title":"Exploring Graph Structure","text":"<pre><code># Get all nodes and edges\nnodes = list(graph.nodes)\nedges = list(graph.edges)\n\nprint(f\"Nodes: {len(nodes)}\")\nprint(f\"Edges: {len(edges)}\")\nprint(f\"First 10 nodes: {nodes[:10]}\")\nprint(f\"First 10 edges: {edges[:10]}\")\n</code></pre> <p>Output: <pre><code>Nodes: 1523\nEdges: 8492\nFirst 10 nodes: ['C_1', 'A_2', 'S_3', 'SQ_5', 'Q_6', 'G_7', 'R_8', 'D_9', 'T_10', 'QY_12']\nFirst 10 edges: [('C_1', 'A_2'), ('C_1', 'T_2'), ('C_1', 'V_2'), ...]\n</code></pre></p>"},{"location":"tutorials/graph-construction/#length-distribution","title":"Length Distribution","text":"<pre><code># Sequence length distribution\nprint(graph.lengths)\n</code></pre> <p>Output: <pre><code>{13: 2973, 15: 5075, 14: 4412, 16: 2862, 12: 1147, ...}\n</code></pre></p>"},{"location":"tutorials/graph-construction/#initial-and-terminal-states","title":"Initial and Terminal States","text":"<pre><code># Initial states (first subpattern of sequences)\nprint(\"Initial states:\")\nprint(graph.initial_states)\n\n# Terminal states (last subpattern of sequences)\nprint(\"\\nTerminal states (top 5):\")\nprint(graph.terminal_states.head())\n</code></pre>"},{"location":"tutorials/graph-construction/#vj-gene-distributions","title":"V/J Gene Distributions","text":"<pre><code># Marginal V gene probabilities\nprint(\"V gene distribution:\")\nprint(graph.marginal_vgenes)\n\n# Marginal J gene probabilities\nprint(\"\\nJ gene distribution:\")\nprint(graph.marginal_jgenes)\n</code></pre>"},{"location":"tutorials/graph-construction/#nucleotide-double-positional-graph-ndplzgraph","title":"Nucleotide Double Positional Graph (NDPLZGraph)","text":"<p>The <code>NDPLZGraph</code> is designed for nucleotide sequences with double positional encoding.</p>"},{"location":"tutorials/graph-construction/#construction","title":"Construction","text":"<pre><code>from LZGraphs import NDPLZGraph\n\n# Data must have 'cdr3_rearrangement' column\ndata = pd.read_csv(\"nucleotide_repertoire.csv\")\ngraph = NDPLZGraph(data, verbose=True)\n</code></pre>"},{"location":"tutorials/graph-construction/#data-format","title":"Data Format","text":"cdr3_rearrangement V J TGTGCCAGCAGTTTAGAG... TRBV16-1*01 TRBJ1-2*01"},{"location":"tutorials/graph-construction/#encoding-example","title":"Encoding Example","text":"<pre><code>sequence = \"TGTGCCAGC\"\nencoded = NDPLZGraph.encode_sequence(sequence)\nprint(encoded)\n# ['T_1_1', 'G_2_2', 'T_3_3', 'G_4_4', 'C_5_5', 'C_6_6', 'A_7_7', 'G_8_8', 'C_9_9']\n</code></pre> <p>The double position encoding (<code>_start_end</code>) captures subpattern boundaries precisely.</p>"},{"location":"tutorials/graph-construction/#naive-lzgraph","title":"Naive LZGraph","text":"<p>The <code>NaiveLZGraph</code> uses pure LZ76 decomposition without positional encoding, making it ideal for cross-repertoire comparisons.</p>"},{"location":"tutorials/graph-construction/#construction_1","title":"Construction","text":"<pre><code>from LZGraphs import NaiveLZGraph\nfrom LZGraphs.utilities import generate_kmer_dictionary\n\n# Generate a shared dictionary\ndictionary = generate_kmer_dictionary(6)\nprint(f\"Dictionary size: {len(dictionary)}\")  # 5460 patterns\n\n# Build graph from sequence list\nsequences = data['cdr3_rearrangement'].tolist()\ngraph = NaiveLZGraph(sequences, dictionary, verbose=True)\n</code></pre>"},{"location":"tutorials/graph-construction/#why-use-a-shared-dictionary","title":"Why Use a Shared Dictionary?","text":"<p>Using the same dictionary across multiple repertoires ensures:</p> <ol> <li>Consistent feature dimensions for machine learning</li> <li>Comparable graphs for cross-repertoire analysis</li> <li>Fixed node set regardless of repertoire content</li> </ol>"},{"location":"tutorials/graph-construction/#feature-extraction","title":"Feature Extraction","text":"<pre><code># Extract eigenvector centrality features\nfeatures = graph.eigenvector_centrality()\nprint(f\"Feature vector length: {len(features)}\")\nprint(pd.Series(features).head(10))\n</code></pre> <p>Output: <pre><code>A         3.009520e-01\nT         1.183398e-01\nG         1.186366e-01\nC         2.461758e-01\nAA        1.252643e-01\n...\n</code></pre></p>"},{"location":"tutorials/graph-construction/#construction-options","title":"Construction Options","text":""},{"location":"tutorials/graph-construction/#verbose-mode","title":"Verbose Mode","text":"<p>Control output verbosity:</p> <pre><code># Silent construction\ngraph = AAPLZGraph(data, verbose=False)\n\n# With progress output\ngraph = AAPLZGraph(data, verbose=True)\n</code></pre>"},{"location":"tutorials/graph-construction/#graph-summary","title":"Graph Summary","text":"<p>Get a quick overview of your graph:</p> <pre><code>from LZGraphs import graph_summary\n\nsummary = graph_summary(graph)\nprint(summary)\n</code></pre>"},{"location":"tutorials/graph-construction/#saving-and-loading-graphs","title":"Saving and Loading Graphs","text":"<p>Persist your graphs for later use:</p> <pre><code># Save\ngraph.save(\"my_graph.pkl\")\n\n# Load\nloaded_graph = AAPLZGraph.load(\"my_graph.pkl\")\n</code></pre> <p>See How-To: Serialization for more details.</p>"},{"location":"tutorials/graph-construction/#next-steps","title":"Next Steps","text":"<ul> <li>Sequence Analysis Tutorial - Work with your constructed graph</li> <li>Concepts: Graph Types - Deep dive into graph differences</li> <li>API: AAPLZGraph - Complete class reference</li> </ul>"},{"location":"tutorials/sequence-analysis/","title":"Sequence Analysis","text":"<p>This tutorial covers analyzing sequences using LZGraphs, including probability calculation, encoding, and sequence generation.</p>"},{"location":"tutorials/sequence-analysis/#prerequisites","title":"Prerequisites","text":"<p>Build a graph first:</p> <pre><code>import pandas as pd\nfrom LZGraphs import AAPLZGraph\n\ndata = pd.read_csv(\"Examples/ExampleData1.csv\")\ngraph = AAPLZGraph(data, verbose=True)\n</code></pre>"},{"location":"tutorials/sequence-analysis/#sequence-encoding","title":"Sequence Encoding","text":"<p>Before analyzing a sequence, you must encode it into the graph's format.</p>"},{"location":"tutorials/sequence-analysis/#encoding-with-aaplzgraph","title":"Encoding with AAPLZGraph","text":"<pre><code>sequence = \"CASRGERGDNEQFF\"\n\n# Encode the sequence\nencoded = AAPLZGraph.encode_sequence(sequence)\nprint(encoded)\n</code></pre> <p>Output: <pre><code>['C_1', 'A_2', 'S_3', 'R_4', 'G_5', 'E_6', 'RG_8', 'D_9', 'N_10', 'EQ_12', 'F_13', 'F_14']\n</code></pre></p> <p>Each node has the format <code>&lt;subpattern&gt;_&lt;position&gt;</code>.</p>"},{"location":"tutorials/sequence-analysis/#decoding-back-to-sequence","title":"Decoding Back to Sequence","text":"<pre><code># Clean each node to get the original subpattern\nclean_nodes = [AAPLZGraph.clean_node(node) for node in encoded]\nprint(clean_nodes)\n\n# Reconstruct the sequence\nreconstructed = ''.join(clean_nodes)\nprint(f\"Original:      {sequence}\")\nprint(f\"Reconstructed: {reconstructed}\")\n</code></pre>"},{"location":"tutorials/sequence-analysis/#calculating-sequence-probability-pgen","title":"Calculating Sequence Probability (Pgen)","text":"<p>The generation probability quantifies how likely a sequence is given the repertoire:</p>"},{"location":"tutorials/sequence-analysis/#basic-probability","title":"Basic Probability","text":"<pre><code>sequence = \"CASRGERGDNEQFF\"\nencoded = AAPLZGraph.encode_sequence(sequence)\n\npgen = graph.walk_probability(encoded)\nprint(f\"{sequence}: P(gen) = {pgen:.2e}\")\n</code></pre> <p>Output: <pre><code>CASRGERGDNEQFF: P(gen) = 6.69e-13\n</code></pre></p>"},{"location":"tutorials/sequence-analysis/#log-probability","title":"Log Probability","text":"<p>For very small probabilities, use log-space to avoid numerical underflow:</p> <pre><code>log_pgen = graph.walk_probability(encoded, use_log=True)\nprint(f\"log P(gen) = {log_pgen:.2f}\")\n</code></pre> <p>When to use log probability</p> <p>Use <code>use_log=True</code> when:</p> <ul> <li>Comparing many sequences</li> <li>Working with very rare sequences</li> <li>Performing numerical operations on probabilities</li> </ul>"},{"location":"tutorials/sequence-analysis/#handling-unknown-sequences","title":"Handling Unknown Sequences","text":"<p>If a sequence contains patterns not in the graph:</p> <pre><code>unknown_seq = \"CASSXYZABC\"  # XYZ unlikely in real repertoire\nencoded = AAPLZGraph.encode_sequence(unknown_seq)\n\npgen = graph.walk_probability(encoded, verbose=True)\nprint(f\"P(gen) = {pgen}\")  # Returns 0 if path doesn't exist\n</code></pre>"},{"location":"tutorials/sequence-analysis/#generating-new-sequences","title":"Generating New Sequences","text":"<p>Generate sequences that follow the statistical patterns of your repertoire.</p>"},{"location":"tutorials/sequence-analysis/#unsupervised-random-walk","title":"Unsupervised Random Walk","text":"<p>Generate without gene constraints:</p> <pre><code>walk = graph.random_walk()\nsequence = ''.join([AAPLZGraph.clean_node(node) for node in walk])\nprint(f\"Generated: {sequence}\")\n</code></pre>"},{"location":"tutorials/sequence-analysis/#gene-constrained-generation","title":"Gene-Constrained Generation","text":"<p>Generate sequences consistent with specific V/J genes:</p> <pre><code># Generate with random V/J selection\nwalk, v_gene, j_gene = graph.genomic_random_walk()\n\nsequence = ''.join([AAPLZGraph.clean_node(node) for node in walk])\nprint(f\"Sequence: {sequence}\")\nprint(f\"V gene: {v_gene}\")\nprint(f\"J gene: {j_gene}\")\n</code></pre> <p>Output: <pre><code>Sequence: CSATGGTGGELFF\nV gene: TRBV29-1*01\nJ gene: TRBJ2-5*01\n</code></pre></p>"},{"location":"tutorials/sequence-analysis/#generating-multiple-sequences","title":"Generating Multiple Sequences","text":"<pre><code>generated = []\nfor _ in range(100):\n    walk, v, j = graph.genomic_random_walk()\n    seq = ''.join([AAPLZGraph.clean_node(n) for n in walk])\n    generated.append({'sequence': seq, 'v_gene': v, 'j_gene': j})\n\ndf = pd.DataFrame(generated)\nprint(df.head())\n</code></pre>"},{"location":"tutorials/sequence-analysis/#exploring-graph-structure","title":"Exploring Graph Structure","text":""},{"location":"tutorials/sequence-analysis/#node-properties","title":"Node Properties","text":"<pre><code># Check if a node exists\nnode = \"C_1\"\nexists = graph.graph.has_node(node)\nprint(f\"Node {node} exists: {exists}\")\n\n# Get node successors (outgoing edges)\nsuccessors = list(graph.graph.successors(\"C_1\"))\nprint(f\"C_1 can transition to: {successors[:5]}...\")\n</code></pre>"},{"location":"tutorials/sequence-analysis/#edge-properties","title":"Edge Properties","text":"<pre><code># Check edge weight\nif graph.graph.has_edge(\"C_1\", \"A_2\"):\n    weight = graph.graph[\"C_1\"][\"A_2\"][\"weight\"]\n    print(f\"Edge C_1 -&gt; A_2 weight: {weight:.4f}\")\n</code></pre>"},{"location":"tutorials/sequence-analysis/#subpattern-probabilities","title":"Subpattern Probabilities","text":"<pre><code># Get probability of a subpattern at a position\nproba_df = graph.subpattern_individual_probability\nprint(proba_df.head())\n</code></pre>"},{"location":"tutorials/sequence-analysis/#working-with-terminal-states","title":"Working with Terminal States","text":"<p>Terminal states are the final subpatterns of sequences:</p> <pre><code># All terminal states with counts\nprint(graph.terminal_states.head(10))\n\n# Check if a node is terminal\nnode = \"F_15\"\nis_terminal = node in graph.terminal_states.index\nprint(f\"{node} is terminal: {is_terminal}\")\n</code></pre>"},{"location":"tutorials/sequence-analysis/#terminal-state-map","title":"Terminal State Map","text":"<p>Get terminal states reachable from any position:</p> <pre><code># Get terminal states for position 12\nterminals_at_12 = graph.terminal_states_map.get(12, {})\nprint(f\"Terminal states at position 12: {list(terminals_at_12.keys())[:5]}\")\n</code></pre>"},{"location":"tutorials/sequence-analysis/#practical-example-sequence-comparison","title":"Practical Example: Sequence Comparison","text":"<p>Compare sequences by their generation probability:</p> <pre><code>sequences = [\n    \"CASSLEPSGGTDTQYF\",  # Likely common\n    \"CASSLGQGSTEAFF\",    # Also common\n    \"CASSXYZABCDEFGH\",   # Likely rare/impossible\n]\n\nresults = []\nfor seq in sequences:\n    try:\n        encoded = AAPLZGraph.encode_sequence(seq)\n        pgen = graph.walk_probability(encoded, use_log=True)\n        results.append({'sequence': seq, 'log_pgen': pgen})\n    except Exception as e:\n        results.append({'sequence': seq, 'log_pgen': float('-inf')})\n\ndf = pd.DataFrame(results)\ndf = df.sort_values('log_pgen', ascending=False)\nprint(df)\n</code></pre>"},{"location":"tutorials/sequence-analysis/#next-steps","title":"Next Steps","text":"<ul> <li>Diversity Metrics Tutorial - Measure repertoire diversity</li> <li>Concepts: Probability Model - Understand how Pgen works</li> <li>How-To: Generate Sequences - Advanced generation techniques</li> </ul>"},{"location":"tutorials/visualization/","title":"Visualization","text":"<p>This tutorial covers creating publication-ready plots for TCR repertoire analysis.</p>"},{"location":"tutorials/visualization/#overview","title":"Overview","text":"<p>LZGraphs provides specialized visualization functions:</p> Function Purpose <code>draw_graph</code> Visualize graph structure <code>ancestors_descendants_curves_plot</code> Trace sequence path through graph <code>sequence_possible_paths_plot</code> Show branching at each position <code>sequence_genomic_node_variability_plot</code> V/J gene diversity per node <code>sequence_genomic_edges_variability_plot</code> V/J gene diversity per edge"},{"location":"tutorials/visualization/#setup","title":"Setup","text":"<pre><code>import pandas as pd\nfrom LZGraphs import AAPLZGraph\nfrom LZGraphs.visualization import (\n    draw_graph,\n    ancestors_descendants_curves_plot,\n    sequence_possible_paths_plot,\n    sequence_genomic_node_variability_plot,\n    sequence_genomic_edges_variability_plot\n)\n\n# Build a graph\ndata = pd.read_csv(\"Examples/ExampleData1.csv\")\ngraph = AAPLZGraph(data, verbose=False)\n</code></pre>"},{"location":"tutorials/visualization/#drawing-the-graph","title":"Drawing the Graph","text":"<p>Visualize the graph structure:</p> <pre><code>draw_graph(graph, file_name='my_lzgraph.png')\n</code></pre> <p>This generates a PNG image showing the graph structure with nodes representing LZ76 patterns and edges showing observed transitions.</p> <p>Large graphs</p> <p>For large repertoires, the graph may be too complex to visualize effectively. Consider filtering to a subset of nodes.</p>"},{"location":"tutorials/visualization/#ancestors-and-descendants-curves","title":"Ancestors and Descendants Curves","text":"<p>This plot shows how the number of ancestors (predecessors) and descendants (successors) changes along a sequence path.</p> <pre><code>sequence = 'CASTPGTASGYTF'\nancestors_descendants_curves_plot(graph, sequence)\n</code></pre> <p></p>"},{"location":"tutorials/visualization/#interpretation","title":"Interpretation","text":"<ul> <li>Descendants curve (blue): Number of reachable nodes from each position</li> <li>Ancestors curve (orange): Number of paths leading to each position</li> <li>Intersection point: Where the sequence transitions from \"common start\" to \"specific ending\"</li> </ul>"},{"location":"tutorials/visualization/#use-cases","title":"Use Cases","text":"<ul> <li>Compare rare vs. common sequences</li> <li>Identify motifs that constrain downstream options</li> <li>Study sequence \"funneling\" patterns</li> </ul>"},{"location":"tutorials/visualization/#sequence-possible-paths","title":"Sequence Possible Paths","text":"<p>Shows the number of alternative paths (branching factor) at each position:</p> <pre><code>sequence = 'CASTPGTASGYTF'\nsequence_possible_paths_plot(graph, sequence)\n</code></pre> <p></p>"},{"location":"tutorials/visualization/#interpretation_1","title":"Interpretation","text":"<ul> <li>High values: Many alternatives at that position (common patterns)</li> <li>Low values: Few alternatives (rare patterns)</li> <li>Value of 1: Only one observed continuation</li> </ul>"},{"location":"tutorials/visualization/#correlation-with-rarity","title":"Correlation with Rarity","text":"<p>Sequences with consistently low path counts are rare in the repertoire and tend to have: - Lower generation probability - Higher Levenshtein distance from repertoire mean - Lower LZCentrality</p>"},{"location":"tutorials/visualization/#genomic-node-variability","title":"Genomic Node Variability","text":"<p>Shows V and J gene diversity at each node in a sequence:</p> <pre><code>sequence = 'CASTPGTASGYTF'\nsequence_genomic_node_variability_plot(graph, sequence)\n</code></pre> <p></p>"},{"location":"tutorials/visualization/#interpretation_2","title":"Interpretation","text":"<ul> <li>Bar height: Number of distinct V/J genes observed at that node</li> <li>High V diversity early: Expected for V-gene derived regions</li> <li>High J diversity late: Expected for J-gene derived regions</li> </ul>"},{"location":"tutorials/visualization/#requirements","title":"Requirements","text":"<p>This function requires gene annotation data (<code>V</code> and <code>J</code> columns) in your original DataFrame.</p>"},{"location":"tutorials/visualization/#genomic-edge-variability","title":"Genomic Edge Variability","text":"<p>Shows V and J gene associations for each edge transition:</p> <pre><code>sequence = 'CASTPGTASGYTF'\nsequence_genomic_edges_variability_plot(graph, sequence)\n</code></pre> <p></p>"},{"location":"tutorials/visualization/#reading-the-heatmap","title":"Reading the Heatmap","text":"<ul> <li>Rows: Gene names (V or J)</li> <li>Columns: Edge transitions</li> <li>Color intensity: Probability of that edge given the gene</li> <li>Red gene names: Gene appears in ALL edges</li> <li>Black cells: Gene not observed at that edge</li> </ul>"},{"location":"tutorials/visualization/#use-cases_1","title":"Use Cases","text":"<ul> <li>Identify gene-specific sequence motifs</li> <li>Compare gene usage between sequences</li> <li>Study CDR3 structure by gene</li> </ul>"},{"location":"tutorials/visualization/#customizing-plots","title":"Customizing Plots","text":""},{"location":"tutorials/visualization/#saving-figures","title":"Saving Figures","text":"<pre><code>import matplotlib.pyplot as plt\n\n# Create the plot\nfig = sequence_possible_paths_plot(graph, sequence)\n\n# Customize and save\nplt.title(\"Path Variability Analysis\")\nplt.tight_layout()\nplt.savefig(\"my_analysis.png\", dpi=300, bbox_inches='tight')\nplt.close()\n</code></pre>"},{"location":"tutorials/visualization/#batch-processing","title":"Batch Processing","text":"<pre><code>sequences = [\n    'CASTPGTASGYTF',\n    'CASSLEPSGGTDTQYF',\n    'CASSLGQGSTEAFF'\n]\n\nfor i, seq in enumerate(sequences):\n    ancestors_descendants_curves_plot(graph, seq)\n    plt.savefig(f\"ad_curve_{i}.png\", dpi=150)\n    plt.close()\n</code></pre>"},{"location":"tutorials/visualization/#comparing-sequences","title":"Comparing Sequences","text":"<p>Visualize differences between sequences:</p> <pre><code>import matplotlib.pyplot as plt\n\nsequences = ['CASTPGTASGYTF', 'CASSLEPSGGTDTQYF']\n\nfig, axes = plt.subplots(1, 2, figsize=(14, 5))\n\nfor ax, seq in zip(axes, sequences):\n    plt.sca(ax)\n    sequence_possible_paths_plot(graph, seq)\n    ax.set_title(seq)\n\nplt.tight_layout()\nplt.savefig(\"comparison.png\", dpi=300)\n</code></pre>"},{"location":"tutorials/visualization/#saturation-curves","title":"Saturation Curves","text":"<p>Visualize how diversity grows with sample size:</p> <pre><code>from LZGraphs import NodeEdgeSaturationProbe\nimport matplotlib.pyplot as plt\n\nsequences = data['cdr3_amino_acid'].tolist()\nprobe = NodeEdgeSaturationProbe()\n\n# Generate curve\ncurve = probe.saturation_curve(\n    sequences,\n    encoding_function=AAPLZGraph.encode_sequence,\n    steps=50\n)\n\n# Plot\nplt.figure(figsize=(10, 6))\nplt.plot(curve['sequences'], curve['nodes'], label='Nodes')\nplt.plot(curve['sequences'], curve['edges'], label='Edges')\nplt.xlabel('Number of Sequences')\nplt.ylabel('Count')\nplt.title('Node/Edge Saturation Curve')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.savefig(\"saturation_curve.png\", dpi=300)\n</code></pre>"},{"location":"tutorials/visualization/#complete-example","title":"Complete Example","text":"<pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\nfrom LZGraphs import AAPLZGraph\nfrom LZGraphs.visualization import (\n    ancestors_descendants_curves_plot,\n    sequence_possible_paths_plot,\n    sequence_genomic_node_variability_plot\n)\n\n# Load and build\ndata = pd.read_csv(\"Examples/ExampleData1.csv\")\ngraph = AAPLZGraph(data, verbose=False)\n\n# Analyze a sequence\nsequence = 'CASTPGTASGYTF'\n\n# Create multi-panel figure\nfig, axes = plt.subplots(1, 3, figsize=(18, 5))\n\n# Panel 1: Ancestors/Descendants\nplt.sca(axes[0])\nancestors_descendants_curves_plot(graph, sequence)\naxes[0].set_title(\"Ancestors &amp; Descendants\")\n\n# Panel 2: Possible Paths\nplt.sca(axes[1])\nsequence_possible_paths_plot(graph, sequence)\naxes[1].set_title(\"Path Variability\")\n\n# Panel 3: Gene Variability\nplt.sca(axes[2])\nsequence_genomic_node_variability_plot(graph, sequence)\naxes[2].set_title(\"V/J Gene Diversity\")\n\nplt.suptitle(f\"Analysis of {sequence}\", fontsize=14)\nplt.tight_layout()\nplt.savefig(\"complete_analysis.png\", dpi=300)\nplt.show()\n</code></pre>"},{"location":"tutorials/visualization/#next-steps","title":"Next Steps","text":"<ul> <li>Examples Gallery - See complete notebooks</li> <li>API: Visualization - Full function reference</li> <li>How-To: Compare Repertoires - Visual comparison workflows</li> </ul>"}]}